                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/linked-list.anchor:                     
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : this.item < 1073741823                                                                     
         ? holds(this.owner, tid) ? B : E                                                           
         : isRead ? B : E                                                                           
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
      requires this.head == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          tail.init(1073741823,List.null)                                                           
          Node head;                                                                                
          head = new Node();                                                                        
          head.init(-1073741824,List.null)                                                          
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        synchronized (this) {                                                                       
          pred := this.head;                                                                        
          curr := pred.next;                                                                        
          while (true)                                                                              
            invariant isShared(curr);                                                               
            invariant isShared(pred);                                                               
            invariant pred.item < item;                                                             
            invariant curr == pred.next;                                                            
            invariant pred.owner == this;                                                           
            invariant curr.owner == this;                                                           
            {                                                                                       
            boolean tmp1;                                                                           
            int tmp2;                                                                               
            tmp2 := curr.item;                                                                      
            tmp1 = tmp2 < item;                                                                     
            if (!tmp1) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              pred = curr;                                                                          
              curr := curr.next;                                                                    
            }                                                                                       
          }                                                                                         
          boolean tmp3;                                                                             
          int tmp4;                                                                                 
          tmp4 := curr.item;                                                                        
          tmp3 = item == tmp4;                                                                      
          if (tmp3 /* == item == curr.item */) {                                                    
             return false;                                                                          
          } else {                                                                                  
            Node node;                                                                              
            node = new Node();                                                                      
            node.init(item,this)                                                                    
            node.next := curr;                                                                      
            pred.next := node;                                                                      
             return true;                                                                           
          }                                                                                         
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        synchronized (this) {                                                                       
          pred := this.head;                                                                        
          curr := pred.next;                                                                        
          while (true)                                                                              
            invariant isShared(curr);                                                               
            invariant isShared(pred);                                                               
            invariant pred.item < item;                                                             
            invariant curr == pred.next;                                                            
            invariant pred.owner == this;                                                           
            invariant curr.owner == this;                                                           
            {                                                                                       
            boolean tmp5;                                                                           
            int tmp6;                                                                               
            tmp6 := curr.item;                                                                      
            tmp5 = tmp6 < item;                                                                     
            if (!tmp5) break; else {                                                                
                                                                                                    
            }                                                                                       
            {                                                                                       
              pred = curr;                                                                          
              curr := curr.next;                                                                    
            }                                                                                       
          }                                                                                         
          boolean tmp7;                                                                             
          int tmp8;                                                                                 
          tmp8 := curr.item;                                                                        
          tmp7 = item == tmp8;                                                                      
          if (tmp7 /* == item == curr.item */) {                                                    
            Node tmp9;                                                                              
            tmp9 := curr.next;                                                                      
            pred.next := tmp9;                                                                      
             return true;                                                                           
          } else {                                                                                  
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        synchronized (this) {                                                                       
          Node pred;                                                                                
          pred := this.head;                                                                        
          Node curr;                                                                                
          curr := pred.next;                                                                        
          while (true)                                                                              
            invariant isShared(curr);                                                               
            invariant curr.owner == this;                                                           
            invariant pred.owner == this;                                                           
            invariant curr == pred.next;                                                            
            {                                                                                       
            boolean tmp10;                                                                          
            int tmp11;                                                                              
            tmp11 := curr.item;                                                                     
            tmp10 = tmp11 < item;                                                                   
            if (!tmp10) break; else {                                                               
                                                                                                    
            }                                                                                       
            {                                                                                       
              pred = curr;                                                                          
              curr := curr.next;                                                                    
            }                                                                                       
          }                                                                                         
          boolean tmp12;                                                                            
          int tmp13;                                                                                
          tmp13 := curr.item;                                                                       
          tmp12 = item == tmp13;                                                                    
           return tmp12;                                                                            
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : this.item < 1073741823                                                                     
         ? holds(this.owner, tid) ? B : E                                                           
         : isRead ? B : E                                                                           
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
      requires this.head == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          tail.init(1073741823,List.null)                                                           
          Node head;                                                                                
          head = new Node();                                                                        
          head.init(-1073741824,List.null)                                                          
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant curr == pred.next;                                                          
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := curr.item;                                                                    
              tmp1 = tmp2 < item;                                                                   
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp3;                                                                           
            int tmp4;                                                                               
            tmp4 := curr.item;                                                                      
            tmp3 = item == tmp4;                                                                    
            if (tmp3 /* == item == curr.item */) {                                                  
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            } else {                                                                                
              Node node;                                                                            
              node = new Node();                                                                    
              node.init(item,this)                                                                  
              node.next := curr;                                                                    
              pred.next := node;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant curr == pred.next;                                                          
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp5;                                                                         
              int tmp6;                                                                             
              tmp6 := curr.item;                                                                    
              tmp5 = tmp6 < item;                                                                   
              if (!tmp5) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            int tmp8;                                                                               
            tmp8 := curr.item;                                                                      
            tmp7 = item == tmp8;                                                                    
            if (tmp7 /* == item == curr.item */) {                                                  
              Node tmp9;                                                                            
              tmp9 := curr.next;                                                                    
              pred.next := tmp9;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant curr.owner == this;                                                         
              invariant pred.owner == this;                                                         
              invariant curr == pred.next;                                                          
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp10;                                                                        
              int tmp11;                                                                            
              tmp11 := curr.item;                                                                   
              tmp10 = tmp11 < item;                                                                 
              if (!tmp10) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := curr.item;                                                                     
            tmp12 = item == tmp13;                                                                  
            {                                                                                       
              release(this);                                                                        
               return tmp12;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : this.item < 1073741823                                                                     
         ? holds(this.owner, tid) ? B : E                                                           
         : isRead ? B : E                                                                           
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
      requires this.head == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          {                                                                                         
            inlined tail.init(1073741823,List.null);                                                
            exit$209: {                                                                             
              int item$209;                                                                         
              List owner$209;                                                                       
              Node this$209;                                                                        
              item$209 = 1073741823;                                                                
              owner$209 = List.null;                                                                
              this$209 = tail;                                                                      
              {                                                                                     
                assume this$209.item == 0;                                                          
                assume this$209.next == Node.null;                                                  
                assume this$209.owner == List.null;                                                 
                {                                                                                   
                  this$209.item := item$209;                                                        
                  this$209.owner := owner$209;                                                      
                  {                                                                                 
                    break exit$209;                                                                 
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          Node head;                                                                                
          head = new Node();                                                                        
          {                                                                                         
            inlined head.init(-1073741824,List.null);                                               
            exit$210: {                                                                             
              int item$210;                                                                         
              List owner$210;                                                                       
              Node this$210;                                                                        
              item$210 = -1073741824;                                                               
              owner$210 = List.null;                                                                
              this$210 = head;                                                                      
              {                                                                                     
                assume this$210.item == 0;                                                          
                assume this$210.next == Node.null;                                                  
                assume this$210.owner == List.null;                                                 
                {                                                                                   
                  this$210.item := item$210;                                                        
                  this$210.owner := owner$210;                                                      
                  {                                                                                 
                    break exit$210;                                                                 
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant curr == pred.next;                                                          
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := curr.item;                                                                    
              tmp1 = tmp2 < item;                                                                   
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp3;                                                                           
            int tmp4;                                                                               
            tmp4 := curr.item;                                                                      
            tmp3 = item == tmp4;                                                                    
            if (tmp3 /* == item == curr.item */) {                                                  
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            } else {                                                                                
              Node node;                                                                            
              node = new Node();                                                                    
              {                                                                                     
                inlined node.init(item,this);                                                       
                exit$211: {                                                                         
                  int item$211;                                                                     
                  List owner$211;                                                                   
                  Node this$211;                                                                    
                  item$211 = item;                                                                  
                  owner$211 = this;                                                                 
                  this$211 = node;                                                                  
                  {                                                                                 
                    assume this$211.item == 0;                                                      
                    assume this$211.next == Node.null;                                              
                    assume this$211.owner == List.null;                                             
                    {                                                                               
                      this$211.item := item$211;                                                    
                      this$211.owner := owner$211;                                                  
                      {                                                                             
                        break exit$211;                                                             
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              node.next := curr;                                                                    
              pred.next := node;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant curr == pred.next;                                                          
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp5;                                                                         
              int tmp6;                                                                             
              tmp6 := curr.item;                                                                    
              tmp5 = tmp6 < item;                                                                   
              if (!tmp5) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            int tmp8;                                                                               
            tmp8 := curr.item;                                                                      
            tmp7 = item == tmp8;                                                                    
            if (tmp7 /* == item == curr.item */) {                                                  
              Node tmp9;                                                                            
              tmp9 := curr.next;                                                                    
              pred.next := tmp9;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant curr.owner == this;                                                         
              invariant pred.owner == this;                                                         
              invariant curr == pred.next;                                                          
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp10;                                                                        
              int tmp11;                                                                            
              tmp11 := curr.item;                                                                   
              tmp10 = tmp11 < item;                                                                 
              if (!tmp10) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := curr.item;                                                                     
            tmp12 = item == tmp13;                                                                  
            {                                                                                       
              release(this);                                                                        
               return tmp12;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Node next isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : this.item < 1073741823                                                                     
         ? holds(this.owner, tid) ? B : E                                                           
         : isRead ? B : E                                                                           
                                                                                                    
       List owner isLocal(this, tid)                                                                
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.next != Node.null ==> this.owner == this.next.owner;                          
      invariant  this.owner != List.null;                                                           
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next != Node.null ==> this.item < this.next.item;                             
      invariant  this.next == Node.null ==> this.item == 1073741823;                                
                                                                                                    
                                                                                                    
                                                                                                    
      void init(int item,List owner) {                                                              
        assume this.item == 0;                                                                      
        assume this.next == Node.null;                                                              
        assume this.owner == List.null;                                                             
        {                                                                                           
          this.item := item;                                                                        
          this.owner := owner;                                                                      
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.owner == this;                                                           
                                                                                                    
      requires this.head == Node.null;                                                              
                                                                                                    
      public void init() {                                                                          
        assume this.head == Node.null;                                                              
        {                                                                                           
          Node tail;                                                                                
          tail = new Node();                                                                        
          {                                                                                         
            inlined tail.init(1073741823,List.null);                                                
            exit$209: {                                                                             
              int item$209;                                                                         
              List owner$209;                                                                       
              Node this$209;                                                                        
              item$209 = 1073741823;                                                                
              owner$209 = List.null;                                                                
              this$209 = tail;                                                                      
              {                                                                                     
                assume this$209.item == 0;                                                          
                assume this$209.next == Node.null;                                                  
                assume this$209.owner == List.null;                                                 
                {                                                                                   
                  this$209.item := item$209;                                                        
                  this$209.owner := owner$209;                                                      
                  {                                                                                 
                    break exit$209;                                                                 
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          Node head;                                                                                
          head = new Node();                                                                        
          {                                                                                         
            inlined head.init(-1073741824,List.null);                                               
            exit$210: {                                                                             
              int item$210;                                                                         
              List owner$210;                                                                       
              Node this$210;                                                                        
              item$210 = -1073741824;                                                               
              owner$210 = List.null;                                                                
              this$210 = head;                                                                      
              {                                                                                     
                assume this$210.item == 0;                                                          
                assume this$210.next == Node.null;                                                  
                assume this$210.owner == List.null;                                                 
                {                                                                                   
                  this$210.item := item$210;                                                        
                  this$210.owner := owner$210;                                                      
                  {                                                                                 
                    break exit$210;                                                                 
                  }                                                                                 
                }                                                                                   
              }                                                                                     
            }                                                                                       
            inlined return;                                                                         
          }                                                                                         
          tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        Node pred;                                                                                  
        Node curr;                                                                                  
        int key;                                                                                    
        key = item;                                                                                 
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant curr == pred.next;                                                          
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp1;                                                                         
              int tmp2;                                                                             
              tmp2 := curr.item;                                                                    
              tmp1 = tmp2 < item;                                                                   
              if (!tmp1) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp3;                                                                           
            int tmp4;                                                                               
            tmp4 := curr.item;                                                                      
            tmp3 = item == tmp4;                                                                    
            if (tmp3 /* == item == curr.item */) {                                                  
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            } else {                                                                                
              Node node;                                                                            
              node = new Node();                                                                    
              {                                                                                     
                inlined node.init(item,this);                                                       
                exit$211: {                                                                         
                  int item$211;                                                                     
                  List owner$211;                                                                   
                  Node this$211;                                                                    
                  item$211 = item;                                                                  
                  owner$211 = this;                                                                 
                  this$211 = node;                                                                  
                  {                                                                                 
                    assume this$211.item == 0;                                                      
                    assume this$211.next == Node.null;                                              
                    assume this$211.owner == List.null;                                             
                    {                                                                               
                      this$211.item := item$211;                                                    
                      this$211.owner := owner$211;                                                  
                      {                                                                             
                        break exit$211;                                                             
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              node.next := curr;                                                                    
              pred.next := node;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean remove(int item) {                                                             
        Node pred;                                                                                  
        Node curr;                                                                                  
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            pred := this.head;                                                                      
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant isShared(pred);                                                             
              invariant pred.item < item;                                                           
              invariant curr == pred.next;                                                          
              invariant pred.owner == this;                                                         
              invariant curr.owner == this;                                                         
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp5;                                                                         
              int tmp6;                                                                             
              tmp6 := curr.item;                                                                    
              tmp5 = tmp6 < item;                                                                   
              if (!tmp5) {                                                                          
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp7;                                                                           
            int tmp8;                                                                               
            tmp8 := curr.item;                                                                      
            tmp7 = item == tmp8;                                                                    
            if (tmp7 /* == item == curr.item */) {                                                  
              Node tmp9;                                                                            
              tmp9 := curr.next;                                                                    
              pred.next := tmp9;                                                                    
              {                                                                                     
                release(this);                                                                      
                 return true;                                                                       
              }                                                                                     
            } else {                                                                                
              {                                                                                     
                release(this);                                                                      
                 return false;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean contains(int item) {                                                           
        {                                                                                           
          acquire(this);                                                                            
          {                                                                                         
            Node pred;                                                                              
            pred := this.head;                                                                      
            Node curr;                                                                              
            curr := pred.next;                                                                      
            while (true)                                                                            
              invariant isShared(curr);                                                             
              invariant curr.owner == this;                                                         
              invariant pred.owner == this;                                                         
              invariant curr == pred.next;                                                          
              invariant holds(this, tid);                                                           
              {                                                                                     
              boolean tmp10;                                                                        
              int tmp11;                                                                            
              tmp11 := curr.item;                                                                   
              tmp10 = tmp11 < item;                                                                 
              if (!tmp10) {                                                                         
                break;                                                                              
              } else {                                                                              
                                                                                                    
              }                                                                                     
              {                                                                                     
                pred = curr;                                                                        
                curr := curr.next;                                                                  
              }                                                                                     
            }                                                                                       
            boolean tmp12;                                                                          
            int tmp13;                                                                              
            tmp13 := curr.item;                                                                     
            tmp12 = item == tmp13;                                                                  
            {                                                                                       
              release(this);                                                                        
               return tmp12;                                                                        
            }                                                                                       
          }                                                                                         
          release(this);                                                                            
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.item: [Node]int;                                                                           
                                                                                                    
function {:inline} ReadEval.Node.item(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.item(tid: Tid,this : Node,newValue: int,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((Node.item[this]<1073741823)) then                                                            
   if ((isAccessible(List._state[Node.owner[this]], tid) && List._lock[Node.owner[this]] == tid)) then
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (isRead) then                                                                                 
    moverPath(_B, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((Node.item[this]<1073741823)) then                                                            
   if ((isAccessible(List._state[Node.owner[this]], tid) && List._lock[Node.owner[this]] == tid)) then
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (isRead) then                                                                                 
    moverPath(_B, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.owner: [Node]List;                                                                         
                                                                                                    
function {:inline} ReadEval.Node.owner(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := List.null;                                                                        
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.owner(tid: Tid,this : Node,newValue: List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Node.2339509(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((Node.next[this]!=Node.null)==>(Node.owner[this]==Node.owner[Node.next[this]]))                   
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2339517(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 (Node.owner[this]!=List.null)                                                                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2339532(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((-1073741824<=Node.item[this])&&(Node.item[this]<=1073741823))                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2339549(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((Node.next[this]!=Node.null)==>(Node.item[this]<Node.item[Node.next[this]]))                      
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2339565(tid: Tid,this : Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((Node.next[this]==Node.null)==>(Node.item[this]==1073741823))                                     
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl List ***/                                                                           
                                                                                                    
type List;                                                                                          
const unique List.null: List;                                                                       
var List._state: [List]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var List.head: [List]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.List.head(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(List._state[this], tid)) then                                                          
  if (isLocal(List._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.List.head(tid: Tid,this : List,newValue: Node,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(List._state[this], tid)) then                                                          
  if (isLocal(List._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var List._lock: [List]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.List._lock(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(List._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((List._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((List._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((List._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.List._lock(tid: Tid,this : List,newValue: Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(List._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((List._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((List._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((List._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.List.2340192(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((List.head[this]!=Node.null)&&(Node.item[List.head[this]]==-1073741824))                          
}                                                                                                   
                                                                                                    
function {:inline} Invariant.List.2340199(tid: Tid,this : List,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 (Node.owner[List.head[this]]==this)                                                                
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  List.init(tid:Tid, this : List)                                                          
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (33.5): Bad tid
requires isLocal(List._state[this], tid);                                                           
requires (forall _x : List :: this != _x ==> !isLocal(List._state[_x], tid));                       
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
requires (List.head[this]==Node.null);                                                              
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && _this != this ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && _this != this ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.5): Object invariant may not hold.
{                                                                                                   
 var this$2102346597: Node;                                                                         
 var Node.owner2346618: [Node]List;                                                                 
 var head2346624: Node;                                                                             
 var path2346624: int;                                                                              
 var owner$209: List;                                                                               
 var $pc2346531: Phase;                                                                             
 var this$2092346531: Node;                                                                         
 var tid2346597: Tid;                                                                               
 var Node._state2346627: [Node]State;                                                               
 var Node.item2346621: [Node]int;                                                                   
 var mover2346627: Mover;                                                                           
 var item$2102346600: int;                                                                          
 var List.head2346621: [List]Node;                                                                  
 var this2346600: List;                                                                             
 var Node._lock2346618: [Node]Tid;                                                                  
 var tail2346597: Node;                                                                             
 var List._state2346534: [List]State;                                                               
 var Node.owner2346600: [Node]List;                                                                 
 var head2346627: Node;                                                                             
 var head2346597: Node;                                                                             
 var $recorded.state2346627: int;                                                                   
 var mover2346621: Mover;                                                                           
 var path2346531: int;                                                                              
 var Node.next2346597: [Node]Node;                                                                  
 var tid2346600: Tid;                                                                               
 var mover2346534: Mover;                                                                           
 var tid2346621: Tid;                                                                               
 var head: Node;                                                                                    
 var Node.item2346531: [Node]int;                                                                   
 var $recorded.state2346531: int;                                                                   
 var moverPath2346531: MoverPath;                                                                   
 var Node._state2346531: [Node]State;                                                               
 var Node.next2346627: [Node]Node;                                                                  
 var owner$2092346531: List;                                                                        
 var owner$210: List;                                                                               
 var moverPath2346621: MoverPath;                                                                   
 var List.head2346629: [List]Node;                                                                  
 var List._state2346621: [List]State;                                                               
 var Node.next2346600: [Node]Node;                                                                  
 var tid2346534: Tid;                                                                               
 var $recorded.state2346621: int;                                                                   
 var head2346629: Node;                                                                             
 var $pc2346618: Phase;                                                                             
 var List._lock2346531: [List]Tid;                                                                  
 var List.head2346531: [List]Node;                                                                  
 var Node.next2346531: [Node]Node;                                                                  
 var this$210: Node;                                                                                
 var item$2092346531: int;                                                                          
 var item$210: int;                                                                                 
 var List.head2346618: [List]Node;                                                                  
 var path2346597: int;                                                                              
 var moverPath2346624: MoverPath;                                                                   
 var tail2346621: Node;                                                                             
 var this2346624: List;                                                                             
 var this2346629: List;                                                                             
 var Node.next2346534: [Node]Node;                                                                  
 var List.head2346627: [List]Node;                                                                  
 var List._state2346531: [List]State;                                                               
 var this2346621: List;                                                                             
 var mover2346531: Mover;                                                                           
 var this2346531: List;                                                                             
 var Node.item2346627: [Node]int;                                                                   
 var Node._lock2346597: [Node]Tid;                                                                  
 var tail2346534: Node;                                                                             
 var List.head2346534: [List]Node;                                                                  
 var this2346618: List;                                                                             
 var this2346627: List;                                                                             
 var $pc2346600: Phase;                                                                             
 var head2346618: Node;                                                                             
 var this$209: Node;                                                                                
 var Node._lock2346624: [Node]Tid;                                                                  
 var List._lock2346621: [List]Tid;                                                                  
 var Node._lock2346534: [Node]Tid;                                                                  
 var Node._state2346618: [Node]State;                                                               
 var owner$2092346534: List;                                                                        
 var Node._state2346624: [Node]State;                                                               
 var Node.item2346600: [Node]int;                                                                   
 var Node.owner2346627: [Node]List;                                                                 
 var List._lock2346618: [List]Tid;                                                                  
 var head2346621: Node;                                                                             
 var Node.owner2346597: [Node]List;                                                                 
 var List._state2346597: [List]State;                                                               
 var Node._lock2346621: [Node]Tid;                                                                  
 var mover2346600: Mover;                                                                           
 var tid2346624: Tid;                                                                               
 var Node._state2346597: [Node]State;                                                               
 var item$209: int;                                                                                 
 var List._lock2346597: [List]Tid;                                                                  
 var List._lock2346600: [List]Tid;                                                                  
 var Node.owner2346629: [Node]List;                                                                 
 var List.head2346597: [List]Node;                                                                  
 var List.head2346600: [List]Node;                                                                  
 var mover2346624: Mover;                                                                           
 var Node.item2346534: [Node]int;                                                                   
 var tail2346629: Node;                                                                             
 var path2346534: int;                                                                              
 var owner$2102346597: List;                                                                        
 var Node._lock2346627: [Node]Tid;                                                                  
 var List._lock2346629: [List]Tid;                                                                  
 var moverPath2346597: MoverPath;                                                                   
 var Node.next2346621: [Node]Node;                                                                  
 var Node.owner2346624: [Node]List;                                                                 
 var $pc2346621: Phase;                                                                             
 var this$2092346534: Node;                                                                         
 var List._state2346624: [List]State;                                                               
 var $recorded.state2346618: int;                                                                   
 var $recorded.state2346600: int;                                                                   
 var Node._state2346629: [Node]State;                                                               
 var tail2346627: Node;                                                                             
 var mover2346618: Mover;                                                                           
 var Node._state2346621: [Node]State;                                                               
 var tid2346531: Tid;                                                                               
 var moverPath2346627: MoverPath;                                                                   
 var moverPath2346600: MoverPath;                                                                   
 var moverPath2346534: MoverPath;                                                                   
 var List._lock2346624: [List]Tid;                                                                  
 var this2346534: List;                                                                             
 var path2346621: int;                                                                              
 var tid2346629: Tid;                                                                               
 var Node._lock2346600: [Node]Tid;                                                                  
 var Node.next2346624: [Node]Node;                                                                  
 var tail2346618: Node;                                                                             
 var tid2346618: Tid;                                                                               
 var List.head2346624: [List]Node;                                                                  
 var item$2102346597: int;                                                                          
 var $pc2346629: Phase;                                                                             
 var path2346600: int;                                                                              
 var Node._lock2346629: [Node]Tid;                                                                  
 var owner$2102346600: List;                                                                        
 var List._state2346629: [List]State;                                                               
 var $pc2346597: Phase;                                                                             
 var List._lock2346627: [List]Tid;                                                                  
 var List._state2346627: [List]State;                                                               
 var Node.next2346618: [Node]Node;                                                                  
 var $pc2346534: Phase;                                                                             
 var tail2346600: Node;                                                                             
 var Node.item2346597: [Node]int;                                                                   
 var $pc2346624: Phase;                                                                             
 var $pc2346627: Phase;                                                                             
 var Node._state2346534: [Node]State;                                                               
 var Node.item2346629: [Node]int;                                                                   
 var path2346618: int;                                                                              
 var this2346597: List;                                                                             
 var Node._lock2346531: [Node]Tid;                                                                  
 var $recorded.state2346629: int;                                                                   
 var List._state2346600: [List]State;                                                               
 var tid2346627: Tid;                                                                               
 var head2346600: Node;                                                                             
 var Node.owner2346534: [Node]List;                                                                 
 var $recorded.state2346624: int;                                                                   
 var item$2092346534: int;                                                                          
 var $recorded.state2346597: int;                                                                   
 var Node.next2346629: [Node]Node;                                                                  
 var Node.owner2346621: [Node]List;                                                                 
 var tail: Node;                                                                                    
 var List._state2346618: [List]State;                                                               
 var List._lock2346534: [List]Tid;                                                                  
 var tail2346624: Node;                                                                             
 var Node.item2346618: [Node]int;                                                                   
 var Node.item2346624: [Node]int;                                                                   
 var Node.owner2346531: [Node]List;                                                                 
 var Node._state2346600: [Node]State;                                                               
 var $recorded.state2346534: int;                                                                   
 var mover2346597: Mover;                                                                           
 var tail2346531: Node;                                                                             
 var path2346627: int;                                                                              
 var this$2102346600: Node;                                                                         
 var moverPath2346618: MoverPath;                                                                   
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)),_R);       // (33.5): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 33.5: assume this.head == Node.null;                                                            
                                                                                                    
 assume (List.head[this]==Node.null);                                                               
                                                                                                    
 // 34.9: Node tail;                                                                                
                                                                                                    
                                                                                                    
 // 34.9: tail = new Node();                                                                        
                                                                                                    
 havoc tail;                                                                                        
 assume tail != Node.null && isFresh(Node._state[tail]);                                            
 Node._state[tail] := LOCAL(tid);                                                                   
 assume Node.item[tail]  == 0;                                                                      
 assume Node.next[tail]  == Node.null;                                                              
 assume Node.owner[tail]  == List.null;                                                             
 assume Node._lock[tail]  == Tid.null;                                                              
 // inlined: tail.init(1073741823,List.null)}                                                       
 exit$209_top:                                                                                      
                                                                                                    
 // 34.9: int item$209;                                                                             
                                                                                                    
                                                                                                    
 // 34.9: List owner$209;                                                                           
                                                                                                    
                                                                                                    
 // 34.9: Node this$209;                                                                            
                                                                                                    
                                                                                                    
 // 34.9: item$209 = 1073741823;                                                                    
                                                                                                    
 item$209 := 1073741823;                                                                            
                                                                                                    
 // 34.9: owner$209 = List.null;                                                                    
                                                                                                    
 owner$209 := List.null;                                                                            
                                                                                                    
 // 34.9: this$209 = tail;                                                                          
                                                                                                    
 this$209 := tail;                                                                                  
                                                                                                    
 // 19.5: assume this$209.item == 0;                                                                
                                                                                                    
 assume (Node.item[this$209]==0);                                                                   
                                                                                                    
 // 19.5: assume this$209.next == Node.null;                                                        
                                                                                                    
 assume (Node.next[this$209]==Node.null);                                                           
                                                                                                    
 // 19.5: assume this$209.owner == List.null;                                                       
                                                                                                    
 assume (Node.owner[this$209]==List.null);                                                          
                                                                                                    
                                                                                                    
 // 20.9: this$209.item := item$209;                                                                
                                                                                                    
                                                                                                    
 moverPath2346531 := WriteEval.Node.item(tid: Tid,this$209: Node,item$209: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346531 := m#moverPath(moverPath2346531);                                                     
 path2346531 := p#moverPath(moverPath2346531);                                                      
 assume Node._state2346531 == Node._state && Node.item2346531 == Node.item && Node.next2346531 == Node.next && Node.owner2346531 == Node.owner && Node._lock2346531 == Node._lock && List._state2346531 == List._state && List.head2346531 == List.head && List._lock2346531 == List._lock && this$2092346531 == this$209 && owner$2092346531 == owner$209 && item$2092346531 == item$209 && tail2346531 == tail && this2346531 == this && tid2346531 == tid && $pc2346531 == $pc;
 assume $recorded.state2346531 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$209 != Node.null;                                                                     
 } else {                                                                                           
  assert this$209 != Node.null;                                                                            // (20.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2346531);                                                              
 assert $pc != PhaseError;                                                                                 // (20.9): Reduction failure
 Node.item[this$209] := item$209;                                                                   
                                                                                                    
                                                                                                    
 // 21.9: this$209.owner := owner$209;                                                              
                                                                                                    
                                                                                                    
 moverPath2346534 := WriteEval.Node.owner(tid: Tid,this$209: Node,owner$209: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346534 := m#moverPath(moverPath2346534);                                                     
 path2346534 := p#moverPath(moverPath2346534);                                                      
 assume Node._state2346534 == Node._state && Node.item2346534 == Node.item && Node.next2346534 == Node.next && Node.owner2346534 == Node.owner && Node._lock2346534 == Node._lock && List._state2346534 == List._state && List.head2346534 == List.head && List._lock2346534 == List._lock && this$2092346534 == this$209 && owner$2092346534 == owner$209 && item$2092346534 == item$209 && tail2346534 == tail && this2346534 == this && tid2346534 == tid && $pc2346534 == $pc;
 assume $recorded.state2346534 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$209 != Node.null;                                                                     
 } else {                                                                                           
  assert this$209 != Node.null;                                                                            // (21.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2346534);                                                              
 assert $pc != PhaseError;                                                                                 // (21.9): Reduction failure
 Node.owner[this$209] := owner$209;                                                                 
 if (isLocal(List._state[owner$209], tid)) {                                                        
  List._state[owner$209] := SHARED();                                                               
  assert isSharedAssignable(Node._state[List.head[owner$209]]);                                            // (21.9): owner$209 became shared, but owner$209.head may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 19.32: break exit$209;                                                                          
                                                                                                    
 goto exit$209_bottom;                                                                              
 exit$209_bottom:                                                                                   
                                                                                                    
 // 35.9: Node head;                                                                                
                                                                                                    
                                                                                                    
 // 35.9: head = new Node();                                                                        
                                                                                                    
 havoc head;                                                                                        
 assume head != Node.null && isFresh(Node._state[head]);                                            
 Node._state[head] := LOCAL(tid);                                                                   
 assume Node.item[head]  == 0;                                                                      
 assume Node.next[head]  == Node.null;                                                              
 assume Node.owner[head]  == List.null;                                                             
 assume Node._lock[head]  == Tid.null;                                                              
 // inlined: head.init(-1073741824,List.null)}                                                      
 exit$210_top:                                                                                      
                                                                                                    
 // 35.9: int item$210;                                                                             
                                                                                                    
                                                                                                    
 // 35.9: List owner$210;                                                                           
                                                                                                    
                                                                                                    
 // 35.9: Node this$210;                                                                            
                                                                                                    
                                                                                                    
 // 35.9: item$210 = -1073741824;                                                                   
                                                                                                    
 item$210 := -1073741824;                                                                           
                                                                                                    
 // 35.9: owner$210 = List.null;                                                                    
                                                                                                    
 owner$210 := List.null;                                                                            
                                                                                                    
 // 35.9: this$210 = head;                                                                          
                                                                                                    
 this$210 := head;                                                                                  
                                                                                                    
 // 19.5: assume this$210.item == 0;                                                                
                                                                                                    
 assume (Node.item[this$210]==0);                                                                   
                                                                                                    
 // 19.5: assume this$210.next == Node.null;                                                        
                                                                                                    
 assume (Node.next[this$210]==Node.null);                                                           
                                                                                                    
 // 19.5: assume this$210.owner == List.null;                                                       
                                                                                                    
 assume (Node.owner[this$210]==List.null);                                                          
                                                                                                    
                                                                                                    
 // 20.9: this$210.item := item$210;                                                                
                                                                                                    
                                                                                                    
 moverPath2346597 := WriteEval.Node.item(tid: Tid,this$210: Node,item$210: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346597 := m#moverPath(moverPath2346597);                                                     
 path2346597 := p#moverPath(moverPath2346597);                                                      
 assume Node._state2346597 == Node._state && Node.item2346597 == Node.item && Node.next2346597 == Node.next && Node.owner2346597 == Node.owner && Node._lock2346597 == Node._lock && List._state2346597 == List._state && List.head2346597 == List.head && List._lock2346597 == List._lock && this$2102346597 == this$210 && owner$2102346597 == owner$210 && item$2102346597 == item$210 && head2346597 == head && tail2346597 == tail && this2346597 == this && tid2346597 == tid && $pc2346597 == $pc;
 assume $recorded.state2346597 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$210 != Node.null;                                                                     
 } else {                                                                                           
  assert this$210 != Node.null;                                                                            // (20.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2346597);                                                              
 assert $pc != PhaseError;                                                                                 // (20.9): Reduction failure
 Node.item[this$210] := item$210;                                                                   
                                                                                                    
                                                                                                    
 // 21.9: this$210.owner := owner$210;                                                              
                                                                                                    
                                                                                                    
 moverPath2346600 := WriteEval.Node.owner(tid: Tid,this$210: Node,owner$210: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346600 := m#moverPath(moverPath2346600);                                                     
 path2346600 := p#moverPath(moverPath2346600);                                                      
 assume Node._state2346600 == Node._state && Node.item2346600 == Node.item && Node.next2346600 == Node.next && Node.owner2346600 == Node.owner && Node._lock2346600 == Node._lock && List._state2346600 == List._state && List.head2346600 == List.head && List._lock2346600 == List._lock && this$2102346600 == this$210 && owner$2102346600 == owner$210 && item$2102346600 == item$210 && head2346600 == head && tail2346600 == tail && this2346600 == this && tid2346600 == tid && $pc2346600 == $pc;
 assume $recorded.state2346600 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this$210 != Node.null;                                                                     
 } else {                                                                                           
  assert this$210 != Node.null;                                                                            // (21.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover2346600);                                                              
 assert $pc != PhaseError;                                                                                 // (21.9): Reduction failure
 Node.owner[this$210] := owner$210;                                                                 
 if (isLocal(List._state[owner$210], tid)) {                                                        
  List._state[owner$210] := SHARED();                                                               
  assert isSharedAssignable(Node._state[List.head[owner$210]]);                                            // (21.9): owner$210 became shared, but owner$210.head may not be shared.
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 19.32: break exit$210;                                                                          
                                                                                                    
 goto exit$210_bottom;                                                                              
 exit$210_bottom:                                                                                   
                                                                                                    
 // 36.9: tail.owner := this, this.head := head, head.owner := this, head.next := tail;             
                                                                                                    
 assert $pc == PreCommit;                                                                                  // (36.9): Local Write block must appear pre commit.
                                                                                                    
 // 36.9: tail.owner := this;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346618 := WriteEval.Node.owner(tid: Tid,tail: Node,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346618 := m#moverPath(moverPath2346618);                                                     
 path2346618 := p#moverPath(moverPath2346618);                                                      
 assume Node._state2346618 == Node._state && Node.item2346618 == Node.item && Node.next2346618 == Node.next && Node.owner2346618 == Node.owner && Node._lock2346618 == Node._lock && List._state2346618 == List._state && List.head2346618 == List.head && List._lock2346618 == List._lock && head2346618 == head && tail2346618 == tail && this2346618 == this && tid2346618 == tid && $pc2346618 == $pc;
 assume $recorded.state2346618 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume tail != Node.null;                                                                         
 } else {                                                                                           
  assert tail != Node.null;                                                                                // (36.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346618);                                                              
 assert $pc != PhaseError;                                                                                 // (36.9): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.9): Local Write block can only include right-movers.
 Node.owner[tail] := this;                                                                          
                                                                                                    
 // 36.28: this.head := head;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346621 := WriteEval.List.head(tid: Tid,this: List,head: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346621 := m#moverPath(moverPath2346621);                                                     
 path2346621 := p#moverPath(moverPath2346621);                                                      
 assume Node._state2346621 == Node._state && Node.item2346621 == Node.item && Node.next2346621 == Node.next && Node.owner2346621 == Node.owner && Node._lock2346621 == Node._lock && List._state2346621 == List._state && List.head2346621 == List.head && List._lock2346621 == List._lock && head2346621 == head && tail2346621 == tail && this2346621 == this && tid2346621 == tid && $pc2346621 == $pc;
 assume $recorded.state2346621 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (36.28): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346621);                                                              
 assert $pc != PhaseError;                                                                                 // (36.28): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.28): Local Write block can only include right-movers.
 List.head[this] := head;                                                                           
                                                                                                    
 // 36.46: head.owner := this;                                                                      
                                                                                                    
                                                                                                    
 moverPath2346624 := WriteEval.Node.owner(tid: Tid,head: Node,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346624 := m#moverPath(moverPath2346624);                                                     
 path2346624 := p#moverPath(moverPath2346624);                                                      
 assume Node._state2346624 == Node._state && Node.item2346624 == Node.item && Node.next2346624 == Node.next && Node.owner2346624 == Node.owner && Node._lock2346624 == Node._lock && List._state2346624 == List._state && List.head2346624 == List.head && List._lock2346624 == List._lock && head2346624 == head && tail2346624 == tail && this2346624 == this && tid2346624 == tid && $pc2346624 == $pc;
 assume $recorded.state2346624 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume head != Node.null;                                                                         
 } else {                                                                                           
  assert head != Node.null;                                                                                // (36.46): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346624);                                                              
 assert $pc != PhaseError;                                                                                 // (36.46): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.46): Local Write block can only include right-movers.
 Node.owner[head] := this;                                                                          
                                                                                                    
 // 36.65: head.next := tail;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346627 := WriteEval.Node.next(tid: Tid,head: Node,tail: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346627 := m#moverPath(moverPath2346627);                                                     
 path2346627 := p#moverPath(moverPath2346627);                                                      
 assume Node._state2346627 == Node._state && Node.item2346627 == Node.item && Node.next2346627 == Node.next && Node.owner2346627 == Node.owner && Node._lock2346627 == Node._lock && List._state2346627 == List._state && List.head2346627 == List.head && List._lock2346627 == List._lock && head2346627 == head && tail2346627 == tail && this2346627 == this && tid2346627 == tid && $pc2346627 == $pc;
 assume $recorded.state2346627 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume head != Node.null;                                                                         
 } else {                                                                                           
  assert head != Node.null;                                                                                // (36.65): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346627);                                                              
 assert $pc != PhaseError;                                                                                 // (36.65): Reduction failure
 assert $pc == PreCommit;                                                                                  // (36.65): Local Write block can only include right-movers.
 Node.next[head] := tail;                                                                           
 assert isLocal(List._state[this], tid);                                                                   // (36.9): Can only have local designators in Local Write block.
 assert isLocal(Node._state[head], tid);                                                                   // (36.28): Can only have local designators in Local Write block.
 assert isLocal(List._state[this], tid);                                                                   // (36.46): Can only have local designators in Local Write block.
 assert isLocal(Node._state[tail], tid);                                                                   // (36.65): Can only have local designators in Local Write block.
 List._state[this] := SHARED();                                                                     
 Node._state[head] := SHARED();                                                                     
 List._state[this] := SHARED();                                                                     
 Node._state[tail] := SHARED();                                                                     
 assert isSharedAssignable(Node._state[List.head[this]]);                                                  // (36.9): this became shared, but this.head may not be shared.
 assert isSharedAssignable(Node._state[Node.next[head]]);                                                  // (36.28): head became shared, but head.next may not be shared.
 assert isSharedAssignable(List._state[Node.owner[head]]);                                                 // (36.28): head became shared, but head.owner may not be shared.
 assert isSharedAssignable(Node._state[List.head[this]]);                                                  // (36.46): this became shared, but this.head may not be shared.
 assert isSharedAssignable(Node._state[Node.next[tail]]);                                                  // (36.65): tail became shared, but tail.next may not be shared.
 assert isSharedAssignable(List._state[Node.owner[tail]]);                                                 // (36.65): tail became shared, but tail.owner may not be shared.
                                                                                                    
 // 33.19: // return;                                                                               
                                                                                                    
 assume Node._state2346629 == Node._state && Node.item2346629 == Node.item && Node.next2346629 == Node.next && Node.owner2346629 == Node.owner && Node._lock2346629 == Node._lock && List._state2346629 == List._state && List.head2346629 == List.head && List._lock2346629 == List._lock && head2346629 == head && tail2346629 == tail && this2346629 == this && tid2346629 == tid;
 assume $recorded.state2346629 == 1;                                                                
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.19): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.19): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.19): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.19): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.19): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.19): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (33.19): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  List.add(tid:Tid, this : List, item : int)                                               
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (39.5): Bad tid
requires isShared(List._state[this]);                                                                      // (39.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
requires ((-1073741824<item)&&(item<1073741823));                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (39.5): Object invariant may not hold.
{                                                                                                   
 var Node.owner2346650: [Node]List;                                                                 
 var List.head2346754: [List]Node;                                                                  
 var curr2346653: Node;                                                                             
 var tmp32346777: bool;                                                                             
 var List._lock2346690: [List]Tid;                                                                  
 var tmp42346754: int;                                                                              
 var List._state2346777: [List]State;                                                               
 var $pc2346701: Phase;                                                                             
 var Node.item2346681_bottom: [Node]int;                                                            
 var List.head2346769: [List]Node;                                                                  
 var Node._state2346769: [Node]State;                                                               
 var List._lock2346681_bottom: [List]Tid;                                                           
 var tmp12346662: bool;                                                                             
 var $pc2346690: Phase;                                                                             
 var tmp32346772: bool;                                                                             
 var Node.owner2346769: [Node]List;                                                                 
 var this$2112346754: Node;                                                                         
 var $result2346751: bool;                                                                          
 var List.head2346772: [List]Node;                                                                  
 var tmp12346678: bool;                                                                             
 var $recorded.state2346690: int;                                                                   
 var Node._lock2346681: [Node]Tid;                                                                  
 var path2346769: int;                                                                              
 var Node._lock2346787: [Node]Tid;                                                                  
 var Node.owner2346751: [Node]List;                                                                 
 var this$2112346751: Node;                                                                         
 var Node._state2346650: [Node]State;                                                               
 var $recorded.state2346787: int;                                                                   
 var List.head2346777: [List]Node;                                                                  
 var this2346690: List;                                                                             
 var node: Node;                                                                                    
 var pred2346751: Node;                                                                             
 var $recorded.state2346772: int;                                                                   
 var Node._state2346653: [Node]State;                                                               
 var $recorded.state2346701: int;                                                                   
 var key2346650: int;                                                                               
 var $pc2346769: Phase;                                                                             
 var Node.item2346751: [Node]int;                                                                   
 var $result2346777: bool;                                                                          
 var moverPath2346653: MoverPath;                                                                   
 var owner$211: List;                                                                               
 var List._lock2346769: [List]Tid;                                                                  
 var path2346754: int;                                                                              
 var Node._state2346787: [Node]State;                                                               
 var Node.item2346772: [Node]int;                                                                   
 var pred2346754: Node;                                                                             
 var Node.owner2346681_bottom: [Node]List;                                                          
 var Node.item2346690: [Node]int;                                                                   
 var Node._lock2346653: [Node]Tid;                                                                  
 var Node._state2346681: [Node]State;                                                               
 var tmp42346777: int;                                                                              
 var pred2346650: Node;                                                                             
 var moverPath2346769: MoverPath;                                                                   
 var List.head2346653: [List]Node;                                                                  
 var key2346772: int;                                                                               
 var Node._state2346777: [Node]State;                                                               
 var path2346751: int;                                                                              
 var List._lock2346751: [List]Tid;                                                                  
 var tmp1: bool;                                                                                    
 var path2346678: int;                                                                              
 var $result2346754: bool;                                                                          
 var $pc2346662: Phase;                                                                             
 var Node._lock2346650: [Node]Tid;                                                                  
 var $pc2346787: Phase;                                                                             
 var mover2346678: Mover;                                                                           
 var pred2346701: Node;                                                                             
 var path2346650: int;                                                                              
 var moverPath2346754: MoverPath;                                                                   
 var moverPath2346690: MoverPath;                                                                   
 var List.head2346650: [List]Node;                                                                  
 var path2346772: int;                                                                              
 var $recorded.state2346681: int;                                                                   
 var Node.item2346662: [Node]int;                                                                   
 var Node.next2346653: [Node]Node;                                                                  
 var pred2346777: Node;                                                                             
 var $result2346787: bool;                                                                          
 var pred2346662: Node;                                                                             
 var tid2346787: Tid;                                                                               
 var $pc2346751: Phase;                                                                             
 var tid2346662: Tid;                                                                               
 var key2346751: int;                                                                               
 var curr2346690: Node;                                                                             
 var List._state2346653: [List]State;                                                               
 var List._state2346690: [List]State;                                                               
 var Node.next2346662: [Node]Node;                                                                  
 var Node._lock2346662: [Node]Tid;                                                                  
 var curr2346701: Node;                                                                             
 var List._lock2346772: [List]Tid;                                                                  
 var tid2346772: Tid;                                                                               
 var node2346777: Node;                                                                             
 var Node._lock2346701: [Node]Tid;                                                                  
 var List._lock2346777: [List]Tid;                                                                  
 var tid2346678: Tid;                                                                               
 var $pc2346678: Phase;                                                                             
 var curr2346787: Node;                                                                             
 var List._state2346769: [List]State;                                                               
 var List._lock2346681: [List]Tid;                                                                  
 var phase2346681: Phase;                                                                           
 var Node.next2346754: [Node]Node;                                                                  
 var Node._lock2346751: [Node]Tid;                                                                  
 var curr2346678: Node;                                                                             
 var Node._state2346690: [Node]State;                                                               
 var this2346751: List;                                                                             
 var List._lock2346662: [List]Tid;                                                                  
 var tid2346751: Tid;                                                                               
 var item2346690: int;                                                                              
 var pred2346681: Node;                                                                             
 var List.head2346681_bottom: [List]Node;                                                           
 var tid2346754: Tid;                                                                               
 var List.head2346751: [List]Node;                                                                  
 var Node._lock2346681_bottom: [Node]Tid;                                                           
 var key2346678: int;                                                                               
 var Node.item2346681: [Node]int;                                                                   
 var List.head2346787: [List]Node;                                                                  
 var $pc2346772: Phase;                                                                             
 var Node._state2346751: [Node]State;                                                               
 var List._state2346787: [List]State;                                                               
 var tid2346769: Tid;                                                                               
 var Node._lock2346690: [Node]Tid;                                                                  
 var tmp32346690: bool;                                                                             
 var tid2346650: Tid;                                                                               
 var Node.owner2346701: [Node]List;                                                                 
 var Node.item2346754: [Node]int;                                                                   
 var pred2346690: Node;                                                                             
 var item$2112346751: int;                                                                          
 var item2346769: int;                                                                              
 var $recorded.state2346769: int;                                                                   
 var List._lock2346653: [List]Tid;                                                                  
 var pred2346772: Node;                                                                             
 var mover2346769: Mover;                                                                           
 var $recorded.state2346653: int;                                                                   
 var curr: Node;                                                                                    
 var key2346662: int;                                                                               
 var Node.owner2346787: [Node]List;                                                                 
 var $pc2346650: Phase;                                                                             
 var curr2346681: Node;                                                                             
 var Node._lock2346777: [Node]Tid;                                                                  
 var $pc2346777: Phase;                                                                             
 var mover2346653: Mover;                                                                           
 var List._lock2346787: [List]Tid;                                                                  
 var mover2346662: Mover;                                                                           
 var Node.owner2346681: [Node]List;                                                                 
 var List._state2346650: [List]State;                                                               
 var path2346690: int;                                                                              
 var $recorded.state2346681_bottom: int;                                                            
 var Node._state2346754: [Node]State;                                                               
 var key2346653: int;                                                                               
 var this2346769: List;                                                                             
 var item2346678: int;                                                                              
 var List._state2346681: [List]State;                                                               
 var pred2346681_bottom: Node;                                                                      
 var item2346751: int;                                                                              
 var tmp32346754: bool;                                                                             
 var Node.next2346650: [Node]Node;                                                                  
 var List._lock2346650: [List]Tid;                                                                  
 var Node._lock2346769: [Node]Tid;                                                                  
 var $result2346772: bool;                                                                          
 var Node._state2346701: [Node]State;                                                               
 var List.head2346681: [List]Node;                                                                  
 var Node.owner2346653: [Node]List;                                                                 
 var $result2346690: bool;                                                                          
 var item2346650: int;                                                                              
 var item$211: int;                                                                                 
 var key: int;                                                                                      
 var Node.owner2346754: [Node]List;                                                                 
 var path2346653: int;                                                                              
 var tmp42346690: int;                                                                              
 var List._state2346701: [List]State;                                                               
 var moverPath2346751: MoverPath;                                                                   
 var $recorded.state2346754: int;                                                                   
 var node2346769: Node;                                                                             
 var curr2346681_bottom: Node;                                                                      
 var Node.owner2346678: [Node]List;                                                                 
 var Node.next2346777: [Node]Node;                                                                  
 var key2346681: int;                                                                               
 var Node.next2346787: [Node]Node;                                                                  
 var Node.next2346701: [Node]Node;                                                                  
 var item2346653: int;                                                                              
 var moverPath2346772: MoverPath;                                                                   
 var tmp42346751: int;                                                                              
 var item2346777: int;                                                                              
 var tmp32346701: bool;                                                                             
 var owner$2112346754: List;                                                                        
 var $recorded.state2346650: int;                                                                   
 var List._state2346678: [List]State;                                                               
 var curr2346754: Node;                                                                             
 var List._lock2346701: [List]Tid;                                                                  
 var Node.item2346653: [Node]int;                                                                   
 var Node._lock2346678: [Node]Tid;                                                                  
 var Node._state2346772: [Node]State;                                                               
 var $result2346769: bool;                                                                          
 var tmp22346678: int;                                                                              
 var this2346772: List;                                                                             
 var this2346754: List;                                                                             
 var pred2346769: Node;                                                                             
 var node2346754: Node;                                                                             
 var item2346681_bottom: int;                                                                       
 var $pc2346754: Phase;                                                                             
 var Node.item2346678: [Node]int;                                                                   
 var curr2346662: Node;                                                                             
 var tmp42346769: int;                                                                              
 var this2346681_bottom: List;                                                                      
 var Node._state2346681_bottom: [Node]State;                                                        
 var item2346772: int;                                                                              
 var this2346662: List;                                                                             
 var curr2346650: Node;                                                                             
 var Node.owner2346772: [Node]List;                                                                 
 var List._state2346662: [List]State;                                                               
 var curr2346777: Node;                                                                             
 var List._lock2346754: [List]Tid;                                                                  
 var Node.next2346681_bottom: [Node]Node;                                                           
 var Node.item2346769: [Node]int;                                                                   
 var key2346754: int;                                                                               
 var curr2346769: Node;                                                                             
 var mover2346754: Mover;                                                                           
 var Node._lock2346772: [Node]Tid;                                                                  
 var item2346754: int;                                                                              
 var $pc2346653: Phase;                                                                             
 var mover2346772: Mover;                                                                           
 var pred2346653: Node;                                                                             
 var key2346787: int;                                                                               
 var tmp22346662: int;                                                                              
 var pred2346678: Node;                                                                             
 var curr2346772: Node;                                                                             
 var node2346751: Node;                                                                             
 var $result2346653: bool;                                                                          
 var $result2346662: bool;                                                                          
 var Node.owner2346690: [Node]List;                                                                 
 var tmp3: bool;                                                                                    
 var List._state2346681_bottom: [List]State;                                                        
 var moverPath2346662: MoverPath;                                                                   
 var tmp42346701: int;                                                                              
 var List._lock2346678: [List]Tid;                                                                  
 var List._state2346772: [List]State;                                                               
 var $pc2346681_bottom: Phase;                                                                      
 var item$2112346754: int;                                                                          
 var $result2346681: bool;                                                                          
 var this$211: Node;                                                                                
 var List.head2346678: [List]Node;                                                                  
 var curr2346751: Node;                                                                             
 var key2346701: int;                                                                               
 var path2346662: int;                                                                              
 var $recorded.state2346751: int;                                                                   
 var tid2346690: Tid;                                                                               
 var tid2346777: Tid;                                                                               
 var key2346777: int;                                                                               
 var item2346701: int;                                                                              
 var Node.next2346772: [Node]Node;                                                                  
 var this2346678: List;                                                                             
 var Node.item2346777: [Node]int;                                                                   
 var Node.next2346769: [Node]Node;                                                                  
 var mover2346751: Mover;                                                                           
 var tid2346653: Tid;                                                                               
 var Node.next2346690: [Node]Node;                                                                  
 var item2346662: int;                                                                              
 var List.head2346690: [List]Node;                                                                  
 var List.head2346701: [List]Node;                                                                  
 var node2346772: Node;                                                                             
 var $result2346678: bool;                                                                          
 var pred: Node;                                                                                    
 var Node._state2346662: [Node]State;                                                               
 var tid2346681: Tid;                                                                               
 var List._state2346751: [List]State;                                                               
 var this2346777: List;                                                                             
 var tid2346701: Tid;                                                                               
 var moverPath2346650: MoverPath;                                                                   
 var Node.next2346751: [Node]Node;                                                                  
 var $result2346681_bottom: bool;                                                                   
 var tmp2: int;                                                                                     
 var key2346769: int;                                                                               
 var List._state2346754: [List]State;                                                               
 var List.head2346662: [List]Node;                                                                  
 var Node.next2346678: [Node]Node;                                                                  
 var key2346681_bottom: int;                                                                        
 var $result2346650: bool;                                                                          
 var Node.owner2346777: [Node]List;                                                                 
 var Node.item2346650: [Node]int;                                                                   
 var tmp32346769: bool;                                                                             
 var this2346701: List;                                                                             
 var tmp32346751: bool;                                                                             
 var Node._lock2346754: [Node]Tid;                                                                  
 var Node._state2346678: [Node]State;                                                               
 var Node.next2346681: [Node]Node;                                                                  
 var key2346690: int;                                                                               
 var Node.item2346787: [Node]int;                                                                   
 var Node.owner2346662: [Node]List;                                                                 
 var item2346681: int;                                                                              
 var this2346653: List;                                                                             
 var $recorded.state2346777: int;                                                                   
 var this2346650: List;                                                                             
 var tmp42346772: int;                                                                              
 var tmp4: int;                                                                                     
 var mover2346690: Mover;                                                                           
 var $result2346701: bool;                                                                          
 var this2346681: List;                                                                             
 var mover2346650: Mover;                                                                           
 var Node.item2346701: [Node]int;                                                                   
 var this2346787: List;                                                                             
 var $recorded.state2346678: int;                                                                   
 var owner$2112346751: List;                                                                        
 var tid2346681_bottom: Tid;                                                                        
 var $pc2346681: Phase;                                                                             
 var $recorded.state2346662: int;                                                                   
 var item2346787: int;                                                                              
 var pred2346787: Node;                                                                             
 var moverPath2346678: MoverPath;                                                                   
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (39.29): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 41.9: Node pred;                                                                                
                                                                                                    
                                                                                                    
 // 42.9: Node curr;                                                                                
                                                                                                    
                                                                                                    
 // 43.9: int key;                                                                                  
                                                                                                    
                                                                                                    
 // 43.9: key = item;                                                                               
                                                                                                    
 key := item;                                                                                       
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (44.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume List._lock[this] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (44.22): Reduction failure
 List._lock[this] := tid;                                                                           
                                                                                                    
 // 45.13: pred := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346650 := ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346650 := m#moverPath(moverPath2346650);                                                     
 path2346650 := p#moverPath(moverPath2346650);                                                      
 assume Node._state2346650 == Node._state && Node.item2346650 == Node.item && Node.next2346650 == Node.next && Node.owner2346650 == Node.owner && Node._lock2346650 == Node._lock && List._state2346650 == List._state && List.head2346650 == List.head && List._lock2346650 == List._lock && key2346650 == key && curr2346650 == curr && pred2346650 == pred && $result2346650 == $result && item2346650 == item && this2346650 == this && tid2346650 == tid && $pc2346650 == $pc;
 assume $recorded.state2346650 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (45.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346650);                                                              
 assert $pc != PhaseError;                                                                                 // (45.13): Reduction failure
 pred := List.head[this];                                                                           
                                                                                                    
 // 46.13: curr := pred.next;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346653 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346653 := m#moverPath(moverPath2346653);                                                     
 path2346653 := p#moverPath(moverPath2346653);                                                      
 assume Node._state2346653 == Node._state && Node.item2346653 == Node.item && Node.next2346653 == Node.next && Node.owner2346653 == Node.owner && Node._lock2346653 == Node._lock && List._state2346653 == List._state && List.head2346653 == List.head && List._lock2346653 == List._lock && key2346653 == key && curr2346653 == curr && pred2346653 == pred && $result2346653 == $result && item2346653 == item && this2346653 == this && tid2346653 == tid && $pc2346653 == $pc;
 assume $recorded.state2346653 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume pred != Node.null;                                                                         
 } else {                                                                                           
  assert pred != Node.null;                                                                                // (46.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346653);                                                              
 assert $pc != PhaseError;                                                                                 // (46.13): Reduction failure
 curr := Node.next[pred];                                                                           
 assume Node._state2346681 == Node._state && Node.item2346681 == Node.item && Node.next2346681 == Node.next && Node.owner2346681 == Node.owner && Node._lock2346681 == Node._lock && List._state2346681 == List._state && List.head2346681 == List.head && List._lock2346681 == List._lock && key2346681 == key && curr2346681 == curr && pred2346681 == pred && $result2346681 == $result && item2346681 == item && this2346681 == this && tid2346681 == tid;
 assume $recorded.state2346681 == 1;                                                                
                                                                                                    
 // 48.13: while (true)                                                                             
                                                                                                    
 phase2346681 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (39.5): Bad tid
  invariant isShared(List._state[this]);                                                                   // (39.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (48.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (48.13): Object invariant may not hold.
  invariant isShared(Node._state[curr]);                                                            
  invariant isShared(Node._state[pred]);                                                            
  invariant (Node.item[pred]<item);                                                                 
  invariant (curr==Node.next[pred]);                                                                
  invariant (Node.owner[pred]==this);                                                               
  invariant (Node.owner[curr]==this);                                                               
  invariant (isAccessible(List._state[this], tid) && List._lock[this] == tid);                      
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state2346681,Node.item2346681,Node.next2346681,Node.owner2346681,Node._lock2346681,List._state2346681,List.head2346681,List._lock2346681));       // (48.13): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state2346681,Node.item2346681,Node.next2346681,Node.owner2346681,Node._lock2346681,List._state2346681,List.head2346681,List._lock2346681));       // (48.13): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Node :: Invariant.Y_Node.owner(tid : Tid, _this, Node.owner[_this] ,Node._state2346681,Node.item2346681,Node.next2346681,Node.owner2346681,Node._lock2346681,List._state2346681,List.head2346681,List._lock2346681));       // (48.13): Loop does not preserve yields_as annotation for field owner
  invariant (forall _this : List :: Invariant.Y_List.head(tid : Tid, _this, List.head[_this] ,Node._state2346681,Node.item2346681,Node.next2346681,Node.owner2346681,Node._lock2346681,List._state2346681,List.head2346681,List._lock2346681));       // (48.13): Loop does not preserve yields_as annotation for field head
  invariant phase2346681 == $pc;                                                                           // (48.13): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (48.13): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 48.30: boolean tmp1;                                                                           
                                                                                                    
                                                                                                    
  // 48.20: int tmp2;                                                                               
                                                                                                    
                                                                                                    
  // 48.20: tmp2 := curr.item;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346662 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346662 := m#moverPath(moverPath2346662);                                                    
  path2346662 := p#moverPath(moverPath2346662);                                                     
  assume Node._state2346662 == Node._state && Node.item2346662 == Node.item && Node.next2346662 == Node.next && Node.owner2346662 == Node.owner && Node._lock2346662 == Node._lock && List._state2346662 == List._state && List.head2346662 == List.head && List._lock2346662 == List._lock && tmp22346662 == tmp2 && tmp12346662 == tmp1 && key2346662 == key && curr2346662 == curr && pred2346662 == pred && $result2346662 == $result && item2346662 == item && this2346662 == this && tid2346662 == tid && $pc2346662 == $pc;
  assume $recorded.state2346662 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (48.20): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2346662);                                                             
  assert $pc != PhaseError;                                                                                // (48.20): Reduction failure
  tmp2 := Node.item[curr];                                                                          
                                                                                                    
  // 48.30: tmp1 = tmp2 < item;                                                                     
                                                                                                    
  tmp1 := (tmp2<item);                                                                              
  if (!(tmp1)) {                                                                                    
                                                                                                    
   // 48.13: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 56.17: pred = curr;                                                                            
                                                                                                    
  pred := curr;                                                                                     
                                                                                                    
  // 57.17: curr := curr.next;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346678 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346678 := m#moverPath(moverPath2346678);                                                    
  path2346678 := p#moverPath(moverPath2346678);                                                     
  assume Node._state2346678 == Node._state && Node.item2346678 == Node.item && Node.next2346678 == Node.next && Node.owner2346678 == Node.owner && Node._lock2346678 == Node._lock && List._state2346678 == List._state && List.head2346678 == List.head && List._lock2346678 == List._lock && tmp22346678 == tmp2 && tmp12346678 == tmp1 && key2346678 == key && curr2346678 == curr && pred2346678 == pred && $result2346678 == $result && item2346678 == item && this2346678 == this && tid2346678 == tid && $pc2346678 == $pc;
  assume $recorded.state2346678 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (57.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2346678);                                                             
  assert $pc != PhaseError;                                                                                // (57.17): Reduction failure
  curr := Node.next[curr];                                                                          
  assume Node._state2346681_bottom == Node._state && Node.item2346681_bottom == Node.item && Node.next2346681_bottom == Node.next && Node.owner2346681_bottom == Node.owner && Node._lock2346681_bottom == Node._lock && List._state2346681_bottom == List._state && List.head2346681_bottom == List.head && List._lock2346681_bottom == List._lock && key2346681_bottom == key && curr2346681_bottom == curr && pred2346681_bottom == pred && $result2346681_bottom == $result && item2346681_bottom == item && this2346681_bottom == this && tid2346681_bottom == tid;
  assume $recorded.state2346681_bottom == 1;                                                        
  assert phase2346681 == $pc;                                                                              // (48.13): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 59.13: boolean tmp3;                                                                            
                                                                                                    
                                                                                                    
 // 59.13: int tmp4;                                                                                
                                                                                                    
                                                                                                    
 // 59.13: tmp4 := curr.item;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346690 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346690 := m#moverPath(moverPath2346690);                                                     
 path2346690 := p#moverPath(moverPath2346690);                                                      
 assume Node._state2346690 == Node._state && Node.item2346690 == Node.item && Node.next2346690 == Node.next && Node.owner2346690 == Node.owner && Node._lock2346690 == Node._lock && List._state2346690 == List._state && List.head2346690 == List.head && List._lock2346690 == List._lock && tmp42346690 == tmp4 && tmp32346690 == tmp3 && key2346690 == key && curr2346690 == curr && pred2346690 == pred && $result2346690 == $result && item2346690 == item && this2346690 == this && tid2346690 == tid && $pc2346690 == $pc;
 assume $recorded.state2346690 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume curr != Node.null;                                                                         
 } else {                                                                                           
  assert curr != Node.null;                                                                                // (59.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346690);                                                              
 assert $pc != PhaseError;                                                                                 // (59.13): Reduction failure
 tmp4 := Node.item[curr];                                                                           
                                                                                                    
 // 59.13: tmp3 = item == tmp4;                                                                     
                                                                                                    
 tmp3 := (item==tmp4);                                                                              
 if (tmp3 /* lowered (item==Node.item[curr]) */) {                                                  
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (67.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (67.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (67.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 60.17:  return false;                                                                          
                                                                                                    
  assume Node._state2346701 == Node._state && Node.item2346701 == Node.item && Node.next2346701 == Node.next && Node.owner2346701 == Node.owner && Node._lock2346701 == Node._lock && List._state2346701 == List._state && List.head2346701 == List.head && List._lock2346701 == List._lock && tmp42346701 == tmp4 && tmp32346701 == tmp3 && key2346701 == key && curr2346701 == curr && pred2346701 == pred && $result2346701 == $result && item2346701 == item && this2346701 == this && tid2346701 == tid;
  assume $recorded.state2346701 == 1;                                                               
  $result := false;                                                                                 
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (60.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (60.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (60.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (60.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (60.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (60.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (60.17): Object invariant may not hold.
  return;                                                                                           
 } else {                                                                                           
                                                                                                    
  // 62.17: Node node;                                                                              
                                                                                                    
                                                                                                    
  // 62.17: node = new Node();                                                                      
                                                                                                    
  havoc node;                                                                                       
  assume node != Node.null && isFresh(Node._state[node]);                                           
  Node._state[node] := LOCAL(tid);                                                                  
  assume Node.item[node]  == 0;                                                                     
  assume Node.next[node]  == Node.null;                                                             
  assume Node.owner[node]  == List.null;                                                            
  assume Node._lock[node]  == Tid.null;                                                             
  // inlined: node.init(item,this)}                                                                 
  exit$211_top:                                                                                     
                                                                                                    
  // 62.17: int item$211;                                                                           
                                                                                                    
                                                                                                    
  // 62.17: List owner$211;                                                                         
                                                                                                    
                                                                                                    
  // 62.17: Node this$211;                                                                          
                                                                                                    
                                                                                                    
  // 62.17: item$211 = item;                                                                        
                                                                                                    
  item$211 := item;                                                                                 
                                                                                                    
  // 62.17: owner$211 = this;                                                                       
                                                                                                    
  owner$211 := this;                                                                                
                                                                                                    
  // 62.17: this$211 = node;                                                                        
                                                                                                    
  this$211 := node;                                                                                 
                                                                                                    
  // 19.5: assume this$211.item == 0;                                                               
                                                                                                    
  assume (Node.item[this$211]==0);                                                                  
                                                                                                    
  // 19.5: assume this$211.next == Node.null;                                                       
                                                                                                    
  assume (Node.next[this$211]==Node.null);                                                          
                                                                                                    
  // 19.5: assume this$211.owner == List.null;                                                      
                                                                                                    
  assume (Node.owner[this$211]==List.null);                                                         
                                                                                                    
                                                                                                    
  // 20.9: this$211.item := item$211;                                                               
                                                                                                    
                                                                                                    
  moverPath2346751 := WriteEval.Node.item(tid: Tid,this$211: Node,item$211: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346751 := m#moverPath(moverPath2346751);                                                    
  path2346751 := p#moverPath(moverPath2346751);                                                     
  assume Node._state2346751 == Node._state && Node.item2346751 == Node.item && Node.next2346751 == Node.next && Node.owner2346751 == Node.owner && Node._lock2346751 == Node._lock && List._state2346751 == List._state && List.head2346751 == List.head && List._lock2346751 == List._lock && this$2112346751 == this$211 && owner$2112346751 == owner$211 && item$2112346751 == item$211 && node2346751 == node && tmp42346751 == tmp4 && tmp32346751 == tmp3 && key2346751 == key && curr2346751 == curr && pred2346751 == pred && $result2346751 == $result && item2346751 == item && this2346751 == this && tid2346751 == tid && $pc2346751 == $pc;
  assume $recorded.state2346751 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$211 != Node.null;                                                                    
  } else {                                                                                          
   assert this$211 != Node.null;                                                                           // (20.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2346751);                                                             
  assert $pc != PhaseError;                                                                                // (20.9): Reduction failure
  Node.item[this$211] := item$211;                                                                  
                                                                                                    
                                                                                                    
  // 21.9: this$211.owner := owner$211;                                                             
                                                                                                    
                                                                                                    
  moverPath2346754 := WriteEval.Node.owner(tid: Tid,this$211: Node,owner$211: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346754 := m#moverPath(moverPath2346754);                                                    
  path2346754 := p#moverPath(moverPath2346754);                                                     
  assume Node._state2346754 == Node._state && Node.item2346754 == Node.item && Node.next2346754 == Node.next && Node.owner2346754 == Node.owner && Node._lock2346754 == Node._lock && List._state2346754 == List._state && List.head2346754 == List.head && List._lock2346754 == List._lock && this$2112346754 == this$211 && owner$2112346754 == owner$211 && item$2112346754 == item$211 && node2346754 == node && tmp42346754 == tmp4 && tmp32346754 == tmp3 && key2346754 == key && curr2346754 == curr && pred2346754 == pred && $result2346754 == $result && item2346754 == item && this2346754 == this && tid2346754 == tid && $pc2346754 == $pc;
  assume $recorded.state2346754 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume this$211 != Node.null;                                                                    
  } else {                                                                                          
   assert this$211 != Node.null;                                                                           // (21.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2346754);                                                             
  assert $pc != PhaseError;                                                                                // (21.9): Reduction failure
  Node.owner[this$211] := owner$211;                                                                
  if (isLocal(List._state[owner$211], tid)) {                                                       
   List._state[owner$211] := SHARED();                                                              
   assert isSharedAssignable(Node._state[List.head[owner$211]]);                                           // (21.9): owner$211 became shared, but owner$211.head may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
  // 19.32: break exit$211;                                                                         
                                                                                                    
  goto exit$211_bottom;                                                                             
  exit$211_bottom:                                                                                  
                                                                                                    
                                                                                                    
  // 63.17: node.next := curr;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346769 := WriteEval.Node.next(tid: Tid,node: Node,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346769 := m#moverPath(moverPath2346769);                                                    
  path2346769 := p#moverPath(moverPath2346769);                                                     
  assume Node._state2346769 == Node._state && Node.item2346769 == Node.item && Node.next2346769 == Node.next && Node.owner2346769 == Node.owner && Node._lock2346769 == Node._lock && List._state2346769 == List._state && List.head2346769 == List.head && List._lock2346769 == List._lock && node2346769 == node && tmp42346769 == tmp4 && tmp32346769 == tmp3 && key2346769 == key && curr2346769 == curr && pred2346769 == pred && $result2346769 == $result && item2346769 == item && this2346769 == this && tid2346769 == tid && $pc2346769 == $pc;
  assume $recorded.state2346769 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume node != Node.null;                                                                        
  } else {                                                                                          
   assert node != Node.null;                                                                               // (63.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2346769);                                                             
  assert $pc != PhaseError;                                                                                // (63.17): Reduction failure
  Node.next[node] := curr;                                                                          
  if (isLocal(Node._state[curr], tid)) {                                                            
   Node._state[curr] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[curr]]);                                                // (63.17): curr became shared, but curr.next may not be shared.
   assert isSharedAssignable(List._state[Node.owner[curr]]);                                               // (63.17): curr became shared, but curr.owner may not be shared.
  }                                                                                                 
                                                                                                    
                                                                                                    
                                                                                                    
  // 64.17: pred.next := node;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346772 := WriteEval.Node.next(tid: Tid,pred: Node,node: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346772 := m#moverPath(moverPath2346772);                                                    
  path2346772 := p#moverPath(moverPath2346772);                                                     
  assume Node._state2346772 == Node._state && Node.item2346772 == Node.item && Node.next2346772 == Node.next && Node.owner2346772 == Node.owner && Node._lock2346772 == Node._lock && List._state2346772 == List._state && List.head2346772 == List.head && List._lock2346772 == List._lock && node2346772 == node && tmp42346772 == tmp4 && tmp32346772 == tmp3 && key2346772 == key && curr2346772 == curr && pred2346772 == pred && $result2346772 == $result && item2346772 == item && this2346772 == this && tid2346772 == tid && $pc2346772 == $pc;
  assume $recorded.state2346772 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (64.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2346772);                                                             
  assert $pc != PhaseError;                                                                                // (64.17): Reduction failure
  Node.next[pred] := node;                                                                          
  if (isLocal(Node._state[node], tid)) {                                                            
   Node._state[node] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[node]]);                                                // (64.17): node became shared, but node.next may not be shared.
   assert isSharedAssignable(List._state[Node.owner[node]]);                                               // (64.17): node became shared, but node.owner may not be shared.
  }                                                                                                 
                                                                                                    
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (67.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (67.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (67.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 65.17:  return true;                                                                           
                                                                                                    
  assume Node._state2346777 == Node._state && Node.item2346777 == Node.item && Node.next2346777 == Node.next && Node.owner2346777 == Node.owner && Node._lock2346777 == Node._lock && List._state2346777 == List._state && List.head2346777 == List.head && List._lock2346777 == List._lock && node2346777 == node && tmp42346777 == tmp4 && tmp32346777 == tmp3 && key2346777 == key && curr2346777 == curr && pred2346777 == pred && $result2346777 == $result && item2346777 == item && this2346777 == this && tid2346777 == tid;
  assume $recorded.state2346777 == 1;                                                               
  $result := true;                                                                                  
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (65.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (65.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (65.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (65.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (65.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (65.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (65.17): Object invariant may not hold.
  return;                                                                                           
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (67.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (67.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (67.9): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 40.34: // return false;                                                                         
                                                                                                    
 assume Node._state2346787 == Node._state && Node.item2346787 == Node.item && Node.next2346787 == Node.next && Node.owner2346787 == Node.owner && Node._lock2346787 == Node._lock && List._state2346787 == List._state && List.head2346787 == List.head && List._lock2346787 == List._lock && key2346787 == key && curr2346787 == curr && pred2346787 == pred && $result2346787 == $result && item2346787 == item && this2346787 == this && tid2346787 == tid;
 assume $recorded.state2346787 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (40.34): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (40.34): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  List.remove(tid:Tid, this : List, item : int)                                            
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (70.5): Bad tid
requires isShared(List._state[this]);                                                                      // (70.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
requires ((-1073741824<item)&&(item<1073741823));                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (70.5): Object invariant may not hold.
{                                                                                                   
 var tmp62346829: int;                                                                              
 var pred2346832: Node;                                                                             
 var Node._state2346832: [Node]State;                                                               
 var path2346801: int;                                                                              
 var Node.item2346856: [Node]int;                                                                   
 var $recorded.state2346856: int;                                                                   
 var List.head2346868: [List]Node;                                                                  
 var item2346853: int;                                                                              
 var List._state2346813: [List]State;                                                               
 var moverPath2346801: MoverPath;                                                                   
 var this2346856: List;                                                                             
 var List.head2346861: [List]Node;                                                                  
 var moverPath2346841: MoverPath;                                                                   
 var tid2346856: Tid;                                                                               
 var mover2346853: Mover;                                                                           
 var List.head2346841: [List]Node;                                                                  
 var Node.item2346813: [Node]int;                                                                   
 var pred2346861: Node;                                                                             
 var List._state2346832: [List]State;                                                               
 var Node.owner2346868: [Node]List;                                                                 
 var Node._lock2346829: [Node]Tid;                                                                  
 var List._lock2346801: [List]Tid;                                                                  
 var Node._state2346856: [Node]State;                                                               
 var phase2346832: Phase;                                                                           
 var Node.item2346832: [Node]int;                                                                   
 var Node._state2346868: [Node]State;                                                               
 var tid2346804: Tid;                                                                               
 var Node._lock2346853: [Node]Tid;                                                                  
 var $pc2346813: Phase;                                                                             
 var Node._lock2346841: [Node]Tid;                                                                  
 var Node.next2346804: [Node]Node;                                                                  
 var tmp5: bool;                                                                                    
 var $pc2346801: Phase;                                                                             
 var mover2346804: Mover;                                                                           
 var moverPath2346829: MoverPath;                                                                   
 var this2346832_bottom: List;                                                                      
 var Node.next2346861: [Node]Node;                                                                  
 var $result2346813: bool;                                                                          
 var Node.owner2346813: [Node]List;                                                                 
 var pred2346868: Node;                                                                             
 var Node._state2346853: [Node]State;                                                               
 var List._lock2346861: [List]Tid;                                                                  
 var curr2346813: Node;                                                                             
 var this2346832: List;                                                                             
 var List._state2346841: [List]State;                                                               
 var curr2346801: Node;                                                                             
 var Node.next2346832: [Node]Node;                                                                  
 var Node.next2346801: [Node]Node;                                                                  
 var tid2346841: Tid;                                                                               
 var tmp72346853: bool;                                                                             
 var List._lock2346813: [List]Tid;                                                                  
 var List._state2346801: [List]State;                                                               
 var tmp8: int;                                                                                     
 var Node.item2346829: [Node]int;                                                                   
 var curr2346868: Node;                                                                             
 var tmp82346868: int;                                                                              
 var pred2346829: Node;                                                                             
 var mover2346856: Mover;                                                                           
 var moverPath2346804: MoverPath;                                                                   
 var Node._state2346841: [Node]State;                                                               
 var item2346861: int;                                                                              
 var $recorded.state2346829: int;                                                                   
 var tmp72346856: bool;                                                                             
 var item2346832: int;                                                                              
 var Node.owner2346853: [Node]List;                                                                 
 var List._lock2346832: [List]Tid;                                                                  
 var Node.owner2346861: [Node]List;                                                                 
 var $result2346832: bool;                                                                          
 var List._lock2346868: [List]Tid;                                                                  
 var Node._state2346801: [Node]State;                                                               
 var $result2346832_bottom: bool;                                                                   
 var $result2346868: bool;                                                                          
 var Node.owner2346829: [Node]List;                                                                 
 var $recorded.state2346832: int;                                                                   
 var item2346878: int;                                                                              
 var $pc2346829: Phase;                                                                             
 var this2346804: List;                                                                             
 var Node._lock2346861: [Node]Tid;                                                                  
 var this2346841: List;                                                                             
 var Node.owner2346832: [Node]List;                                                                 
 var Node._lock2346804: [Node]Tid;                                                                  
 var tmp92346853: Node;                                                                             
 var mover2346801: Mover;                                                                           
 var $recorded.state2346861: int;                                                                   
 var List._state2346868: [List]State;                                                               
 var Node.next2346841: [Node]Node;                                                                  
 var Node._state2346804: [Node]State;                                                               
 var curr2346861: Node;                                                                             
 var Node._lock2346868: [Node]Tid;                                                                  
 var Node._lock2346856: [Node]Tid;                                                                  
 var mover2346829: Mover;                                                                           
 var Node.next2346832_bottom: [Node]Node;                                                           
 var Node._lock2346832_bottom: [Node]Tid;                                                           
 var Node._state2346813: [Node]State;                                                               
 var mover2346841: Mover;                                                                           
 var $result2346841: bool;                                                                          
 var $recorded.state2346853: int;                                                                   
 var this2346853: List;                                                                             
 var $pc2346804: Phase;                                                                             
 var $recorded.state2346801: int;                                                                   
 var tmp72346841: bool;                                                                             
 var $result2346861: bool;                                                                          
 var this2346801: List;                                                                             
 var curr: Node;                                                                                    
 var item2346856: int;                                                                              
 var path2346813: int;                                                                              
 var List.head2346804: [List]Node;                                                                  
 var this2346878: List;                                                                             
 var item2346801: int;                                                                              
 var List.head2346801: [List]Node;                                                                  
 var tmp9: Node;                                                                                    
 var tmp82346853: int;                                                                              
 var Node.item2346804: [Node]int;                                                                   
 var List._state2346804: [List]State;                                                               
 var Node._lock2346878: [Node]Tid;                                                                  
 var Node.item2346832_bottom: [Node]int;                                                            
 var Node._state2346832_bottom: [Node]State;                                                        
 var tid2346861: Tid;                                                                               
 var item2346841: int;                                                                              
 var List._lock2346878: [List]Tid;                                                                  
 var $pc2346878: Phase;                                                                             
 var Node.item2346868: [Node]int;                                                                   
 var $recorded.state2346868: int;                                                                   
 var $recorded.state2346878: int;                                                                   
 var pred2346832_bottom: Node;                                                                      
 var Node.item2346853: [Node]int;                                                                   
 var path2346856: int;                                                                              
 var Node.next2346878: [Node]Node;                                                                  
 var $result2346829: bool;                                                                          
 var $result2346853: bool;                                                                          
 var tid2346813: Tid;                                                                               
 var $recorded.state2346832_bottom: int;                                                            
 var List.head2346878: [List]Node;                                                                  
 var List._lock2346853: [List]Tid;                                                                  
 var pred2346804: Node;                                                                             
 var $pc2346856: Phase;                                                                             
 var List._lock2346804: [List]Tid;                                                                  
 var Node.next2346868: [Node]Node;                                                                  
 var this2346829: List;                                                                             
 var tmp92346856: Node;                                                                             
 var tid2346829: Tid;                                                                               
 var curr2346856: Node;                                                                             
 var $recorded.state2346841: int;                                                                   
 var List._state2346856: [List]State;                                                               
 var $result2346804: bool;                                                                          
 var mover2346813: Mover;                                                                           
 var tid2346878: Tid;                                                                               
 var tmp7: bool;                                                                                    
 var item2346829: int;                                                                              
 var pred2346856: Node;                                                                             
 var moverPath2346853: MoverPath;                                                                   
 var $pc2346832: Phase;                                                                             
 var List.head2346813: [List]Node;                                                                  
 var $pc2346832_bottom: Phase;                                                                      
 var tid2346853: Tid;                                                                               
 var $recorded.state2346813: int;                                                                   
 var item2346832_bottom: int;                                                                       
 var pred2346841: Node;                                                                             
 var this2346813: List;                                                                             
 var item2346804: int;                                                                              
 var List._lock2346832_bottom: [List]Tid;                                                           
 var Node._state2346829: [Node]State;                                                               
 var List._lock2346829: [List]Tid;                                                                  
 var pred2346853: Node;                                                                             
 var Node._lock2346801: [Node]Tid;                                                                  
 var List.head2346832_bottom: [List]Node;                                                           
 var tmp52346813: bool;                                                                             
 var tmp92346861: Node;                                                                             
 var moverPath2346813: MoverPath;                                                                   
 var List.head2346856: [List]Node;                                                                  
 var curr2346878: Node;                                                                             
 var $result2346856: bool;                                                                          
 var Node._state2346878: [Node]State;                                                               
 var $result2346801: bool;                                                                          
 var curr2346853: Node;                                                                             
 var item2346813: int;                                                                              
 var tid2346832_bottom: Tid;                                                                        
 var path2346841: int;                                                                              
 var tmp62346813: int;                                                                              
 var Node.owner2346841: [Node]List;                                                                 
 var Node.next2346813: [Node]Node;                                                                  
 var List._lock2346841: [List]Tid;                                                                  
 var Node._state2346861: [Node]State;                                                               
 var Node.item2346861: [Node]int;                                                                   
 var moverPath2346856: MoverPath;                                                                   
 var $pc2346868: Phase;                                                                             
 var tmp52346829: bool;                                                                             
 var Node.owner2346878: [Node]List;                                                                 
 var pred2346813: Node;                                                                             
 var this2346861: List;                                                                             
 var List._state2346853: [List]State;                                                               
 var $pc2346853: Phase;                                                                             
 var tid2346832: Tid;                                                                               
 var List._lock2346856: [List]Tid;                                                                  
 var pred: Node;                                                                                    
 var curr2346832_bottom: Node;                                                                      
 var List.head2346832: [List]Node;                                                                  
 var Node.owner2346856: [Node]List;                                                                 
 var path2346853: int;                                                                              
 var item2346868: int;                                                                              
 var Node.owner2346804: [Node]List;                                                                 
 var $pc2346861: Phase;                                                                             
 var Node.item2346801: [Node]int;                                                                   
 var $recorded.state2346804: int;                                                                   
 var curr2346829: Node;                                                                             
 var this2346868: List;                                                                             
 var List._state2346832_bottom: [List]State;                                                        
 var tmp82346841: int;                                                                              
 var List._state2346878: [List]State;                                                               
 var Node._lock2346832: [Node]Tid;                                                                  
 var List._state2346829: [List]State;                                                               
 var Node.item2346841: [Node]int;                                                                   
 var List._state2346861: [List]State;                                                               
 var Node.item2346878: [Node]int;                                                                   
 var tmp72346868: bool;                                                                             
 var path2346804: int;                                                                              
 var pred2346801: Node;                                                                             
 var tmp82346861: int;                                                                              
 var Node.owner2346801: [Node]List;                                                                 
 var curr2346832: Node;                                                                             
 var Node.owner2346832_bottom: [Node]List;                                                          
 var $pc2346841: Phase;                                                                             
 var $result2346878: bool;                                                                          
 var tmp6: int;                                                                                     
 var tmp72346861: bool;                                                                             
 var tmp82346856: int;                                                                              
 var Node.next2346856: [Node]Node;                                                                  
 var tid2346868: Tid;                                                                               
 var curr2346841: Node;                                                                             
 var pred2346878: Node;                                                                             
 var path2346829: int;                                                                              
 var List.head2346853: [List]Node;                                                                  
 var Node.next2346829: [Node]Node;                                                                  
 var curr2346804: Node;                                                                             
 var Node.next2346853: [Node]Node;                                                                  
 var List.head2346829: [List]Node;                                                                  
 var tid2346801: Tid;                                                                               
 var Node._lock2346813: [Node]Tid;                                                                  
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (70.29): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 72.9: Node pred;                                                                                
                                                                                                    
                                                                                                    
 // 73.9: Node curr;                                                                                
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (74.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume List._lock[this] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (74.22): Reduction failure
 List._lock[this] := tid;                                                                           
                                                                                                    
 // 75.13: pred := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346801 := ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346801 := m#moverPath(moverPath2346801);                                                     
 path2346801 := p#moverPath(moverPath2346801);                                                      
 assume Node._state2346801 == Node._state && Node.item2346801 == Node.item && Node.next2346801 == Node.next && Node.owner2346801 == Node.owner && Node._lock2346801 == Node._lock && List._state2346801 == List._state && List.head2346801 == List.head && List._lock2346801 == List._lock && curr2346801 == curr && pred2346801 == pred && $result2346801 == $result && item2346801 == item && this2346801 == this && tid2346801 == tid && $pc2346801 == $pc;
 assume $recorded.state2346801 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (75.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346801);                                                              
 assert $pc != PhaseError;                                                                                 // (75.13): Reduction failure
 pred := List.head[this];                                                                           
                                                                                                    
 // 76.13: curr := pred.next;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346804 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346804 := m#moverPath(moverPath2346804);                                                     
 path2346804 := p#moverPath(moverPath2346804);                                                      
 assume Node._state2346804 == Node._state && Node.item2346804 == Node.item && Node.next2346804 == Node.next && Node.owner2346804 == Node.owner && Node._lock2346804 == Node._lock && List._state2346804 == List._state && List.head2346804 == List.head && List._lock2346804 == List._lock && curr2346804 == curr && pred2346804 == pred && $result2346804 == $result && item2346804 == item && this2346804 == this && tid2346804 == tid && $pc2346804 == $pc;
 assume $recorded.state2346804 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume pred != Node.null;                                                                         
 } else {                                                                                           
  assert pred != Node.null;                                                                                // (76.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346804);                                                              
 assert $pc != PhaseError;                                                                                 // (76.13): Reduction failure
 curr := Node.next[pred];                                                                           
 assume Node._state2346832 == Node._state && Node.item2346832 == Node.item && Node.next2346832 == Node.next && Node.owner2346832 == Node.owner && Node._lock2346832 == Node._lock && List._state2346832 == List._state && List.head2346832 == List.head && List._lock2346832 == List._lock && curr2346832 == curr && pred2346832 == pred && $result2346832 == $result && item2346832 == item && this2346832 == this && tid2346832 == tid;
 assume $recorded.state2346832 == 1;                                                                
                                                                                                    
 // 78.13: while (true)                                                                             
                                                                                                    
 phase2346832 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (70.5): Bad tid
  invariant isShared(List._state[this]);                                                                   // (70.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (78.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (78.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (78.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (78.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (78.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (78.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (78.13): Object invariant may not hold.
  invariant isShared(Node._state[curr]);                                                            
  invariant isShared(Node._state[pred]);                                                            
  invariant (Node.item[pred]<item);                                                                 
  invariant (curr==Node.next[pred]);                                                                
  invariant (Node.owner[pred]==this);                                                               
  invariant (Node.owner[curr]==this);                                                               
  invariant (isAccessible(List._state[this], tid) && List._lock[this] == tid);                      
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state2346832,Node.item2346832,Node.next2346832,Node.owner2346832,Node._lock2346832,List._state2346832,List.head2346832,List._lock2346832));       // (78.13): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state2346832,Node.item2346832,Node.next2346832,Node.owner2346832,Node._lock2346832,List._state2346832,List.head2346832,List._lock2346832));       // (78.13): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Node :: Invariant.Y_Node.owner(tid : Tid, _this, Node.owner[_this] ,Node._state2346832,Node.item2346832,Node.next2346832,Node.owner2346832,Node._lock2346832,List._state2346832,List.head2346832,List._lock2346832));       // (78.13): Loop does not preserve yields_as annotation for field owner
  invariant (forall _this : List :: Invariant.Y_List.head(tid : Tid, _this, List.head[_this] ,Node._state2346832,Node.item2346832,Node.next2346832,Node.owner2346832,Node._lock2346832,List._state2346832,List.head2346832,List._lock2346832));       // (78.13): Loop does not preserve yields_as annotation for field head
  invariant phase2346832 == $pc;                                                                           // (78.13): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (78.13): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 78.30: boolean tmp5;                                                                           
                                                                                                    
                                                                                                    
  // 78.20: int tmp6;                                                                               
                                                                                                    
                                                                                                    
  // 78.20: tmp6 := curr.item;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346813 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346813 := m#moverPath(moverPath2346813);                                                    
  path2346813 := p#moverPath(moverPath2346813);                                                     
  assume Node._state2346813 == Node._state && Node.item2346813 == Node.item && Node.next2346813 == Node.next && Node.owner2346813 == Node.owner && Node._lock2346813 == Node._lock && List._state2346813 == List._state && List.head2346813 == List.head && List._lock2346813 == List._lock && tmp62346813 == tmp6 && tmp52346813 == tmp5 && curr2346813 == curr && pred2346813 == pred && $result2346813 == $result && item2346813 == item && this2346813 == this && tid2346813 == tid && $pc2346813 == $pc;
  assume $recorded.state2346813 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (78.20): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2346813);                                                             
  assert $pc != PhaseError;                                                                                // (78.20): Reduction failure
  tmp6 := Node.item[curr];                                                                          
                                                                                                    
  // 78.30: tmp5 = tmp6 < item;                                                                     
                                                                                                    
  tmp5 := (tmp6<item);                                                                              
  if (!(tmp5)) {                                                                                    
                                                                                                    
   // 78.13: break;                                                                                 
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 86.17: pred = curr;                                                                            
                                                                                                    
  pred := curr;                                                                                     
                                                                                                    
  // 87.17: curr := curr.next;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346829 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346829 := m#moverPath(moverPath2346829);                                                    
  path2346829 := p#moverPath(moverPath2346829);                                                     
  assume Node._state2346829 == Node._state && Node.item2346829 == Node.item && Node.next2346829 == Node.next && Node.owner2346829 == Node.owner && Node._lock2346829 == Node._lock && List._state2346829 == List._state && List.head2346829 == List.head && List._lock2346829 == List._lock && tmp62346829 == tmp6 && tmp52346829 == tmp5 && curr2346829 == curr && pred2346829 == pred && $result2346829 == $result && item2346829 == item && this2346829 == this && tid2346829 == tid && $pc2346829 == $pc;
  assume $recorded.state2346829 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (87.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2346829);                                                             
  assert $pc != PhaseError;                                                                                // (87.17): Reduction failure
  curr := Node.next[curr];                                                                          
  assume Node._state2346832_bottom == Node._state && Node.item2346832_bottom == Node.item && Node.next2346832_bottom == Node.next && Node.owner2346832_bottom == Node.owner && Node._lock2346832_bottom == Node._lock && List._state2346832_bottom == List._state && List.head2346832_bottom == List.head && List._lock2346832_bottom == List._lock && curr2346832_bottom == curr && pred2346832_bottom == pred && $result2346832_bottom == $result && item2346832_bottom == item && this2346832_bottom == this && tid2346832_bottom == tid;
  assume $recorded.state2346832_bottom == 1;                                                        
  assert phase2346832 == $pc;                                                                              // (78.13): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 89.13: boolean tmp7;                                                                            
                                                                                                    
                                                                                                    
 // 89.13: int tmp8;                                                                                
                                                                                                    
                                                                                                    
 // 89.13: tmp8 := curr.item;                                                                       
                                                                                                    
                                                                                                    
 moverPath2346841 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346841 := m#moverPath(moverPath2346841);                                                     
 path2346841 := p#moverPath(moverPath2346841);                                                      
 assume Node._state2346841 == Node._state && Node.item2346841 == Node.item && Node.next2346841 == Node.next && Node.owner2346841 == Node.owner && Node._lock2346841 == Node._lock && List._state2346841 == List._state && List.head2346841 == List.head && List._lock2346841 == List._lock && tmp82346841 == tmp8 && tmp72346841 == tmp7 && curr2346841 == curr && pred2346841 == pred && $result2346841 == $result && item2346841 == item && this2346841 == this && tid2346841 == tid && $pc2346841 == $pc;
 assume $recorded.state2346841 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume curr != Node.null;                                                                         
 } else {                                                                                           
  assert curr != Node.null;                                                                                // (89.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346841);                                                              
 assert $pc != PhaseError;                                                                                 // (89.13): Reduction failure
 tmp8 := Node.item[curr];                                                                           
                                                                                                    
 // 89.13: tmp7 = item == tmp8;                                                                     
                                                                                                    
 tmp7 := (item==tmp8);                                                                              
 if (tmp7 /* lowered (item==Node.item[curr]) */) {                                                  
                                                                                                    
  // 90.17: Node tmp9;                                                                              
                                                                                                    
                                                                                                    
  // 90.17: tmp9 := curr.next;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346853 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346853 := m#moverPath(moverPath2346853);                                                    
  path2346853 := p#moverPath(moverPath2346853);                                                     
  assume Node._state2346853 == Node._state && Node.item2346853 == Node.item && Node.next2346853 == Node.next && Node.owner2346853 == Node.owner && Node._lock2346853 == Node._lock && List._state2346853 == List._state && List.head2346853 == List.head && List._lock2346853 == List._lock && tmp92346853 == tmp9 && tmp82346853 == tmp8 && tmp72346853 == tmp7 && curr2346853 == curr && pred2346853 == pred && $result2346853 == $result && item2346853 == item && this2346853 == this && tid2346853 == tid && $pc2346853 == $pc;
  assume $recorded.state2346853 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (90.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2346853);                                                             
  assert $pc != PhaseError;                                                                                // (90.17): Reduction failure
  tmp9 := Node.next[curr];                                                                          
                                                                                                    
                                                                                                    
  // 90.17: pred.next := tmp9;                                                                      
                                                                                                    
                                                                                                    
  moverPath2346856 := WriteEval.Node.next(tid: Tid,pred: Node,tmp9: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346856 := m#moverPath(moverPath2346856);                                                    
  path2346856 := p#moverPath(moverPath2346856);                                                     
  assume Node._state2346856 == Node._state && Node.item2346856 == Node.item && Node.next2346856 == Node.next && Node.owner2346856 == Node.owner && Node._lock2346856 == Node._lock && List._state2346856 == List._state && List.head2346856 == List.head && List._lock2346856 == List._lock && tmp92346856 == tmp9 && tmp82346856 == tmp8 && tmp72346856 == tmp7 && curr2346856 == curr && pred2346856 == pred && $result2346856 == $result && item2346856 == item && this2346856 == this && tid2346856 == tid && $pc2346856 == $pc;
  assume $recorded.state2346856 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume pred != Node.null;                                                                        
  } else {                                                                                          
   assert pred != Node.null;                                                                               // (90.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover2346856);                                                             
  assert $pc != PhaseError;                                                                                // (90.17): Reduction failure
  Node.next[pred] := tmp9;                                                                          
  if (isLocal(Node._state[tmp9], tid)) {                                                            
   Node._state[tmp9] := SHARED();                                                                   
   assert isSharedAssignable(Node._state[Node.next[tmp9]]);                                                // (90.17): tmp9 became shared, but tmp9.next may not be shared.
   assert isSharedAssignable(List._state[Node.owner[tmp9]]);                                               // (90.17): tmp9 became shared, but tmp9.owner may not be shared.
  }                                                                                                 
                                                                                                    
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (95.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (95.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (95.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 91.17:  return true;                                                                           
                                                                                                    
  assume Node._state2346861 == Node._state && Node.item2346861 == Node.item && Node.next2346861 == Node.next && Node.owner2346861 == Node.owner && Node._lock2346861 == Node._lock && List._state2346861 == List._state && List.head2346861 == List.head && List._lock2346861 == List._lock && tmp92346861 == tmp9 && tmp82346861 == tmp8 && tmp72346861 == tmp7 && curr2346861 == curr && pred2346861 == pred && $result2346861 == $result && item2346861 == item && this2346861 == this && tid2346861 == tid;
  assume $recorded.state2346861 == 1;                                                               
  $result := true;                                                                                  
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (91.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (91.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (91.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (91.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (91.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (91.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (91.17): Object invariant may not hold.
  return;                                                                                           
 } else {                                                                                           
  if ($pc == PreCommit) {                                                                           
   assume this != List.null;                                                                        
  } else {                                                                                          
   assert this != List.null;                                                                               // (95.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert List._lock[this] == tid;                                                                          // (95.9): lock not held
  $pc := transition($pc, _L);                                                                       
  assert $pc != PhaseError;                                                                                // (95.9): Reduction failure
  List._lock[this] := Tid.null;                                                                     
                                                                                                    
  // 93.17:  return false;                                                                          
                                                                                                    
  assume Node._state2346868 == Node._state && Node.item2346868 == Node.item && Node.next2346868 == Node.next && Node.owner2346868 == Node.owner && Node._lock2346868 == Node._lock && List._state2346868 == List._state && List.head2346868 == List.head && List._lock2346868 == List._lock && tmp82346868 == tmp8 && tmp72346868 == tmp7 && curr2346868 == curr && pred2346868 == pred && $result2346868 == $result && item2346868 == item && this2346868 == this && tid2346868 == tid;
  assume $recorded.state2346868 == 1;                                                               
  $result := false;                                                                                 
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (93.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (93.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (93.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (93.17): Object invariant may not hold.
  assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (93.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (93.17): Object invariant may not hold.
  assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (93.17): Object invariant may not hold.
  return;                                                                                           
 }                                                                                                  
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (95.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (95.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (95.9): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 71.37: // return false;                                                                         
                                                                                                    
 assume Node._state2346878 == Node._state && Node.item2346878 == Node.item && Node.next2346878 == Node.next && Node.owner2346878 == Node.owner && Node._lock2346878 == Node._lock && List._state2346878 == List._state && List.head2346878 == List.head && List._lock2346878 == List._lock && curr2346878 == curr && pred2346878 == pred && $result2346878 == $result && item2346878 == item && this2346878 == this && tid2346878 == tid;
 assume $recorded.state2346878 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (71.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (71.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (71.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (71.37): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (71.37): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (71.37): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (71.37): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  List.contains(tid:Tid, this : List, item : int)                                          
returns ($result : bool)                                                                            
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (99.5): Bad tid
requires isShared(List._state[this]);                                                                      // (99.5): this is not global
                                                                                                    
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
requires ((-1073741824<item)&&(item<1073741823));                                                   
                                                                                                    
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (99.5): Object invariant may not hold.
{                                                                                                   
 var List._state2346950: [List]State;                                                               
 var $pc2346889: Phase;                                                                             
 var List.head2346904: [List]Node;                                                                  
 var $pc2346895: Phase;                                                                             
 var tid2346904: Tid;                                                                               
 var $result2346895: bool;                                                                          
 var this2346895: List;                                                                             
 var Node._lock2346920: [Node]Tid;                                                                  
 var tmp132346932: int;                                                                             
 var Node._state2346923_bottom: [Node]State;                                                        
 var List._lock2346923: [List]Tid;                                                                  
 var pred2346923: Node;                                                                             
 var path2346932: int;                                                                              
 var $result2346904: bool;                                                                          
 var Node._state2346895: [Node]State;                                                               
 var Node._state2346923: [Node]State;                                                               
 var $result2346923_bottom: bool;                                                                   
 var Node.item2346889: [Node]int;                                                                   
 var List.head2346920: [List]Node;                                                                  
 var item2346920: int;                                                                              
 var tid2346923_bottom: Tid;                                                                        
 var Node.owner2346950: [Node]List;                                                                 
 var tmp102346904: bool;                                                                            
 var Node.next2346923_bottom: [Node]Node;                                                           
 var path2346904: int;                                                                              
 var Node.next2346932: [Node]Node;                                                                  
 var Node._lock2346942: [Node]Tid;                                                                  
 var Node.owner2346889: [Node]List;                                                                 
 var List._state2346932: [List]State;                                                               
 var Node._state2346904: [Node]State;                                                               
 var $pc2346942: Phase;                                                                             
 var Node.item2346932: [Node]int;                                                                   
 var $result2346889: bool;                                                                          
 var Node.owner2346923: [Node]List;                                                                 
 var Node._lock2346889: [Node]Tid;                                                                  
 var Node.owner2346932: [Node]List;                                                                 
 var Node._lock2346950: [Node]Tid;                                                                  
 var List._state2346895: [List]State;                                                               
 var pred2346942: Node;                                                                             
 var List.head2346895: [List]Node;                                                                  
 var List.head2346923: [List]Node;                                                                  
 var this2346904: List;                                                                             
 var tid2346889: Tid;                                                                               
 var Node.next2346920: [Node]Node;                                                                  
 var curr2346942: Node;                                                                             
 var mover2346904: Mover;                                                                           
 var $recorded.state2346932: int;                                                                   
 var tmp122346932: bool;                                                                            
 var $pc2346904: Phase;                                                                             
 var this2346923: List;                                                                             
 var path2346889: int;                                                                              
 var mover2346895: Mover;                                                                           
 var pred2346932: Node;                                                                             
 var this2346942: List;                                                                             
 var $recorded.state2346889: int;                                                                   
 var mover2346889: Mover;                                                                           
 var $recorded.state2346920: int;                                                                   
 var List._state2346923: [List]State;                                                               
 var Node._lock2346932: [Node]Tid;                                                                  
 var this2346889: List;                                                                             
 var curr2346920: Node;                                                                             
 var tmp132346942: int;                                                                             
 var List._state2346904: [List]State;                                                               
 var Node._lock2346923_bottom: [Node]Tid;                                                           
 var $result2346942: bool;                                                                          
 var curr: Node;                                                                                    
 var Node._state2346889: [Node]State;                                                               
 var $pc2346923: Phase;                                                                             
 var item2346932: int;                                                                              
 var Node.owner2346904: [Node]List;                                                                 
 var Node.item2346942: [Node]int;                                                                   
 var item2346895: int;                                                                              
 var List.head2346889: [List]Node;                                                                  
 var item2346904: int;                                                                              
 var tid2346920: Tid;                                                                               
 var $pc2346932: Phase;                                                                             
 var moverPath2346932: MoverPath;                                                                   
 var tmp11: int;                                                                                    
 var List._lock2346932: [List]Tid;                                                                  
 var Node._lock2346895: [Node]Tid;                                                                  
 var Node.next2346923: [Node]Node;                                                                  
 var $result2346923: bool;                                                                          
 var Node.next2346889: [Node]Node;                                                                  
 var List._lock2346950: [List]Tid;                                                                  
 var Node.owner2346895: [Node]List;                                                                 
 var List.head2346942: [List]Node;                                                                  
 var List.head2346932: [List]Node;                                                                  
 var path2346920: int;                                                                              
 var Node.item2346895: [Node]int;                                                                   
 var tmp112346920: int;                                                                             
 var Node.next2346950: [Node]Node;                                                                  
 var Node.item2346920: [Node]int;                                                                   
 var Node._state2346942: [Node]State;                                                               
 var pred2346920: Node;                                                                             
 var item2346923_bottom: int;                                                                       
 var tid2346923: Tid;                                                                               
 var tmp112346904: int;                                                                             
 var $recorded.state2346923_bottom: int;                                                            
 var moverPath2346920: MoverPath;                                                                   
 var pred2346895: Node;                                                                             
 var item2346950: int;                                                                              
 var List._lock2346904: [List]Tid;                                                                  
 var tmp10: bool;                                                                                   
 var tmp12: bool;                                                                                   
 var Node._lock2346904: [Node]Tid;                                                                  
 var this2346932: List;                                                                             
 var Node.owner2346923_bottom: [Node]List;                                                          
 var $recorded.state2346904: int;                                                                   
 var tmp13: int;                                                                                    
 var $recorded.state2346942: int;                                                                   
 var item2346923: int;                                                                              
 var Node._state2346932: [Node]State;                                                               
 var $result2346920: bool;                                                                          
 var Node.next2346904: [Node]Node;                                                                  
 var pred2346923_bottom: Node;                                                                      
 var List._state2346942: [List]State;                                                               
 var pred2346904: Node;                                                                             
 var List.head2346923_bottom: [List]Node;                                                           
 var List._state2346923_bottom: [List]State;                                                        
 var tmp122346942: bool;                                                                            
 var Node.next2346895: [Node]Node;                                                                  
 var pred2346889: Node;                                                                             
 var $pc2346920: Phase;                                                                             
 var Node.item2346904: [Node]int;                                                                   
 var item2346889: int;                                                                              
 var this2346950: List;                                                                             
 var tid2346895: Tid;                                                                               
 var List._lock2346942: [List]Tid;                                                                  
 var tid2346932: Tid;                                                                               
 var item2346942: int;                                                                              
 var Node.next2346942: [Node]Node;                                                                  
 var $recorded.state2346895: int;                                                                   
 var curr2346904: Node;                                                                             
 var phase2346923: Phase;                                                                           
 var $pc2346923_bottom: Phase;                                                                      
 var tid2346942: Tid;                                                                               
 var curr2346923_bottom: Node;                                                                      
 var Node._state2346920: [Node]State;                                                               
 var List._state2346920: [List]State;                                                               
 var curr2346923: Node;                                                                             
 var this2346920: List;                                                                             
 var curr2346895: Node;                                                                             
 var Node.owner2346942: [Node]List;                                                                 
 var Node.owner2346920: [Node]List;                                                                 
 var moverPath2346889: MoverPath;                                                                   
 var moverPath2346895: MoverPath;                                                                   
 var Node._state2346950: [Node]State;                                                               
 var $pc2346950: Phase;                                                                             
 var tmp102346920: bool;                                                                            
 var Node.item2346923_bottom: [Node]int;                                                            
 var mover2346932: Mover;                                                                           
 var moverPath2346904: MoverPath;                                                                   
 var path2346895: int;                                                                              
 var List._lock2346895: [List]Tid;                                                                  
 var pred: Node;                                                                                    
 var this2346923_bottom: List;                                                                      
 var List._state2346889: [List]State;                                                               
 var $result2346932: bool;                                                                          
 var curr2346932: Node;                                                                             
 var Node.item2346923: [Node]int;                                                                   
 var $result2346950: bool;                                                                          
 var List._lock2346889: [List]Tid;                                                                  
 var mover2346920: Mover;                                                                           
 var Node._lock2346923: [Node]Tid;                                                                  
 var List._lock2346920: [List]Tid;                                                                  
 var $recorded.state2346923: int;                                                                   
 var List._lock2346923_bottom: [List]Tid;                                                           
 var tid2346950: Tid;                                                                               
 var Node.item2346950: [Node]int;                                                                   
 var $recorded.state2346950: int;                                                                   
 var List.head2346950: [List]Node;                                                                  
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (99.29): Can only have right-mover memory accesses in requires clause
                                                                                                    
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (101.22): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assume List._lock[this] == Tid.null;                                                               
 $pc := transition($pc, _R);                                                                        
 assert $pc != PhaseError;                                                                                 // (101.22): Reduction failure
 List._lock[this] := tid;                                                                           
                                                                                                    
 // 102.13: Node pred;                                                                              
                                                                                                    
                                                                                                    
 // 102.13: pred := this.head;                                                                      
                                                                                                    
                                                                                                    
 moverPath2346889 := ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346889 := m#moverPath(moverPath2346889);                                                     
 path2346889 := p#moverPath(moverPath2346889);                                                      
 assume Node._state2346889 == Node._state && Node.item2346889 == Node.item && Node.next2346889 == Node.next && Node.owner2346889 == Node.owner && Node._lock2346889 == Node._lock && List._state2346889 == List._state && List.head2346889 == List.head && List._lock2346889 == List._lock && pred2346889 == pred && $result2346889 == $result && item2346889 == item && this2346889 == this && tid2346889 == tid && $pc2346889 == $pc;
 assume $recorded.state2346889 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (102.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346889);                                                              
 assert $pc != PhaseError;                                                                                 // (102.13): Reduction failure
 pred := List.head[this];                                                                           
                                                                                                    
 // 103.13: Node curr;                                                                              
                                                                                                    
                                                                                                    
 // 103.13: curr := pred.next;                                                                      
                                                                                                    
                                                                                                    
 moverPath2346895 := ReadEval.Node.next(tid: Tid,pred: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346895 := m#moverPath(moverPath2346895);                                                     
 path2346895 := p#moverPath(moverPath2346895);                                                      
 assume Node._state2346895 == Node._state && Node.item2346895 == Node.item && Node.next2346895 == Node.next && Node.owner2346895 == Node.owner && Node._lock2346895 == Node._lock && List._state2346895 == List._state && List.head2346895 == List.head && List._lock2346895 == List._lock && curr2346895 == curr && pred2346895 == pred && $result2346895 == $result && item2346895 == item && this2346895 == this && tid2346895 == tid && $pc2346895 == $pc;
 assume $recorded.state2346895 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume pred != Node.null;                                                                         
 } else {                                                                                           
  assert pred != Node.null;                                                                                // (103.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346895);                                                              
 assert $pc != PhaseError;                                                                                 // (103.13): Reduction failure
 curr := Node.next[pred];                                                                           
 assume Node._state2346923 == Node._state && Node.item2346923 == Node.item && Node.next2346923 == Node.next && Node.owner2346923 == Node.owner && Node._lock2346923 == Node._lock && List._state2346923 == List._state && List.head2346923 == List.head && List._lock2346923 == List._lock && curr2346923 == curr && pred2346923 == pred && $result2346923 == $result && item2346923 == item && this2346923 == this && tid2346923 == tid;
 assume $recorded.state2346923 == 1;                                                                
                                                                                                    
 // 104.13: while (true)                                                                            
                                                                                                    
 phase2346923 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (99.5): Bad tid
  invariant isShared(List._state[this]);                                                                   // (99.5): this is not global
                                                                                                    
  invariant StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (104.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (104.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (104.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (104.13): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (104.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (104.13): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (104.13): Object invariant may not hold.
  invariant isShared(Node._state[curr]);                                                            
  invariant (Node.owner[curr]==this);                                                               
  invariant (Node.owner[pred]==this);                                                               
  invariant (curr==Node.next[pred]);                                                                
  invariant (isAccessible(List._state[this], tid) && List._lock[this] == tid);                      
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Node._state2346923,Node.item2346923,Node.next2346923,Node.owner2346923,Node._lock2346923,List._state2346923,List.head2346923,List._lock2346923));       // (104.13): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Node._state2346923,Node.item2346923,Node.next2346923,Node.owner2346923,Node._lock2346923,List._state2346923,List.head2346923,List._lock2346923));       // (104.13): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : Node :: Invariant.Y_Node.owner(tid : Tid, _this, Node.owner[_this] ,Node._state2346923,Node.item2346923,Node.next2346923,Node.owner2346923,Node._lock2346923,List._state2346923,List.head2346923,List._lock2346923));       // (104.13): Loop does not preserve yields_as annotation for field owner
  invariant (forall _this : List :: Invariant.Y_List.head(tid : Tid, _this, List.head[_this] ,Node._state2346923,Node.item2346923,Node.next2346923,Node.owner2346923,Node._lock2346923,List._state2346923,List.head2346923,List._lock2346923));       // (104.13): Loop does not preserve yields_as annotation for field head
  invariant phase2346923 == $pc;                                                                           // (104.13): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (104.13): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 104.30: boolean tmp10;                                                                         
                                                                                                    
                                                                                                    
  // 104.20: int tmp11;                                                                             
                                                                                                    
                                                                                                    
  // 104.20: tmp11 := curr.item;                                                                    
                                                                                                    
                                                                                                    
  moverPath2346904 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346904 := m#moverPath(moverPath2346904);                                                    
  path2346904 := p#moverPath(moverPath2346904);                                                     
  assume Node._state2346904 == Node._state && Node.item2346904 == Node.item && Node.next2346904 == Node.next && Node.owner2346904 == Node.owner && Node._lock2346904 == Node._lock && List._state2346904 == List._state && List.head2346904 == List.head && List._lock2346904 == List._lock && tmp112346904 == tmp11 && tmp102346904 == tmp10 && curr2346904 == curr && pred2346904 == pred && $result2346904 == $result && item2346904 == item && this2346904 == this && tid2346904 == tid && $pc2346904 == $pc;
  assume $recorded.state2346904 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (104.20): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2346904);                                                             
  assert $pc != PhaseError;                                                                                // (104.20): Reduction failure
  tmp11 := Node.item[curr];                                                                         
                                                                                                    
  // 104.30: tmp10 = tmp11 < item;                                                                  
                                                                                                    
  tmp10 := (tmp11<item);                                                                            
  if (!(tmp10)) {                                                                                   
                                                                                                    
   // 104.13: break;                                                                                
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 110.17: pred = curr;                                                                           
                                                                                                    
  pred := curr;                                                                                     
                                                                                                    
  // 111.17: curr := curr.next;                                                                     
                                                                                                    
                                                                                                    
  moverPath2346920 := ReadEval.Node.next(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
  mover2346920 := m#moverPath(moverPath2346920);                                                    
  path2346920 := p#moverPath(moverPath2346920);                                                     
  assume Node._state2346920 == Node._state && Node.item2346920 == Node.item && Node.next2346920 == Node.next && Node.owner2346920 == Node.owner && Node._lock2346920 == Node._lock && List._state2346920 == List._state && List.head2346920 == List.head && List._lock2346920 == List._lock && tmp112346920 == tmp11 && tmp102346920 == tmp10 && curr2346920 == curr && pred2346920 == pred && $result2346920 == $result && item2346920 == item && this2346920 == this && tid2346920 == tid && $pc2346920 == $pc;
  assume $recorded.state2346920 == 1;                                                               
  if ($pc == PreCommit) {                                                                           
   assume curr != Node.null;                                                                        
  } else {                                                                                          
   assert curr != Node.null;                                                                               // (111.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover2346920);                                                             
  assert $pc != PhaseError;                                                                                // (111.17): Reduction failure
  curr := Node.next[curr];                                                                          
  assume Node._state2346923_bottom == Node._state && Node.item2346923_bottom == Node.item && Node.next2346923_bottom == Node.next && Node.owner2346923_bottom == Node.owner && Node._lock2346923_bottom == Node._lock && List._state2346923_bottom == List._state && List.head2346923_bottom == List.head && List._lock2346923_bottom == List._lock && curr2346923_bottom == curr && pred2346923_bottom == pred && $result2346923_bottom == $result && item2346923_bottom == item && this2346923_bottom == this && tid2346923_bottom == tid;
  assume $recorded.state2346923_bottom == 1;                                                        
  assert phase2346923 == $pc;                                                                              // (104.13): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 113.13: boolean tmp12;                                                                          
                                                                                                    
                                                                                                    
 // 113.13: int tmp13;                                                                              
                                                                                                    
                                                                                                    
 // 113.13: tmp13 := curr.item;                                                                     
                                                                                                    
                                                                                                    
 moverPath2346932 := ReadEval.Node.item(tid: Tid,curr: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 mover2346932 := m#moverPath(moverPath2346932);                                                     
 path2346932 := p#moverPath(moverPath2346932);                                                      
 assume Node._state2346932 == Node._state && Node.item2346932 == Node.item && Node.next2346932 == Node.next && Node.owner2346932 == Node.owner && Node._lock2346932 == Node._lock && List._state2346932 == List._state && List.head2346932 == List.head && List._lock2346932 == List._lock && tmp132346932 == tmp13 && tmp122346932 == tmp12 && curr2346932 == curr && pred2346932 == pred && $result2346932 == $result && item2346932 == item && this2346932 == this && tid2346932 == tid && $pc2346932 == $pc;
 assume $recorded.state2346932 == 1;                                                                
 if ($pc == PreCommit) {                                                                            
  assume curr != Node.null;                                                                         
 } else {                                                                                           
  assert curr != Node.null;                                                                                // (113.13): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover2346932);                                                              
 assert $pc != PhaseError;                                                                                 // (113.13): Reduction failure
 tmp13 := Node.item[curr];                                                                          
                                                                                                    
 // 113.13: tmp12 = item == tmp13;                                                                  
                                                                                                    
 tmp12 := (item==tmp13);                                                                            
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (114.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (114.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (114.9): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 113.13:  return tmp12;                                                                          
                                                                                                    
 assume Node._state2346942 == Node._state && Node.item2346942 == Node.item && Node.next2346942 == Node.next && Node.owner2346942 == Node.owner && Node._lock2346942 == Node._lock && List._state2346942 == List._state && List.head2346942 == List.head && List._lock2346942 == List._lock && tmp132346942 == tmp13 && tmp122346942 == tmp12 && curr2346942 == curr && pred2346942 == pred && $result2346942 == $result && item2346942 == item && this2346942 == this && tid2346942 == tid;
 assume $recorded.state2346942 == 1;                                                                
 $result := tmp12;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (113.13): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (113.13): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (113.13): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (113.13): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (113.13): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (113.13): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (113.13): Object invariant may not hold.
 return;                                                                                            
 if ($pc == PreCommit) {                                                                            
  assume this != List.null;                                                                         
 } else {                                                                                           
  assert this != List.null;                                                                                // (114.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 assert List._lock[this] == tid;                                                                           // (114.9): lock not held
 $pc := transition($pc, _L);                                                                        
 assert $pc != PhaseError;                                                                                 // (114.9): Reduction failure
 List._lock[this] := Tid.null;                                                                      
                                                                                                    
 // 100.39: // return false;                                                                        
                                                                                                    
 assume Node._state2346950 == Node._state && Node.item2346950 == Node.item && Node.next2346950 == Node.next && Node.owner2346950 == Node.owner && Node._lock2346950 == Node._lock && List._state2346950 == List._state && List.head2346950 == List.head && List._lock2346950 == List._lock && $result2346950 == $result && item2346950 == item && this2346950 == this && tid2346950 == tid;
 assume $recorded.state2346950 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (100.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (100.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (100.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (100.39): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (100.39): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (100.39): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (100.39): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]Node,Node.owner: [Node]List,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: List  :: _i == List.null <==> isNull(List._state[_i])) &&                             
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(Node._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(Node._state[Node.next[_i]], _t)))) &&
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(List._state[Node.owner[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(List._state[Node.owner[_i]], _t)))) &&
  (forall _i: List ::  (isShared(List._state[_i]) ==> isSharedAssignable(Node._state[List.head[_i]]))) &&
  (forall _i: List ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(List._state[_i],_t) ==> isLocalAssignable(Node._state[List.head[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (5.5): Node.item failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)             
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (5.5): Node.item failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                  
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.item[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.item[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Node.item failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (6.5): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (6.5): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: Node, w: Node, x: Node)                
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (6.5): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)        
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.owner(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.5): Node.owner failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : List;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.owner[x];                                                                         
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.owner[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : List;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.owner[x];                                                                         
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.owner(u: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.5): Node.owner failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)              
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.owner(t: Tid, u: Tid, v: List, w: List, x: Node)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : List;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.owner[x];                                                                         
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.owner[x] := havocValue;                                                                       
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,x: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Node.owner failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)         
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.List.head(u: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (27.5): List.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)          
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == List.head[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 List.head[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)           
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == List.head[x];                                                                          
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.List.head(u: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (27.5): List.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)               
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)                
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == List.head[x];                                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 List.head[x] := havocValue;                                                                        
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (27.5): List.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.next(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var List._state_mid: [List]State;                                                                  
 var v_mid: int;                                                                                    
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.owner(t: Tid, u: Tid, v: int, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var v_mid: int;                                                                                    
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Node.item is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (6.5): Node.next is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.Node.item(t: Tid, u: Tid, v: List, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.Node.next(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.Node.owner(t: Tid, u: Tid, v: List, w: List, w0: List, x: Node, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : List;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: List;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.owner[x];                                                                             
 Node.owner[x] := v;                                                                                
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.owner[x] := tmpV;                                                                             
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.owner(t: Tid,x: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Node.owner is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.owner.List.head(t: Tid, u: Tid, v: List, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.owner;                                                                               
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var x_pre: Node;                                                                                   
 var Node.owner_pre: [Node]List;                                                                    
 var v_pre: List;                                                                                   
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var v_post: List;                                                                                  
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.owner(t: Tid,x: Node,v: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[x] := v;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.owner (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to Node.owner (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to Node.owner (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Node.item is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Node.item is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.next(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (6.5): Node.next is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (6.5): Node.next is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var w0_mid: List;                                                                                  
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: List;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.owner[y] := w;                                                                                
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to Node.owner (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.owner(u: Tid,y: Node,w: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.owner[y] := w;                                                                                
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.owner (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.owner (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to Node.owner (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.owner(t: Tid, u: Tid, v: Node, w: List, w0: List, x: List, y: Node)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.owner;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var w0_pre: List;                                                                                  
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var w_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var y_post: Node;                                                                                  
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var List._state_post: [List]State;                                                                 
 var w_post: List;                                                                                  
 var v_post: Node;                                                                                  
 var w0_post: List;                                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.owner(u: Tid,y: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Node.owner is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Node.owner is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_mid: [Node]Node;                                                                     
 var t_mid: Tid;                                                                                    
 var Node.owner_mid: [Node]List;                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var v_mid: Node;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var y_mid: List;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node.owner_mid == Node.owner && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (27.5): List.head is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to List.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (27.5): List.head is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Node.owner_pre: [Node]List;                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var Node.next_pre: [Node]Node;                                                                     
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var $recorded.state_post: int;                                                                     
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var Node.owner_post: [Node]List;                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Node._state_post: [Node]State;                                                                 
 var Node.next_post: [Node]Node;                                                                    
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node.owner_post == Node.owner && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (27.5): List.head is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (27.5): List.head is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node.owner;                                                                                
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
ensures StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
ensures Y(tid , old(Node._state), old(Node.item), old(Node.next), old(Node.owner), old(Node._lock), old(List._state), old(List.head), old(List._lock) , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Node.item:                                                                                       
                                                                                                    
function {:inline} Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.item(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Node.item[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.item(tid : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var newValue_yield: int;                                                                            
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.item(u: Tid,this: Node,newValue: int,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, Node.item[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Transitive(tid : Tid, this: Node, newValue : int , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (5.23): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (5.23): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var newValue_pre: int;                                                                              
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Node.item(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.item(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Node.next[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (6.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (6.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Node.next(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Node.owner:                                                                                      
                                                                                                    
function {:inline} Y_Node.owner(tid : Tid, this: Node, newValue: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.owner(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Node.owner[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.owner(tid : Tid, this: Node, newValue: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.owner.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var newValue_yield: List;                                                                           
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.owner(u: Tid,this: Node,newValue: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.owner(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.owner.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.owner(tid, this, Node.owner[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.owner.Transitive(tid : Tid, this: Node, newValue : List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (7.25): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (7.25): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var newValue_pre: List;                                                                             
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var newValue_post: List;                                                                            
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Node.owner(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.owner(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var this_yield: Node;                                                                               
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (4.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (4.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Node._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// List.head:                                                                                       
                                                                                                    
function {:inline} Y_List.head(tid : Tid, this: List, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(List._state[this], tid) && leq(m#moverPath(ReadEval.List.head(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _R)) ==> (List.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_List.head(tid : Tid, this: List, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_List.head.Subsumes.W(tid : Tid, u : Tid, this: List, newValue: Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume isAccessible(List._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.List.head(u: Tid,this: List,newValue: Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List.head(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List.head.Reflexive(tid : Tid, this: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List.head(tid, this, List.head[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List.head.Transitive(tid : Tid, this: List, newValue : Node , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (27.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (27.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
var this_pre: List;                                                                                 
                                                                                                    
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var $pc_post: Phase;                                                                                
var this_post: List;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var List._state_post: [List]State;                                                                  
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_List.head(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_List.head(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// List._lock:                                                                                      
                                                                                                    
function {:inline} Y_List._lock(tid : Tid, this: List, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(List._state[this], tid) && leq(m#moverPath(ReadEval.List._lock(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _R)) ==> (List._lock[this] == newValue))
 &&(((List._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_List._lock(tid : Tid, this: List, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Subsumes.W(tid : Tid, u : Tid, this: List, newValue: Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume isAccessible(List._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.List._lock(u: Tid,this: List,newValue: Tid,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)));
 assume leq(m#moverPath(ReadEval.List._lock(tid: Tid,this: List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock)), _N);
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Reflexive(tid : Tid, this: List , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Node.next_yield: [Node]Node;                                                                    
var Node.item_yield: [Node]int;                                                                     
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Node.owner_yield: [Node]List;                                                                   
var $pc_yield: Phase;                                                                               
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
assume Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node.owner_yield == Node.owner && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List._lock(tid, this, List._lock[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Transitive(tid : Tid, this: List, newValue : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339509(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339517(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339532(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339549(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2339565(tid: Tid,_this : Node,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340192(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (25.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2340199(tid: Tid,_this : List,Node._state,Node.item,Node.next,Node.owner,Node._lock,List._state,List.head,List._lock));       // (25.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Node.owner_pre: [Node]List;                                                                     
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var $pc_pre: Phase;                                                                                 
var Node.next_pre: [Node]Node;                                                                      
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
var this_pre: List;                                                                                 
                                                                                                    
var $recorded.state_post: int;                                                                      
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var $pc_post: Phase;                                                                                
var this_post: List;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var Node.owner_post: [Node]List;                                                                    
var List.head_post: [List]Node;                                                                     
var Node._state_post: [Node]State;                                                                  
var Node.next_post: [Node]Node;                                                                     
var List._state_post: [List]State;                                                                  
var newValue_post: Tid;                                                                             
                                                                                                    
assume Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node.owner_pre == Node.owner && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume Y(tid , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_List._lock(tid, this, newValue , Node._state_p, Node.item_p, Node.next_p, Node.owner_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node.owner_post == Node.owner_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_List._lock(tid, this, newValue , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]Node, Node.owner: [Node]List, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]Node, Node.owner_p: [Node]List, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid): bool
{                                                                                                   
 (forall this: Node :: Y_Node.item(tid : Tid, this, Node.item_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock))
 && (forall this: Node :: Y_Node.owner(tid : Tid, this, Node.owner_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock))
 && (forall this: List :: Y_List.head(tid : Tid, this, List.head_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock))
 && (forall this: List :: Y_List._lock(tid : Tid, this, List._lock_p[this] , Node._state, Node.item, Node.next, Node.owner, Node._lock, List._state, List.head, List._lock))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : List :: isShared(List._state[_i]) ==> isShared(List._state_p[_i]))                 
 && (forall _i : List :: isLocal(List._state[_i], tid) <==> isLocal(List._state_p[_i], tid))        
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1625.1-2134.2: (Method:33.5)
// 1637.1-1637.24: (33.5): Bad tid
// 1644.1-1644.243: (33.5): Object invariant may not hold.
// 1645.1-1645.243: (33.5): Object invariant may not hold.
// 1646.1-1646.243: (33.5): Object invariant may not hold.
// 1647.1-1647.243: (33.5): Object invariant may not hold.
// 1648.1-1648.243: (33.5): Object invariant may not hold.
// 1649.1-1649.252: (33.5): Object invariant may not hold.
// 1650.1-1650.252: (33.5): Object invariant may not hold.
// 1653.1-1653.242: (33.5): Object invariant may not hold.
// 1654.1-1654.242: (33.5): Object invariant may not hold.
// 1655.1-1655.242: (33.5): Object invariant may not hold.
// 1656.1-1656.242: (33.5): Object invariant may not hold.
// 1657.1-1657.242: (33.5): Object invariant may not hold.
// 1658.1-1658.242: (33.5): Object invariant may not hold.
// 1659.1-1659.242: (33.5): Object invariant may not hold.
// 1833.1-1833.165: (33.5): Can only have right-mover memory accesses in requires clause
// 1835.2-1838.38: (class anchor.sink.Assume:33.5)
// 1839.2-1841.2: (class anchor.sink.VarDeclStmt:34.9)
// 1842.2-1851.39: (class anchor.sink.Alloc:34.9)
// 1854.2-1856.2: (class anchor.sink.VarDeclStmt:34.9)
// 1857.2-1859.2: (class anchor.sink.VarDeclStmt:34.9)
// 1860.2-1862.2: (class anchor.sink.VarDeclStmt:34.9)
// 1863.2-1866.25: (class anchor.sink.Assign:34.9)
// 1867.2-1870.25: (class anchor.sink.Assign:34.9)
// 1871.2-1874.19: (class anchor.sink.Assign:34.9)
// 1875.2-1878.34: (class anchor.sink.Assume:19.5)
// 1879.2-1882.42: (class anchor.sink.Assume:19.5)
// 1883.2-1886.43: (class anchor.sink.Assume:19.5)
// 1888.2-1904.34: (class anchor.sink.Write:20.9)
// 1900.1-1900.32: (20.9): Cannot have potential null deference in left-mover part.
// 1903.1-1903.27: (20.9): Reduction failure
// 1906.2-1927.2: (class anchor.sink.Write:21.9)
// 1918.1-1918.32: (21.9): Cannot have potential null deference in left-mover part.
// 1921.1-1921.27: (21.9): Reduction failure
// 1925.1-1925.64: (21.9): owner$209 became shared, but owner$209.head may not be shared.
// 1928.2-1931.23: (class anchor.sink.Break:19.32)
// 1933.2-1935.2: (class anchor.sink.VarDeclStmt:35.9)
// 1936.2-1945.39: (class anchor.sink.Alloc:35.9)
// 1948.2-1950.2: (class anchor.sink.VarDeclStmt:35.9)
// 1951.2-1953.2: (class anchor.sink.VarDeclStmt:35.9)
// 1954.2-1956.2: (class anchor.sink.VarDeclStmt:35.9)
// 1957.2-1960.26: (class anchor.sink.Assign:35.9)
// 1961.2-1964.25: (class anchor.sink.Assign:35.9)
// 1965.2-1968.19: (class anchor.sink.Assign:35.9)
// 1969.2-1972.34: (class anchor.sink.Assume:19.5)
// 1973.2-1976.42: (class anchor.sink.Assume:19.5)
// 1977.2-1980.43: (class anchor.sink.Assume:19.5)
// 1982.2-1998.34: (class anchor.sink.Write:20.9)
// 1994.1-1994.32: (20.9): Cannot have potential null deference in left-mover part.
// 1997.1-1997.27: (20.9): Reduction failure
// 2000.2-2021.2: (class anchor.sink.Write:21.9)
// 2012.1-2012.32: (21.9): Cannot have potential null deference in left-mover part.
// 2015.1-2015.27: (21.9): Reduction failure
// 2019.1-2019.64: (21.9): owner$210 became shared, but owner$210.head may not be shared.
// 2022.2-2025.23: (class anchor.sink.Break:19.32)
// 2027.2-2120.59: (class anchor.sink.LocalWrites:36.9)
// 2030.1-2030.26: (36.9): Local Write block must appear pre commit.
// 2031.2-2049.27: (class anchor.sink.Write:36.9)
// 2043.1-2043.28: (36.9): Cannot have potential null deference in left-mover part.
// 2047.1-2047.27: (36.9): Reduction failure
// 2048.1-2048.26: (36.9): Local Write block can only include right-movers.
// 2050.2-2068.26: (class anchor.sink.Write:36.28)
// 2062.1-2062.28: (36.28): Cannot have potential null deference in left-mover part.
// 2066.1-2066.27: (36.28): Reduction failure
// 2067.1-2067.26: (36.28): Local Write block can only include right-movers.
// 2069.2-2087.27: (class anchor.sink.Write:36.46)
// 2081.1-2081.28: (36.46): Cannot have potential null deference in left-mover part.
// 2085.1-2085.27: (36.46): Reduction failure
// 2086.1-2086.26: (36.46): Local Write block can only include right-movers.
// 2088.2-2106.26: (class anchor.sink.Write:36.65)
// 2100.1-2100.28: (36.65): Cannot have potential null deference in left-mover part.
// 2104.1-2104.27: (36.65): Reduction failure
// 2105.1-2105.26: (36.65): Local Write block can only include right-movers.
// 2107.1-2107.41: (36.9): Can only have local designators in Local Write block.
// 2108.1-2108.41: (36.28): Can only have local designators in Local Write block.
// 2109.1-2109.41: (36.46): Can only have local designators in Local Write block.
// 2110.1-2110.41: (36.65): Can only have local designators in Local Write block.
// 2115.1-2115.58: (36.9): this became shared, but this.head may not be shared.
// 2116.1-2116.58: (36.28): head became shared, but head.next may not be shared.
// 2117.1-2117.59: (36.28): head became shared, but head.owner may not be shared.
// 2118.1-2118.58: (36.46): this became shared, but this.head may not be shared.
// 2119.1-2119.58: (36.65): tail became shared, but tail.next may not be shared.
// 2120.1-2120.59: (36.65): tail became shared, but tail.owner may not be shared.
// 2121.2-2133.9: (class anchor.sink.Return:33.19)
// 2126.1-2126.242: (33.19): Object invariant may not hold.
// 2127.1-2127.242: (33.19): Object invariant may not hold.
// 2128.1-2128.242: (33.19): Object invariant may not hold.
// 2129.1-2129.242: (33.19): Object invariant may not hold.
// 2130.1-2130.242: (33.19): Object invariant may not hold.
// 2131.1-2131.242: (33.19): Object invariant may not hold.
// 2132.1-2132.242: (33.19): Object invariant may not hold.
// 2135.1-2877.2: (Method:39.5)
// 2148.1-2148.24: (39.5): Bad tid
// 2149.1-2149.38: (39.5): this is not global
// 2154.1-2154.243: (39.5): Object invariant may not hold.
// 2155.1-2155.243: (39.5): Object invariant may not hold.
// 2156.1-2156.243: (39.5): Object invariant may not hold.
// 2157.1-2157.243: (39.5): Object invariant may not hold.
// 2158.1-2158.243: (39.5): Object invariant may not hold.
// 2159.1-2159.243: (39.5): Object invariant may not hold.
// 2160.1-2160.243: (39.5): Object invariant may not hold.
// 2163.1-2163.242: (39.5): Object invariant may not hold.
// 2164.1-2164.242: (39.5): Object invariant may not hold.
// 2165.1-2165.242: (39.5): Object invariant may not hold.
// 2166.1-2166.242: (39.5): Object invariant may not hold.
// 2167.1-2167.242: (39.5): Object invariant may not hold.
// 2168.1-2168.242: (39.5): Object invariant may not hold.
// 2169.1-2169.242: (39.5): Object invariant may not hold.
// 2481.1-2481.14: (39.29): Can only have right-mover memory accesses in requires clause
// 2483.2-2485.2: (class anchor.sink.VarDeclStmt:41.9)
// 2486.2-2488.2: (class anchor.sink.VarDeclStmt:42.9)
// 2489.2-2491.2: (class anchor.sink.VarDeclStmt:43.9)
// 2492.2-2495.14: (class anchor.sink.Assign:43.9)
// 2499.1-2499.28: (44.22): Cannot have potential null deference in left-mover part.
// 2503.1-2503.27: (44.22): Reduction failure
// 2505.2-2522.26: (class anchor.sink.Read:45.13)
// 2517.1-2517.28: (45.13): Cannot have potential null deference in left-mover part.
// 2521.1-2521.27: (45.13): Reduction failure
// 2523.2-2540.26: (class anchor.sink.Read:46.13)
// 2535.1-2535.28: (46.13): Cannot have potential null deference in left-mover part.
// 2539.1-2539.27: (46.13): Reduction failure
// 2543.2-2547.14: (class anchor.sink.While:48.13)
// 2549.1-2549.27: (39.5): Bad tid
// 2550.1-2550.41: (39.5): this is not global
// 2553.1-2553.246: (48.13): Object invariant may not hold.
// 2554.1-2554.246: (48.13): Object invariant may not hold.
// 2555.1-2555.246: (48.13): Object invariant may not hold.
// 2556.1-2556.246: (48.13): Object invariant may not hold.
// 2557.1-2557.246: (48.13): Object invariant may not hold.
// 2558.1-2558.246: (48.13): Object invariant may not hold.
// 2559.1-2559.246: (48.13): Object invariant may not hold.
// 2559.246-2560.41: (48.13): invariant isShared(curr) may not hold
// 2560.41-2561.41: (48.13): invariant isShared(pred) may not hold
// 2561.41-2562.36: (48.13): invariant pred.item < item may not hold
// 2562.36-2563.37: (48.13): invariant curr == pred.next may not hold
// 2563.37-2564.38: (48.13): invariant pred.owner == this may not hold
// 2564.38-2565.38: (48.13): invariant curr.owner == this may not hold
// 2565.38-2566.79: (48.13): invariant holds(this, tid) may not hold
// 2567.1-2567.240: (48.13): Loop does not preserve yields_as annotation for field item
// 2568.1-2568.240: (48.13): Loop does not preserve yields_as annotation for field next
// 2569.1-2569.242: (48.13): Loop does not preserve yields_as annotation for field owner
// 2570.1-2570.240: (48.13): Loop does not preserve yields_as annotation for field head
// 2571.1-2571.33: (48.13): Phase must be invariant at loop head
// 2572.1-2572.30: (48.13): Potentially infinite loop cannot be in post-commit phase.
// 2574.3-2576.3: (class anchor.sink.VarDeclStmt:48.30)
// 2577.3-2579.3: (class anchor.sink.VarDeclStmt:48.20)
// 2580.3-2597.27: (class anchor.sink.Read:48.20)
// 2592.1-2592.29: (48.20): Cannot have potential null deference in left-mover part.
// 2596.1-2596.28: (48.20): Reduction failure
// 2598.3-2601.23: (class anchor.sink.Assign:48.30)
// 2603.4-2606.10: (class anchor.sink.Break:48.13)
// 2609.3-2612.16: (class anchor.sink.Assign:56.17)
// 2613.3-2630.27: (class anchor.sink.Read:57.17)
// 2625.1-2625.29: (57.17): Cannot have potential null deference in left-mover part.
// 2629.1-2629.28: (57.17): Reduction failure
// 2633.1-2633.30: (48.13): Phase must be invariant at loop head
// 2635.2-2637.2: (class anchor.sink.VarDeclStmt:59.13)
// 2638.2-2640.2: (class anchor.sink.VarDeclStmt:59.13)
// 2641.2-2658.26: (class anchor.sink.Read:59.13)
// 2653.1-2653.28: (59.13): Cannot have potential null deference in left-mover part.
// 2657.1-2657.27: (59.13): Reduction failure
// 2659.2-2662.23: (class anchor.sink.Assign:59.13)
// 2667.1-2667.29: (67.9): Cannot have potential null deference in left-mover part.
// 2669.1-2669.34: (67.9): lock not held
// 2671.1-2671.28: (67.9): Reduction failure
// 2673.3-2686.10: (class anchor.sink.Return:60.17)
// 2679.1-2679.243: (60.17): Object invariant may not hold.
// 2680.1-2680.243: (60.17): Object invariant may not hold.
// 2681.1-2681.243: (60.17): Object invariant may not hold.
// 2682.1-2682.243: (60.17): Object invariant may not hold.
// 2683.1-2683.243: (60.17): Object invariant may not hold.
// 2684.1-2684.243: (60.17): Object invariant may not hold.
// 2685.1-2685.243: (60.17): Object invariant may not hold.
// 2688.3-2690.3: (class anchor.sink.VarDeclStmt:62.17)
// 2691.3-2700.40: (class anchor.sink.Alloc:62.17)
// 2703.3-2705.3: (class anchor.sink.VarDeclStmt:62.17)
// 2706.3-2708.3: (class anchor.sink.VarDeclStmt:62.17)
// 2709.3-2711.3: (class anchor.sink.VarDeclStmt:62.17)
// 2712.3-2715.20: (class anchor.sink.Assign:62.17)
// 2716.3-2719.21: (class anchor.sink.Assign:62.17)
// 2720.3-2723.20: (class anchor.sink.Assign:62.17)
// 2724.3-2727.35: (class anchor.sink.Assume:19.5)
// 2728.3-2731.43: (class anchor.sink.Assume:19.5)
// 2732.3-2735.44: (class anchor.sink.Assume:19.5)
// 2737.3-2753.35: (class anchor.sink.Write:20.9)
// 2749.1-2749.33: (20.9): Cannot have potential null deference in left-mover part.
// 2752.1-2752.28: (20.9): Reduction failure
// 2755.3-2776.3: (class anchor.sink.Write:21.9)
// 2767.1-2767.33: (21.9): Cannot have potential null deference in left-mover part.
// 2770.1-2770.28: (21.9): Reduction failure
// 2774.1-2774.65: (21.9): owner$211 became shared, but owner$211.head may not be shared.
// 2777.3-2780.24: (class anchor.sink.Break:19.32)
// 2783.3-2805.3: (class anchor.sink.Write:63.17)
// 2795.1-2795.29: (63.17): Cannot have potential null deference in left-mover part.
// 2798.1-2798.28: (63.17): Reduction failure
// 2802.1-2802.60: (63.17): curr became shared, but curr.next may not be shared.
// 2803.1-2803.61: (63.17): curr became shared, but curr.owner may not be shared.
// 2807.3-2829.3: (class anchor.sink.Write:64.17)
// 2819.1-2819.29: (64.17): Cannot have potential null deference in left-mover part.
// 2822.1-2822.28: (64.17): Reduction failure
// 2826.1-2826.60: (64.17): node became shared, but node.next may not be shared.
// 2827.1-2827.61: (64.17): node became shared, but node.owner may not be shared.
// 2833.1-2833.29: (67.9): Cannot have potential null deference in left-mover part.
// 2835.1-2835.34: (67.9): lock not held
// 2837.1-2837.28: (67.9): Reduction failure
// 2839.3-2852.10: (class anchor.sink.Return:65.17)
// 2845.1-2845.243: (65.17): Object invariant may not hold.
// 2846.1-2846.243: (65.17): Object invariant may not hold.
// 2847.1-2847.243: (65.17): Object invariant may not hold.
// 2848.1-2848.243: (65.17): Object invariant may not hold.
// 2849.1-2849.243: (65.17): Object invariant may not hold.
// 2850.1-2850.243: (65.17): Object invariant may not hold.
// 2851.1-2851.243: (65.17): Object invariant may not hold.
// 2857.1-2857.28: (67.9): Cannot have potential null deference in left-mover part.
// 2859.1-2859.33: (67.9): lock not held
// 2861.1-2861.27: (67.9): Reduction failure
// 2863.2-2876.9: (class anchor.sink.Return:40.34)
// 2869.1-2869.242: (40.34): Object invariant may not hold.
// 2870.1-2870.242: (40.34): Object invariant may not hold.
// 2871.1-2871.242: (40.34): Object invariant may not hold.
// 2872.1-2872.242: (40.34): Object invariant may not hold.
// 2873.1-2873.242: (40.34): Object invariant may not hold.
// 2874.1-2874.242: (40.34): Object invariant may not hold.
// 2875.1-2875.242: (40.34): Object invariant may not hold.
// 2878.1-3448.2: (Method:70.5)
// 2891.1-2891.24: (70.5): Bad tid
// 2892.1-2892.38: (70.5): this is not global
// 2897.1-2897.243: (70.5): Object invariant may not hold.
// 2898.1-2898.243: (70.5): Object invariant may not hold.
// 2899.1-2899.243: (70.5): Object invariant may not hold.
// 2900.1-2900.243: (70.5): Object invariant may not hold.
// 2901.1-2901.243: (70.5): Object invariant may not hold.
// 2902.1-2902.243: (70.5): Object invariant may not hold.
// 2903.1-2903.243: (70.5): Object invariant may not hold.
// 2906.1-2906.242: (70.5): Object invariant may not hold.
// 2907.1-2907.242: (70.5): Object invariant may not hold.
// 2908.1-2908.242: (70.5): Object invariant may not hold.
// 2909.1-2909.242: (70.5): Object invariant may not hold.
// 2910.1-2910.242: (70.5): Object invariant may not hold.
// 2911.1-2911.242: (70.5): Object invariant may not hold.
// 2912.1-2912.242: (70.5): Object invariant may not hold.
// 3156.1-3156.14: (70.29): Can only have right-mover memory accesses in requires clause
// 3158.2-3160.2: (class anchor.sink.VarDeclStmt:72.9)
// 3161.2-3163.2: (class anchor.sink.VarDeclStmt:73.9)
// 3167.1-3167.28: (74.22): Cannot have potential null deference in left-mover part.
// 3171.1-3171.27: (74.22): Reduction failure
// 3173.2-3190.26: (class anchor.sink.Read:75.13)
// 3185.1-3185.28: (75.13): Cannot have potential null deference in left-mover part.
// 3189.1-3189.27: (75.13): Reduction failure
// 3191.2-3208.26: (class anchor.sink.Read:76.13)
// 3203.1-3203.28: (76.13): Cannot have potential null deference in left-mover part.
// 3207.1-3207.27: (76.13): Reduction failure
// 3211.2-3215.14: (class anchor.sink.While:78.13)
// 3217.1-3217.27: (70.5): Bad tid
// 3218.1-3218.41: (70.5): this is not global
// 3221.1-3221.246: (78.13): Object invariant may not hold.
// 3222.1-3222.246: (78.13): Object invariant may not hold.
// 3223.1-3223.246: (78.13): Object invariant may not hold.
// 3224.1-3224.246: (78.13): Object invariant may not hold.
// 3225.1-3225.246: (78.13): Object invariant may not hold.
// 3226.1-3226.246: (78.13): Object invariant may not hold.
// 3227.1-3227.246: (78.13): Object invariant may not hold.
// 3227.246-3228.41: (78.13): invariant isShared(curr) may not hold
// 3228.41-3229.41: (78.13): invariant isShared(pred) may not hold
// 3229.41-3230.36: (78.13): invariant pred.item < item may not hold
// 3230.36-3231.37: (78.13): invariant curr == pred.next may not hold
// 3231.37-3232.38: (78.13): invariant pred.owner == this may not hold
// 3232.38-3233.38: (78.13): invariant curr.owner == this may not hold
// 3233.38-3234.79: (78.13): invariant holds(this, tid) may not hold
// 3235.1-3235.240: (78.13): Loop does not preserve yields_as annotation for field item
// 3236.1-3236.240: (78.13): Loop does not preserve yields_as annotation for field next
// 3237.1-3237.242: (78.13): Loop does not preserve yields_as annotation for field owner
// 3238.1-3238.240: (78.13): Loop does not preserve yields_as annotation for field head
// 3239.1-3239.33: (78.13): Phase must be invariant at loop head
// 3240.1-3240.30: (78.13): Potentially infinite loop cannot be in post-commit phase.
// 3242.3-3244.3: (class anchor.sink.VarDeclStmt:78.30)
// 3245.3-3247.3: (class anchor.sink.VarDeclStmt:78.20)
// 3248.3-3265.27: (class anchor.sink.Read:78.20)
// 3260.1-3260.29: (78.20): Cannot have potential null deference in left-mover part.
// 3264.1-3264.28: (78.20): Reduction failure
// 3266.3-3269.23: (class anchor.sink.Assign:78.30)
// 3271.4-3274.10: (class anchor.sink.Break:78.13)
// 3277.3-3280.16: (class anchor.sink.Assign:86.17)
// 3281.3-3298.27: (class anchor.sink.Read:87.17)
// 3293.1-3293.29: (87.17): Cannot have potential null deference in left-mover part.
// 3297.1-3297.28: (87.17): Reduction failure
// 3301.1-3301.30: (78.13): Phase must be invariant at loop head
// 3303.2-3305.2: (class anchor.sink.VarDeclStmt:89.13)
// 3306.2-3308.2: (class anchor.sink.VarDeclStmt:89.13)
// 3309.2-3326.26: (class anchor.sink.Read:89.13)
// 3321.1-3321.28: (89.13): Cannot have potential null deference in left-mover part.
// 3325.1-3325.27: (89.13): Reduction failure
// 3327.2-3330.23: (class anchor.sink.Assign:89.13)
// 3332.3-3334.3: (class anchor.sink.VarDeclStmt:90.17)
// 3335.3-3352.27: (class anchor.sink.Read:90.17)
// 3347.1-3347.29: (90.17): Cannot have potential null deference in left-mover part.
// 3351.1-3351.28: (90.17): Reduction failure
// 3354.3-3376.3: (class anchor.sink.Write:90.17)
// 3366.1-3366.29: (90.17): Cannot have potential null deference in left-mover part.
// 3369.1-3369.28: (90.17): Reduction failure
// 3373.1-3373.60: (90.17): tmp9 became shared, but tmp9.next may not be shared.
// 3374.1-3374.61: (90.17): tmp9 became shared, but tmp9.owner may not be shared.
// 3380.1-3380.29: (95.9): Cannot have potential null deference in left-mover part.
// 3382.1-3382.34: (95.9): lock not held
// 3384.1-3384.28: (95.9): Reduction failure
// 3386.3-3399.10: (class anchor.sink.Return:91.17)
// 3392.1-3392.243: (91.17): Object invariant may not hold.
// 3393.1-3393.243: (91.17): Object invariant may not hold.
// 3394.1-3394.243: (91.17): Object invariant may not hold.
// 3395.1-3395.243: (91.17): Object invariant may not hold.
// 3396.1-3396.243: (91.17): Object invariant may not hold.
// 3397.1-3397.243: (91.17): Object invariant may not hold.
// 3398.1-3398.243: (91.17): Object invariant may not hold.
// 3404.1-3404.29: (95.9): Cannot have potential null deference in left-mover part.
// 3406.1-3406.34: (95.9): lock not held
// 3408.1-3408.28: (95.9): Reduction failure
// 3410.3-3423.10: (class anchor.sink.Return:93.17)
// 3416.1-3416.243: (93.17): Object invariant may not hold.
// 3417.1-3417.243: (93.17): Object invariant may not hold.
// 3418.1-3418.243: (93.17): Object invariant may not hold.
// 3419.1-3419.243: (93.17): Object invariant may not hold.
// 3420.1-3420.243: (93.17): Object invariant may not hold.
// 3421.1-3421.243: (93.17): Object invariant may not hold.
// 3422.1-3422.243: (93.17): Object invariant may not hold.
// 3428.1-3428.28: (95.9): Cannot have potential null deference in left-mover part.
// 3430.1-3430.33: (95.9): lock not held
// 3432.1-3432.27: (95.9): Reduction failure
// 3434.2-3447.9: (class anchor.sink.Return:71.37)
// 3440.1-3440.242: (71.37): Object invariant may not hold.
// 3441.1-3441.242: (71.37): Object invariant may not hold.
// 3442.1-3442.242: (71.37): Object invariant may not hold.
// 3443.1-3443.242: (71.37): Object invariant may not hold.
// 3444.1-3444.242: (71.37): Object invariant may not hold.
// 3445.1-3445.242: (71.37): Object invariant may not hold.
// 3446.1-3446.242: (71.37): Object invariant may not hold.
// 3449.1-3879.2: (Method:99.5)
// 3462.1-3462.24: (99.5): Bad tid
// 3463.1-3463.38: (99.5): this is not global
// 3468.1-3468.243: (99.5): Object invariant may not hold.
// 3469.1-3469.243: (99.5): Object invariant may not hold.
// 3470.1-3470.243: (99.5): Object invariant may not hold.
// 3471.1-3471.243: (99.5): Object invariant may not hold.
// 3472.1-3472.243: (99.5): Object invariant may not hold.
// 3473.1-3473.243: (99.5): Object invariant may not hold.
// 3474.1-3474.243: (99.5): Object invariant may not hold.
// 3477.1-3477.242: (99.5): Object invariant may not hold.
// 3478.1-3478.242: (99.5): Object invariant may not hold.
// 3479.1-3479.242: (99.5): Object invariant may not hold.
// 3480.1-3480.242: (99.5): Object invariant may not hold.
// 3481.1-3481.242: (99.5): Object invariant may not hold.
// 3482.1-3482.242: (99.5): Object invariant may not hold.
// 3483.1-3483.242: (99.5): Object invariant may not hold.
// 3660.1-3660.14: (99.29): Can only have right-mover memory accesses in requires clause
// 3665.1-3665.28: (101.22): Cannot have potential null deference in left-mover part.
// 3669.1-3669.27: (101.22): Reduction failure
// 3671.2-3673.2: (class anchor.sink.VarDeclStmt:102.13)
// 3674.2-3691.26: (class anchor.sink.Read:102.13)
// 3686.1-3686.28: (102.13): Cannot have potential null deference in left-mover part.
// 3690.1-3690.27: (102.13): Reduction failure
// 3692.2-3694.2: (class anchor.sink.VarDeclStmt:103.13)
// 3695.2-3712.26: (class anchor.sink.Read:103.13)
// 3707.1-3707.28: (103.13): Cannot have potential null deference in left-mover part.
// 3711.1-3711.27: (103.13): Reduction failure
// 3715.2-3719.14: (class anchor.sink.While:104.13)
// 3721.1-3721.27: (99.5): Bad tid
// 3722.1-3722.41: (99.5): this is not global
// 3725.1-3725.246: (104.13): Object invariant may not hold.
// 3726.1-3726.246: (104.13): Object invariant may not hold.
// 3727.1-3727.246: (104.13): Object invariant may not hold.
// 3728.1-3728.246: (104.13): Object invariant may not hold.
// 3729.1-3729.246: (104.13): Object invariant may not hold.
// 3730.1-3730.246: (104.13): Object invariant may not hold.
// 3731.1-3731.246: (104.13): Object invariant may not hold.
// 3731.246-3732.41: (104.13): invariant isShared(curr) may not hold
// 3732.41-3733.38: (104.13): invariant curr.owner == this may not hold
// 3733.38-3734.38: (104.13): invariant pred.owner == this may not hold
// 3734.38-3735.37: (104.13): invariant curr == pred.next may not hold
// 3735.37-3736.79: (104.13): invariant holds(this, tid) may not hold
// 3737.1-3737.240: (104.13): Loop does not preserve yields_as annotation for field item
// 3738.1-3738.240: (104.13): Loop does not preserve yields_as annotation for field next
// 3739.1-3739.242: (104.13): Loop does not preserve yields_as annotation for field owner
// 3740.1-3740.240: (104.13): Loop does not preserve yields_as annotation for field head
// 3741.1-3741.33: (104.13): Phase must be invariant at loop head
// 3742.1-3742.30: (104.13): Potentially infinite loop cannot be in post-commit phase.
// 3744.3-3746.3: (class anchor.sink.VarDeclStmt:104.30)
// 3747.3-3749.3: (class anchor.sink.VarDeclStmt:104.20)
// 3750.3-3767.28: (class anchor.sink.Read:104.20)
// 3762.1-3762.29: (104.20): Cannot have potential null deference in left-mover part.
// 3766.1-3766.28: (104.20): Reduction failure
// 3768.3-3771.25: (class anchor.sink.Assign:104.30)
// 3773.4-3776.10: (class anchor.sink.Break:104.13)
// 3779.3-3782.16: (class anchor.sink.Assign:110.17)
// 3783.3-3800.27: (class anchor.sink.Read:111.17)
// 3795.1-3795.29: (111.17): Cannot have potential null deference in left-mover part.
// 3799.1-3799.28: (111.17): Reduction failure
// 3803.1-3803.30: (104.13): Phase must be invariant at loop head
// 3805.2-3807.2: (class anchor.sink.VarDeclStmt:113.13)
// 3808.2-3810.2: (class anchor.sink.VarDeclStmt:113.13)
// 3811.2-3828.27: (class anchor.sink.Read:113.13)
// 3823.1-3823.28: (113.13): Cannot have potential null deference in left-mover part.
// 3827.1-3827.27: (113.13): Reduction failure
// 3829.2-3832.25: (class anchor.sink.Assign:113.13)
// 3836.1-3836.28: (114.9): Cannot have potential null deference in left-mover part.
// 3838.1-3838.33: (114.9): lock not held
// 3840.1-3840.27: (114.9): Reduction failure
// 3842.2-3855.9: (class anchor.sink.Return:113.13)
// 3848.1-3848.242: (113.13): Object invariant may not hold.
// 3849.1-3849.242: (113.13): Object invariant may not hold.
// 3850.1-3850.242: (113.13): Object invariant may not hold.
// 3851.1-3851.242: (113.13): Object invariant may not hold.
// 3852.1-3852.242: (113.13): Object invariant may not hold.
// 3853.1-3853.242: (113.13): Object invariant may not hold.
// 3854.1-3854.242: (113.13): Object invariant may not hold.
// 3859.1-3859.28: (114.9): Cannot have potential null deference in left-mover part.
// 3861.1-3861.33: (114.9): lock not held
// 3863.1-3863.27: (114.9): Reduction failure
// 3865.2-3878.9: (class anchor.sink.Return:100.39)
// 3871.1-3871.242: (100.39): Object invariant may not hold.
// 3872.1-3872.242: (100.39): Object invariant may not hold.
// 3873.1-3873.242: (100.39): Object invariant may not hold.
// 3874.1-3874.242: (100.39): Object invariant may not hold.
// 3875.1-3875.242: (100.39): Object invariant may not hold.
// 3876.1-3876.242: (100.39): Object invariant may not hold.
// 3877.1-3877.242: (100.39): Object invariant may not hold.
// 3970.1-3970.34: (5.5): Node.item failed Write-Write Right-Mover Check
// 4037.1-4037.30: (5.5): Node.item failed Write-Read Right-Mover Check
// 4108.1-4108.34: (5.5): Node.item failed Write-Write Left-Mover Check
// 4176.1-4176.30: (5.5): Node.item failed Write-Read Left-Mover Check
// 4241.1-4241.34: (5.5): Node.item failed Read-Write Right-Mover Check
// 4309.1-4309.34: (5.5): Node.item failed Read-Write Left-Mover Check
// 4376.1-4376.34: (6.5): Node.next failed Write-Write Right-Mover Check
// 4443.1-4443.30: (6.5): Node.next failed Write-Read Right-Mover Check
// 4514.1-4514.34: (6.5): Node.next failed Write-Write Left-Mover Check
// 4582.1-4582.30: (6.5): Node.next failed Write-Read Left-Mover Check
// 4647.1-4647.34: (6.5): Node.next failed Read-Write Right-Mover Check
// 4715.1-4715.34: (6.5): Node.next failed Read-Write Left-Mover Check
// 4782.1-4782.34: (7.5): Node.owner failed Write-Write Right-Mover Check
// 4849.1-4849.30: (7.5): Node.owner failed Write-Read Right-Mover Check
// 4920.1-4920.34: (7.5): Node.owner failed Write-Write Left-Mover Check
// 4988.1-4988.30: (7.5): Node.owner failed Write-Read Left-Mover Check
// 5053.1-5053.34: (7.5): Node.owner failed Read-Write Right-Mover Check
// 5121.1-5121.34: (7.5): Node.owner failed Read-Write Left-Mover Check
// 5188.1-5188.34: (27.5): List.head failed Write-Write Right-Mover Check
// 5255.1-5255.30: (27.5): List.head failed Write-Read Right-Mover Check
// 5326.1-5326.34: (27.5): List.head failed Write-Write Left-Mover Check
// 5394.1-5394.30: (27.5): List.head failed Write-Read Left-Mover Check
// 5459.1-5459.34: (27.5): List.head failed Read-Write Right-Mover Check
// 5527.1-5527.34: (27.5): List.head failed Read-Write Left-Mover Check
// 5606.1-5606.140: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
// 5607.1-5607.101: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
// 5608.1-5608.158: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
// 5716.1-5716.140: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
// 5829.1-5829.144: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
// 5830.1-5830.144: (5.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
// 5909.1-5909.136: (5.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
// 5910.1-5910.136: (5.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
// 5911.1-5911.146: (5.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
// 5989.1-5989.136: (5.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
// 5990.1-5990.136: (5.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
// 5991.1-5991.99: (5.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
// 6071.1-6071.140: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
// 6072.1-6072.101: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
// 6073.1-6073.158: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
// 6181.1-6181.140: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
// 6294.1-6294.144: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
// 6295.1-6295.144: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
// 6374.1-6374.136: (5.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
// 6375.1-6375.136: (5.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
// 6376.1-6376.146: (5.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
// 6454.1-6454.136: (6.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
// 6455.1-6455.136: (6.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
// 6456.1-6456.99: (6.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
// 6536.1-6536.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.1)
// 6537.1-6537.101: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.2)
// 6538.1-6538.158: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case A.3)
// 6646.1-6646.140: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case C)
// 6759.1-6759.144: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case D)
// 6760.1-6760.144: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case R)
// 6839.1-6839.136: (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case F)
// 6840.1-6840.136: (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case H)
// 6841.1-6841.146: (5.5): Node.item is not Read-Write Stable with respect to Node.owner (case I)
// 6919.1-6919.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case J)
// 6920.1-6920.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case K)
// 6921.1-6921.99: (7.5): Node.owner is not Write-Read Stable with respect to Node.item (case L)
// 7001.1-7001.140: (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.1)
// 7002.1-7002.101: (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.2)
// 7003.1-7003.156: (27.5): List.head is not Write-Write Stable with respect to Node.item (case A.3)
// 7111.1-7111.140: (5.5): Node.item is not Write-Write Stable with respect to List.head (case C)
// 7224.1-7224.144: (5.5): Node.item is not Write-Write Stable with respect to List.head (case D)
// 7225.1-7225.144: (5.5): Node.item is not Write-Write Stable with respect to List.head (case R)
// 7304.1-7304.136: (5.5): Node.item is not Read-Write Stable with respect to List.head (case F)
// 7305.1-7305.136: (5.5): Node.item is not Read-Write Stable with respect to List.head (case H)
// 7306.1-7306.144: (5.5): Node.item is not Read-Write Stable with respect to List.head (case I)
// 7384.1-7384.136: (27.5): List.head is not Write-Read Stable with respect to Node.item (case J)
// 7385.1-7385.136: (27.5): List.head is not Write-Read Stable with respect to Node.item (case K)
// 7386.1-7386.99: (27.5): List.head is not Write-Read Stable with respect to Node.item (case L)
// 7466.1-7466.140: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
// 7467.1-7467.101: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
// 7468.1-7468.158: (5.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
// 7576.1-7576.140: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
// 7689.1-7689.144: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
// 7690.1-7690.144: (6.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
// 7769.1-7769.136: (6.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
// 7770.1-7770.136: (6.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
// 7771.1-7771.146: (6.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
// 7849.1-7849.136: (5.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
// 7850.1-7850.136: (5.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
// 7851.1-7851.99: (5.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
// 7931.1-7931.140: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 7932.1-7932.101: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 7933.1-7933.158: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 8041.1-8041.140: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 8154.1-8154.144: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 8155.1-8155.144: (6.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 8234.1-8234.136: (6.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 8235.1-8235.136: (6.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 8236.1-8236.146: (6.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 8314.1-8314.136: (6.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 8315.1-8315.136: (6.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 8316.1-8316.99: (6.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 8396.1-8396.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.1)
// 8397.1-8397.101: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.2)
// 8398.1-8398.158: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case A.3)
// 8506.1-8506.140: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case C)
// 8619.1-8619.144: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case D)
// 8620.1-8620.144: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case R)
// 8699.1-8699.136: (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case F)
// 8700.1-8700.136: (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case H)
// 8701.1-8701.146: (6.5): Node.next is not Read-Write Stable with respect to Node.owner (case I)
// 8779.1-8779.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case J)
// 8780.1-8780.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case K)
// 8781.1-8781.99: (7.5): Node.owner is not Write-Read Stable with respect to Node.next (case L)
// 8861.1-8861.140: (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.1)
// 8862.1-8862.101: (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.2)
// 8863.1-8863.156: (27.5): List.head is not Write-Write Stable with respect to Node.next (case A.3)
// 8971.1-8971.140: (6.5): Node.next is not Write-Write Stable with respect to List.head (case C)
// 9084.1-9084.144: (6.5): Node.next is not Write-Write Stable with respect to List.head (case D)
// 9085.1-9085.144: (6.5): Node.next is not Write-Write Stable with respect to List.head (case R)
// 9164.1-9164.136: (6.5): Node.next is not Read-Write Stable with respect to List.head (case F)
// 9165.1-9165.136: (6.5): Node.next is not Read-Write Stable with respect to List.head (case H)
// 9166.1-9166.144: (6.5): Node.next is not Read-Write Stable with respect to List.head (case I)
// 9244.1-9244.136: (27.5): List.head is not Write-Read Stable with respect to Node.next (case J)
// 9245.1-9245.136: (27.5): List.head is not Write-Read Stable with respect to Node.next (case K)
// 9246.1-9246.99: (27.5): List.head is not Write-Read Stable with respect to Node.next (case L)
// 9326.1-9326.140: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.1)
// 9327.1-9327.101: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.2)
// 9328.1-9328.158: (5.5): Node.item is not Write-Write Stable with respect to Node.owner (case A.3)
// 9436.1-9436.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case C)
// 9549.1-9549.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case D)
// 9550.1-9550.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.item (case R)
// 9629.1-9629.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case F)
// 9630.1-9630.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case H)
// 9631.1-9631.146: (7.5): Node.owner is not Read-Write Stable with respect to Node.item (case I)
// 9709.1-9709.136: (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case J)
// 9710.1-9710.136: (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case K)
// 9711.1-9711.99: (5.5): Node.item is not Write-Read Stable with respect to Node.owner (case L)
// 9791.1-9791.140: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.1)
// 9792.1-9792.101: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.2)
// 9793.1-9793.158: (6.5): Node.next is not Write-Write Stable with respect to Node.owner (case A.3)
// 9901.1-9901.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case C)
// 10014.1-10014.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case D)
// 10015.1-10015.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.next (case R)
// 10094.1-10094.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case F)
// 10095.1-10095.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case H)
// 10096.1-10096.146: (7.5): Node.owner is not Read-Write Stable with respect to Node.next (case I)
// 10174.1-10174.136: (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case J)
// 10175.1-10175.136: (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case K)
// 10176.1-10176.99: (6.5): Node.next is not Write-Read Stable with respect to Node.owner (case L)
// 10256.1-10256.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.1)
// 10257.1-10257.101: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.2)
// 10258.1-10258.158: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case A.3)
// 10366.1-10366.140: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case C)
// 10479.1-10479.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case D)
// 10480.1-10480.144: (7.5): Node.owner is not Write-Write Stable with respect to Node.owner (case R)
// 10559.1-10559.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case F)
// 10560.1-10560.136: (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case H)
// 10561.1-10561.146: (7.5): Node.owner is not Read-Write Stable with respect to Node.owner (case I)
// 10639.1-10639.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case J)
// 10640.1-10640.136: (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case K)
// 10641.1-10641.99: (7.5): Node.owner is not Write-Read Stable with respect to Node.owner (case L)
// 10721.1-10721.140: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.1)
// 10722.1-10722.101: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.2)
// 10723.1-10723.156: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case A.3)
// 10831.1-10831.140: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case C)
// 10944.1-10944.144: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case D)
// 10945.1-10945.144: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case R)
// 11024.1-11024.136: (7.5): Node.owner is not Read-Write Stable with respect to List.head (case F)
// 11025.1-11025.136: (7.5): Node.owner is not Read-Write Stable with respect to List.head (case H)
// 11026.1-11026.144: (7.5): Node.owner is not Read-Write Stable with respect to List.head (case I)
// 11104.1-11104.136: (27.5): List.head is not Write-Read Stable with respect to Node.owner (case J)
// 11105.1-11105.136: (27.5): List.head is not Write-Read Stable with respect to Node.owner (case K)
// 11106.1-11106.99: (27.5): List.head is not Write-Read Stable with respect to Node.owner (case L)
// 11186.1-11186.140: (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.1)
// 11187.1-11187.101: (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.2)
// 11188.1-11188.156: (5.5): Node.item is not Write-Write Stable with respect to List.head (case A.3)
// 11296.1-11296.140: (27.5): List.head is not Write-Write Stable with respect to Node.item (case C)
// 11409.1-11409.144: (27.5): List.head is not Write-Write Stable with respect to Node.item (case D)
// 11410.1-11410.144: (27.5): List.head is not Write-Write Stable with respect to Node.item (case R)
// 11489.1-11489.136: (27.5): List.head is not Read-Write Stable with respect to Node.item (case F)
// 11490.1-11490.136: (27.5): List.head is not Read-Write Stable with respect to Node.item (case H)
// 11491.1-11491.144: (27.5): List.head is not Read-Write Stable with respect to Node.item (case I)
// 11569.1-11569.136: (5.5): Node.item is not Write-Read Stable with respect to List.head (case J)
// 11570.1-11570.136: (5.5): Node.item is not Write-Read Stable with respect to List.head (case K)
// 11571.1-11571.99: (5.5): Node.item is not Write-Read Stable with respect to List.head (case L)
// 11651.1-11651.140: (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.1)
// 11652.1-11652.101: (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.2)
// 11653.1-11653.156: (6.5): Node.next is not Write-Write Stable with respect to List.head (case A.3)
// 11761.1-11761.140: (27.5): List.head is not Write-Write Stable with respect to Node.next (case C)
// 11874.1-11874.144: (27.5): List.head is not Write-Write Stable with respect to Node.next (case D)
// 11875.1-11875.144: (27.5): List.head is not Write-Write Stable with respect to Node.next (case R)
// 11954.1-11954.136: (27.5): List.head is not Read-Write Stable with respect to Node.next (case F)
// 11955.1-11955.136: (27.5): List.head is not Read-Write Stable with respect to Node.next (case H)
// 11956.1-11956.144: (27.5): List.head is not Read-Write Stable with respect to Node.next (case I)
// 12034.1-12034.136: (6.5): Node.next is not Write-Read Stable with respect to List.head (case J)
// 12035.1-12035.136: (6.5): Node.next is not Write-Read Stable with respect to List.head (case K)
// 12036.1-12036.99: (6.5): Node.next is not Write-Read Stable with respect to List.head (case L)
// 12116.1-12116.140: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.1)
// 12117.1-12117.101: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.2)
// 12118.1-12118.156: (7.5): Node.owner is not Write-Write Stable with respect to List.head (case A.3)
// 12226.1-12226.140: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case C)
// 12339.1-12339.144: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case D)
// 12340.1-12340.144: (27.5): List.head is not Write-Write Stable with respect to Node.owner (case R)
// 12419.1-12419.136: (27.5): List.head is not Read-Write Stable with respect to Node.owner (case F)
// 12420.1-12420.136: (27.5): List.head is not Read-Write Stable with respect to Node.owner (case H)
// 12421.1-12421.144: (27.5): List.head is not Read-Write Stable with respect to Node.owner (case I)
// 12499.1-12499.136: (7.5): Node.owner is not Write-Read Stable with respect to List.head (case J)
// 12500.1-12500.136: (7.5): Node.owner is not Write-Read Stable with respect to List.head (case K)
// 12501.1-12501.99: (7.5): Node.owner is not Write-Read Stable with respect to List.head (case L)
// 12581.1-12581.140: (27.5): List.head is not Write-Write Stable with respect to List.head (case A.1)
// 12582.1-12582.101: (27.5): List.head is not Write-Write Stable with respect to List.head (case A.2)
// 12583.1-12583.158: (27.5): List.head is not Write-Write Stable with respect to List.head (case A.3)
// 12691.1-12691.140: (27.5): List.head is not Write-Write Stable with respect to List.head (case C)
// 12804.1-12804.144: (27.5): List.head is not Write-Write Stable with respect to List.head (case D)
// 12805.1-12805.144: (27.5): List.head is not Write-Write Stable with respect to List.head (case R)
// 12884.1-12884.136: (27.5): List.head is not Read-Write Stable with respect to List.head (case F)
// 12885.1-12885.136: (27.5): List.head is not Read-Write Stable with respect to List.head (case H)
// 12886.1-12886.146: (27.5): List.head is not Read-Write Stable with respect to List.head (case I)
// 12964.1-12964.136: (27.5): List.head is not Write-Read Stable with respect to List.head (case J)
// 12965.1-12965.136: (27.5): List.head is not Write-Read Stable with respect to List.head (case K)
// 12966.1-12966.99: (27.5): List.head is not Write-Read Stable with respect to List.head (case L)
// 12973.1-12973.243: (<undefined position>): Object invariant may not hold.
// 12974.1-12974.243: (<undefined position>): Object invariant may not hold.
// 12975.1-12975.243: (<undefined position>): Object invariant may not hold.
// 12976.1-12976.243: (<undefined position>): Object invariant may not hold.
// 12977.1-12977.243: (<undefined position>): Object invariant may not hold.
// 12978.1-12978.243: (<undefined position>): Object invariant may not hold.
// 12979.1-12979.243: (<undefined position>): Object invariant may not hold.
// 12990.1-12990.242: (<undefined position>): Object invariant may not hold.
// 12991.1-12991.242: (<undefined position>): Object invariant may not hold.
// 12992.1-12992.242: (<undefined position>): Object invariant may not hold.
// 12993.1-12993.242: (<undefined position>): Object invariant may not hold.
// 12994.1-12994.242: (<undefined position>): Object invariant may not hold.
// 12995.1-12995.242: (<undefined position>): Object invariant may not hold.
// 12996.1-12996.242: (<undefined position>): Object invariant may not hold.
// 13016.1-13040.2: (5.5): yields_as clause for Node.item is not valid
// 13045.1-13064.2: (5.5): yields_as clause for Node.item is not reflexive
// 13070.1-13070.243: (5.23): Object invariant may not hold.
// 13071.1-13071.243: (5.23): Object invariant may not hold.
// 13072.1-13072.243: (5.23): Object invariant may not hold.
// 13073.1-13073.243: (5.23): Object invariant may not hold.
// 13074.1-13074.243: (5.23): Object invariant may not hold.
// 13075.1-13075.243: (5.23): Object invariant may not hold.
// 13076.1-13076.243: (5.23): Object invariant may not hold.
// 13077.1-13115.2: (5.5): yields_as clause for Node.item is not transitive
// 13134.1-13158.2: (6.5): yields_as clause for Node.next is not valid
// 13163.1-13182.2: (6.5): yields_as clause for Node.next is not reflexive
// 13188.1-13188.243: (6.24): Object invariant may not hold.
// 13189.1-13189.243: (6.24): Object invariant may not hold.
// 13190.1-13190.243: (6.24): Object invariant may not hold.
// 13191.1-13191.243: (6.24): Object invariant may not hold.
// 13192.1-13192.243: (6.24): Object invariant may not hold.
// 13193.1-13193.243: (6.24): Object invariant may not hold.
// 13194.1-13194.243: (6.24): Object invariant may not hold.
// 13195.1-13233.2: (6.5): yields_as clause for Node.next is not transitive
// 13252.1-13276.2: (7.5): yields_as clause for Node.owner is not valid
// 13281.1-13300.2: (7.5): yields_as clause for Node.owner is not reflexive
// 13306.1-13306.243: (7.25): Object invariant may not hold.
// 13307.1-13307.243: (7.25): Object invariant may not hold.
// 13308.1-13308.243: (7.25): Object invariant may not hold.
// 13309.1-13309.243: (7.25): Object invariant may not hold.
// 13310.1-13310.243: (7.25): Object invariant may not hold.
// 13311.1-13311.243: (7.25): Object invariant may not hold.
// 13312.1-13312.243: (7.25): Object invariant may not hold.
// 13313.1-13351.2: (7.5): yields_as clause for Node.owner is not transitive
// 13371.1-13395.2: (7.32): yields_as clause for Node._lock is not valid
// 13400.1-13419.2: (7.32): yields_as clause for Node._lock is not reflexive
// 13425.1-13425.243: (4.1): Object invariant may not hold.
// 13426.1-13426.243: (4.1): Object invariant may not hold.
// 13427.1-13427.243: (4.1): Object invariant may not hold.
// 13428.1-13428.243: (4.1): Object invariant may not hold.
// 13429.1-13429.243: (4.1): Object invariant may not hold.
// 13430.1-13430.243: (4.1): Object invariant may not hold.
// 13431.1-13431.243: (4.1): Object invariant may not hold.
// 13432.1-13470.2: (7.32): yields_as clause for Node._lock is not transitive
// 13489.1-13513.2: (27.5): yields_as clause for List.head is not valid
// 13518.1-13537.2: (27.5): yields_as clause for List.head is not reflexive
// 13543.1-13543.243: (27.24): Object invariant may not hold.
// 13544.1-13544.243: (27.24): Object invariant may not hold.
// 13545.1-13545.243: (27.24): Object invariant may not hold.
// 13546.1-13546.243: (27.24): Object invariant may not hold.
// 13547.1-13547.243: (27.24): Object invariant may not hold.
// 13548.1-13548.243: (27.24): Object invariant may not hold.
// 13549.1-13549.243: (27.24): Object invariant may not hold.
// 13550.1-13588.2: (27.5): yields_as clause for List.head is not transitive
// 13608.1-13632.2: (7.32): yields_as clause for List._lock is not valid
// 13637.1-13656.2: (7.32): yields_as clause for List._lock is not reflexive
// 13662.1-13662.243: (25.1): Object invariant may not hold.
// 13663.1-13663.243: (25.1): Object invariant may not hold.
// 13664.1-13664.243: (25.1): Object invariant may not hold.
// 13665.1-13665.243: (25.1): Object invariant may not hold.
// 13666.1-13666.243: (25.1): Object invariant may not hold.
// 13667.1-13667.243: (25.1): Object invariant may not hold.
// 13668.1-13668.243: (25.1): Object invariant may not hold.
// 13669.1-13707.2: (7.32): yields_as clause for List._lock is not transitive
