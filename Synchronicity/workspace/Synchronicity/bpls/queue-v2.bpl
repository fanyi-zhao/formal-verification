                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/queue-v2.anchor:                        
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 2 ? B : N                                                                         
         : tid == 2 ? N : E                                                                         
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 1 ? B : N                                                                         
         : tid == 1 ? N : E                                                                         
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.head + this.elems.length;
      invariant  this.elems.length == 512;                                                          
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 1;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == old(this.spec) || this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));
      }                                                                                             
      public void enqueue(int x) {                                                                  
        bool tmp5;                                                                                  
        int tmp6;                                                                                   
        int tmp7;                                                                                   
        tmp7 := this.tail;                                                                          
        int tmp8;                                                                                   
        tmp8 := this.head;                                                                          
        tmp6 = tmp7 - tmp8;                                                                         
        int tmp9;                                                                                   
        [Queue.T{this}] tmp10;                                                                      
        tmp10 := this.elems;                                                                        
        tmp9 = tmp10.length;                                                                        
        tmp5 = tmp6 < tmp9;                                                                         
        if (tmp5 /* == this.tail - this.head < this.elems.length */) {                              
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          synchronized (this) {                                                                     
            assume this.tail - this.head < this.elems.length;                                       
            [Queue.T{this}] tmp11;                                                                  
            tmp11 := this.elems;                                                                    
            int tmp12;                                                                              
            int tmp13;                                                                              
            tmp13 := this.tail;                                                                     
            int tmp14;                                                                              
            [Queue.T{this}] tmp15;                                                                  
            tmp15 := this.elems;                                                                    
            tmp14 = tmp15.length;                                                                   
            tmp12 = tmp13 % tmp14;                                                                  
            tmp11[tmp12] := x;                                                                      
            Seq<int> tmp16;                                                                         
            Seq<int> tmp17;                                                                         
            tmp17 := this.spec;                                                                     
            Seq<int> tmp18;                                                                         
            tmp18 = SeqUnit<int>(x);                                                                
            tmp16 = SeqConcat<int>(tmp17,tmp18);                                                    
            this.spec := tmp16;                                                                     
            int tmp19;                                                                              
            int tmp20;                                                                              
            tmp20 := this.tail;                                                                     
            tmp19 = tmp20 + 1;                                                                      
            this.tail := tmp19;                                                                     
          }                                                                                         
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 2;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures $result == 0 && this.spec == old(this.spec) || $result == old(SeqNth<int>(this.spec,0)) && this.spec == SeqExtract<int>(old(this.spec),1,SeqLen<int>(old(this.spec)) - 1);
      }                                                                                             
      public int dequeue() {                                                                        
        bool tmp21;                                                                                 
        int tmp22;                                                                                  
        int tmp23;                                                                                  
        tmp23 := this.tail;                                                                         
        int tmp24;                                                                                  
        tmp24 := this.head;                                                                         
        tmp22 = tmp23 - tmp24;                                                                      
        tmp21 = tmp22 > 0;                                                                          
        if (tmp21 /* == this.tail - this.head > 0 */) {                                             
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          synchronized (this) {                                                                     
            assume this.tail - this.head > 0;                                                       
            int tmp25;                                                                              
            Seq<int> tmp26;                                                                         
            tmp26 := this.spec;                                                                     
            tmp25 = SeqNth<int>(tmp26,0);                                                           
            [Queue.T{this}] tmp27;                                                                  
            tmp27 := this.elems;                                                                    
            int tmp28;                                                                              
            int tmp29;                                                                              
            int tmp30;                                                                              
            tmp30 := this.head;                                                                     
            tmp29 = tmp30 + 0;                                                                      
            int tmp31;                                                                              
            [Queue.T{this}] tmp32;                                                                  
            tmp32 := this.elems;                                                                    
            tmp31 = tmp32.length;                                                                   
            tmp28 = tmp29 % tmp31;                                                                  
            int tmp33;                                                                              
            tmp33 := tmp27[tmp28];                                                                  
            assert tmp25 == tmp33;                                                                  
            int tmp34;                                                                              
            Seq<int> tmp35;                                                                         
            tmp35 := this.spec;                                                                     
            tmp34 = SeqNth<int>(tmp35,0);                                                           
            [Queue.T{this}] tmp36;                                                                  
            tmp36 := this.elems;                                                                    
            int tmp37;                                                                              
            int tmp38;                                                                              
            tmp38 := this.head;                                                                     
            int tmp39;                                                                              
            [Queue.T{this}] tmp40;                                                                  
            tmp40 := this.elems;                                                                    
            tmp39 = tmp40.length;                                                                   
            tmp37 = tmp38 % tmp39;                                                                  
            int tmp41;                                                                              
            tmp41 := tmp36[tmp37];                                                                  
            assert tmp34 == tmp41;                                                                  
            int result;                                                                             
            [Queue.T{this}] tmp42;                                                                  
            tmp42 := this.elems;                                                                    
            int tmp43;                                                                              
            int tmp44;                                                                              
            tmp44 := this.head;                                                                     
            int tmp45;                                                                              
            [Queue.T{this}] tmp46;                                                                  
            tmp46 := this.elems;                                                                    
            tmp45 = tmp46.length;                                                                   
            tmp43 = tmp44 % tmp45;                                                                  
            result := tmp42[tmp43];                                                                 
            assume forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
            Seq<int> tmp47;                                                                         
            Seq<int> tmp48;                                                                         
            tmp48 := this.spec;                                                                     
            int tmp49;                                                                              
            int tmp50;                                                                              
            Seq<int> tmp51;                                                                         
            tmp51 := this.spec;                                                                     
            tmp50 = SeqLen<int>(tmp51);                                                             
            tmp49 = tmp50 - 1;                                                                      
            tmp47 = SeqExtract<int>(tmp48,1,tmp49);                                                 
            this.spec := tmp47;                                                                     
            int tmp52;                                                                              
            int tmp53;                                                                              
            tmp53 := this.head;                                                                     
            tmp52 = tmp53 + 1;                                                                      
            this.head := tmp52;                                                                     
             return result;                                                                         
          }                                                                                         
        } else {                                                                                    
           return 0;                                                                                
        }                                                                                           
        // return -1;                                                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 2 ? B : N                                                                         
         : tid == 2 ? N : E                                                                         
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 1 ? B : N                                                                         
         : tid == 1 ? N : E                                                                         
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.head + this.elems.length;
      invariant  this.elems.length == 512;                                                          
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 1;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == old(this.spec) || this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));
      }                                                                                             
      public void enqueue(int x) {                                                                  
        bool tmp5;                                                                                  
        int tmp6;                                                                                   
        int tmp7;                                                                                   
        tmp7 := this.tail;                                                                          
        int tmp8;                                                                                   
        tmp8 := this.head;                                                                          
        tmp6 = tmp7 - tmp8;                                                                         
        int tmp9;                                                                                   
        [Queue.T{this}] tmp10;                                                                      
        tmp10 := this.elems;                                                                        
        tmp9 = tmp10.length;                                                                        
        tmp5 = tmp6 < tmp9;                                                                         
        if (tmp5 /* == this.tail - this.head < this.elems.length */) {                              
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          {                                                                                         
            acquire(this);                                                                          
            {                                                                                       
              assume this.tail - this.head < this.elems.length;                                     
              [Queue.T{this}] tmp11;                                                                
              tmp11 := this.elems;                                                                  
              int tmp12;                                                                            
              int tmp13;                                                                            
              tmp13 := this.tail;                                                                   
              int tmp14;                                                                            
              [Queue.T{this}] tmp15;                                                                
              tmp15 := this.elems;                                                                  
              tmp14 = tmp15.length;                                                                 
              tmp12 = tmp13 % tmp14;                                                                
              tmp11[tmp12] := x;                                                                    
              Seq<int> tmp16;                                                                       
              Seq<int> tmp17;                                                                       
              tmp17 := this.spec;                                                                   
              Seq<int> tmp18;                                                                       
              tmp18 = SeqUnit<int>(x);                                                              
              tmp16 = SeqConcat<int>(tmp17,tmp18);                                                  
              this.spec := tmp16;                                                                   
              int tmp19;                                                                            
              int tmp20;                                                                            
              tmp20 := this.tail;                                                                   
              tmp19 = tmp20 + 1;                                                                    
              this.tail := tmp19;                                                                   
            }                                                                                       
            release(this);                                                                          
          }                                                                                         
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 2;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures $result == 0 && this.spec == old(this.spec) || $result == old(SeqNth<int>(this.spec,0)) && this.spec == SeqExtract<int>(old(this.spec),1,SeqLen<int>(old(this.spec)) - 1);
      }                                                                                             
      public int dequeue() {                                                                        
        bool tmp21;                                                                                 
        int tmp22;                                                                                  
        int tmp23;                                                                                  
        tmp23 := this.tail;                                                                         
        int tmp24;                                                                                  
        tmp24 := this.head;                                                                         
        tmp22 = tmp23 - tmp24;                                                                      
        tmp21 = tmp22 > 0;                                                                          
        if (tmp21 /* == this.tail - this.head > 0 */) {                                             
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          {                                                                                         
            acquire(this);                                                                          
            {                                                                                       
              assume this.tail - this.head > 0;                                                     
              int tmp25;                                                                            
              Seq<int> tmp26;                                                                       
              tmp26 := this.spec;                                                                   
              tmp25 = SeqNth<int>(tmp26,0);                                                         
              [Queue.T{this}] tmp27;                                                                
              tmp27 := this.elems;                                                                  
              int tmp28;                                                                            
              int tmp29;                                                                            
              int tmp30;                                                                            
              tmp30 := this.head;                                                                   
              tmp29 = tmp30 + 0;                                                                    
              int tmp31;                                                                            
              [Queue.T{this}] tmp32;                                                                
              tmp32 := this.elems;                                                                  
              tmp31 = tmp32.length;                                                                 
              tmp28 = tmp29 % tmp31;                                                                
              int tmp33;                                                                            
              tmp33 := tmp27[tmp28];                                                                
              assert tmp25 == tmp33;                                                                
              int tmp34;                                                                            
              Seq<int> tmp35;                                                                       
              tmp35 := this.spec;                                                                   
              tmp34 = SeqNth<int>(tmp35,0);                                                         
              [Queue.T{this}] tmp36;                                                                
              tmp36 := this.elems;                                                                  
              int tmp37;                                                                            
              int tmp38;                                                                            
              tmp38 := this.head;                                                                   
              int tmp39;                                                                            
              [Queue.T{this}] tmp40;                                                                
              tmp40 := this.elems;                                                                  
              tmp39 = tmp40.length;                                                                 
              tmp37 = tmp38 % tmp39;                                                                
              int tmp41;                                                                            
              tmp41 := tmp36[tmp37];                                                                
              assert tmp34 == tmp41;                                                                
              int result;                                                                           
              [Queue.T{this}] tmp42;                                                                
              tmp42 := this.elems;                                                                  
              int tmp43;                                                                            
              int tmp44;                                                                            
              tmp44 := this.head;                                                                   
              int tmp45;                                                                            
              [Queue.T{this}] tmp46;                                                                
              tmp46 := this.elems;                                                                  
              tmp45 = tmp46.length;                                                                 
              tmp43 = tmp44 % tmp45;                                                                
              result := tmp42[tmp43];                                                               
              assume forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
              Seq<int> tmp47;                                                                       
              Seq<int> tmp48;                                                                       
              tmp48 := this.spec;                                                                   
              int tmp49;                                                                            
              int tmp50;                                                                            
              Seq<int> tmp51;                                                                       
              tmp51 := this.spec;                                                                   
              tmp50 = SeqLen<int>(tmp51);                                                           
              tmp49 = tmp50 - 1;                                                                    
              tmp47 = SeqExtract<int>(tmp48,1,tmp49);                                               
              this.spec := tmp47;                                                                   
              int tmp52;                                                                            
              int tmp53;                                                                            
              tmp53 := this.head;                                                                   
              tmp52 = tmp53 + 1;                                                                    
              this.head := tmp52;                                                                   
              {                                                                                     
                release(this);                                                                      
                 return result;                                                                     
              }                                                                                     
            }                                                                                       
            release(this);                                                                          
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return 0;                                                                              
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 2 ? B : N                                                                         
         : tid == 2 ? N : E                                                                         
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 1 ? B : N                                                                         
         : tid == 1 ? N : E                                                                         
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.head + this.elems.length;
      invariant  this.elems.length == 512;                                                          
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 1;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == old(this.spec) || this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));
      }                                                                                             
      public void enqueue(int x) {                                                                  
        bool tmp5;                                                                                  
        int tmp6;                                                                                   
        int tmp7;                                                                                   
        tmp7 := this.tail;                                                                          
        int tmp8;                                                                                   
        tmp8 := this.head;                                                                          
        tmp6 = tmp7 - tmp8;                                                                         
        int tmp9;                                                                                   
        [Queue.T{this}] tmp10;                                                                      
        tmp10 := this.elems;                                                                        
        tmp9 = tmp10.length;                                                                        
        tmp5 = tmp6 < tmp9;                                                                         
        if (tmp5 /* == this.tail - this.head < this.elems.length */) {                              
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          {                                                                                         
            acquire(this);                                                                          
            {                                                                                       
              assume this.tail - this.head < this.elems.length;                                     
              [Queue.T{this}] tmp11;                                                                
              tmp11 := this.elems;                                                                  
              int tmp12;                                                                            
              int tmp13;                                                                            
              tmp13 := this.tail;                                                                   
              int tmp14;                                                                            
              [Queue.T{this}] tmp15;                                                                
              tmp15 := this.elems;                                                                  
              tmp14 = tmp15.length;                                                                 
              tmp12 = tmp13 % tmp14;                                                                
              tmp11[tmp12] := x;                                                                    
              Seq<int> tmp16;                                                                       
              Seq<int> tmp17;                                                                       
              tmp17 := this.spec;                                                                   
              Seq<int> tmp18;                                                                       
              tmp18 = SeqUnit<int>(x);                                                              
              tmp16 = SeqConcat<int>(tmp17,tmp18);                                                  
              this.spec := tmp16;                                                                   
              int tmp19;                                                                            
              int tmp20;                                                                            
              tmp20 := this.tail;                                                                   
              tmp19 = tmp20 + 1;                                                                    
              this.tail := tmp19;                                                                   
            }                                                                                       
            release(this);                                                                          
          }                                                                                         
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 2;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures $result == 0 && this.spec == old(this.spec) || $result == old(SeqNth<int>(this.spec,0)) && this.spec == SeqExtract<int>(old(this.spec),1,SeqLen<int>(old(this.spec)) - 1);
      }                                                                                             
      public int dequeue() {                                                                        
        bool tmp21;                                                                                 
        int tmp22;                                                                                  
        int tmp23;                                                                                  
        tmp23 := this.tail;                                                                         
        int tmp24;                                                                                  
        tmp24 := this.head;                                                                         
        tmp22 = tmp23 - tmp24;                                                                      
        tmp21 = tmp22 > 0;                                                                          
        if (tmp21 /* == this.tail - this.head > 0 */) {                                             
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          {                                                                                         
            acquire(this);                                                                          
            {                                                                                       
              assume this.tail - this.head > 0;                                                     
              int tmp25;                                                                            
              Seq<int> tmp26;                                                                       
              tmp26 := this.spec;                                                                   
              tmp25 = SeqNth<int>(tmp26,0);                                                         
              [Queue.T{this}] tmp27;                                                                
              tmp27 := this.elems;                                                                  
              int tmp28;                                                                            
              int tmp29;                                                                            
              int tmp30;                                                                            
              tmp30 := this.head;                                                                   
              tmp29 = tmp30 + 0;                                                                    
              int tmp31;                                                                            
              [Queue.T{this}] tmp32;                                                                
              tmp32 := this.elems;                                                                  
              tmp31 = tmp32.length;                                                                 
              tmp28 = tmp29 % tmp31;                                                                
              int tmp33;                                                                            
              tmp33 := tmp27[tmp28];                                                                
              assert tmp25 == tmp33;                                                                
              int tmp34;                                                                            
              Seq<int> tmp35;                                                                       
              tmp35 := this.spec;                                                                   
              tmp34 = SeqNth<int>(tmp35,0);                                                         
              [Queue.T{this}] tmp36;                                                                
              tmp36 := this.elems;                                                                  
              int tmp37;                                                                            
              int tmp38;                                                                            
              tmp38 := this.head;                                                                   
              int tmp39;                                                                            
              [Queue.T{this}] tmp40;                                                                
              tmp40 := this.elems;                                                                  
              tmp39 = tmp40.length;                                                                 
              tmp37 = tmp38 % tmp39;                                                                
              int tmp41;                                                                            
              tmp41 := tmp36[tmp37];                                                                
              assert tmp34 == tmp41;                                                                
              int result;                                                                           
              [Queue.T{this}] tmp42;                                                                
              tmp42 := this.elems;                                                                  
              int tmp43;                                                                            
              int tmp44;                                                                            
              tmp44 := this.head;                                                                   
              int tmp45;                                                                            
              [Queue.T{this}] tmp46;                                                                
              tmp46 := this.elems;                                                                  
              tmp45 = tmp46.length;                                                                 
              tmp43 = tmp44 % tmp45;                                                                
              result := tmp42[tmp43];                                                               
              assume forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
              Seq<int> tmp47;                                                                       
              Seq<int> tmp48;                                                                       
              tmp48 := this.spec;                                                                   
              int tmp49;                                                                            
              int tmp50;                                                                            
              Seq<int> tmp51;                                                                       
              tmp51 := this.spec;                                                                   
              tmp50 = SeqLen<int>(tmp51);                                                           
              tmp49 = tmp50 - 1;                                                                    
              tmp47 = SeqExtract<int>(tmp48,1,tmp49);                                               
              this.spec := tmp47;                                                                   
              int tmp52;                                                                            
              int tmp53;                                                                            
              tmp53 := this.head;                                                                   
              tmp52 = tmp53 + 1;                                                                    
              this.head := tmp52;                                                                   
              {                                                                                     
                release(this);                                                                      
                 return result;                                                                     
              }                                                                                     
            }                                                                                       
            release(this);                                                                          
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return 0;                                                                              
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Queue {                                                                                   
      array T = int[isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E]                                                                  
                                                                                                    
       [Queue.T{this}] elems isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      volatile int head isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 2 ? B : N                                                                         
         : tid == 2 ? N : E                                                                         
                                                                                                    
      volatile int tail isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead                                                                                     
         ? tid == 1 ? B : N                                                                         
         : tid == 1 ? N : E                                                                         
                                                                                                    
      volatile Seq<int> spec isLocal(this, tid)                                                     
       ? isLocal(this, tid) ? B : E                                                                 
       : holds(this, tid) ? B : E                                                                   
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  0 <= this.head && this.head <= this.tail && this.tail <= this.head + this.elems.length;
      invariant  this.elems.length == 512;                                                          
      invariant  this.tail - this.head == SeqLen<int>(this.spec);                                   
      invariant  forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
                                                                                                    
      requires this.elems == [Queue.T{this}].null;                                                  
      {                                                                                             
        ensures this.spec == SeqEmpty<int>();                                                       
      }                                                                                             
      public void init() {                                                                          
        assume this.elems == [Queue.T{this}].null;                                                  
        assume this.head == 0;                                                                      
        assume this.tail == 0;                                                                      
        assume this.spec == SeqEmpty;                                                               
        {                                                                                           
          Seq<int> tmp1;                                                                            
          tmp1 = SeqEmpty<int>();                                                                   
          this.spec := tmp1;                                                                        
          int tmp2;                                                                                 
          tmp2 = 0;                                                                                 
          this.head := tmp2;                                                                        
          int tmp3;                                                                                 
          tmp3 = 0;                                                                                 
          this.tail := tmp3;                                                                        
          [Queue.T{this}] tmp4;                                                                     
          tmp4 = new [Queue.T{this}](512);                                                          
          this.elems := tmp4;                                                                       
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 1;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures this.spec == old(this.spec) || this.spec == SeqConcat<int>(old(this.spec),SeqUnit<int>(x));
      }                                                                                             
      public void enqueue(int x) {                                                                  
        bool tmp5;                                                                                  
        int tmp6;                                                                                   
        int tmp7;                                                                                   
        tmp7 := this.tail;                                                                          
        int tmp8;                                                                                   
        tmp8 := this.head;                                                                          
        tmp6 = tmp7 - tmp8;                                                                         
        int tmp9;                                                                                   
        [Queue.T{this}] tmp10;                                                                      
        tmp10 := this.elems;                                                                        
        tmp9 = tmp10.length;                                                                        
        tmp5 = tmp6 < tmp9;                                                                         
        if (tmp5 /* == this.tail - this.head < this.elems.length */) {                              
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          {                                                                                         
            acquire(this);                                                                          
            {                                                                                       
              assume this.tail - this.head < this.elems.length;                                     
              [Queue.T{this}] tmp11;                                                                
              tmp11 := this.elems;                                                                  
              int tmp12;                                                                            
              int tmp13;                                                                            
              tmp13 := this.tail;                                                                   
              int tmp14;                                                                            
              [Queue.T{this}] tmp15;                                                                
              tmp15 := this.elems;                                                                  
              tmp14 = tmp15.length;                                                                 
              tmp12 = tmp13 % tmp14;                                                                
              tmp11[tmp12] := x;                                                                    
              Seq<int> tmp16;                                                                       
              Seq<int> tmp17;                                                                       
              tmp17 := this.spec;                                                                   
              Seq<int> tmp18;                                                                       
              tmp18 = SeqUnit<int>(x);                                                              
              tmp16 = SeqConcat<int>(tmp17,tmp18);                                                  
              this.spec := tmp16;                                                                   
              int tmp19;                                                                            
              int tmp20;                                                                            
              tmp20 := this.tail;                                                                   
              tmp19 = tmp20 + 1;                                                                    
              this.tail := tmp19;                                                                   
            }                                                                                       
            release(this);                                                                          
          }                                                                                         
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires tid == 2;                                                                            
      {                                                                                             
        modifies this;                                                                              
        modifies this.elems;                                                                        
        modifies this.elems;                                                                        
        ensures $result == 0 && this.spec == old(this.spec) || $result == old(SeqNth<int>(this.spec,0)) && this.spec == SeqExtract<int>(old(this.spec),1,SeqLen<int>(old(this.spec)) - 1);
      }                                                                                             
      public int dequeue() {                                                                        
        bool tmp21;                                                                                 
        int tmp22;                                                                                  
        int tmp23;                                                                                  
        tmp23 := this.tail;                                                                         
        int tmp24;                                                                                  
        tmp24 := this.head;                                                                         
        tmp22 = tmp23 - tmp24;                                                                      
        tmp21 = tmp22 > 0;                                                                          
        if (tmp21 /* == this.tail - this.head > 0 */) {                                             
          yield;                                                                                    
          assume !(NextSpecStep(0));                                                                
          {                                                                                         
            acquire(this);                                                                          
            {                                                                                       
              assume this.tail - this.head > 0;                                                     
              int tmp25;                                                                            
              Seq<int> tmp26;                                                                       
              tmp26 := this.spec;                                                                   
              tmp25 = SeqNth<int>(tmp26,0);                                                         
              [Queue.T{this}] tmp27;                                                                
              tmp27 := this.elems;                                                                  
              int tmp28;                                                                            
              int tmp29;                                                                            
              int tmp30;                                                                            
              tmp30 := this.head;                                                                   
              tmp29 = tmp30 + 0;                                                                    
              int tmp31;                                                                            
              [Queue.T{this}] tmp32;                                                                
              tmp32 := this.elems;                                                                  
              tmp31 = tmp32.length;                                                                 
              tmp28 = tmp29 % tmp31;                                                                
              int tmp33;                                                                            
              tmp33 := tmp27[tmp28];                                                                
              assert tmp25 == tmp33;                                                                
              int tmp34;                                                                            
              Seq<int> tmp35;                                                                       
              tmp35 := this.spec;                                                                   
              tmp34 = SeqNth<int>(tmp35,0);                                                         
              [Queue.T{this}] tmp36;                                                                
              tmp36 := this.elems;                                                                  
              int tmp37;                                                                            
              int tmp38;                                                                            
              tmp38 := this.head;                                                                   
              int tmp39;                                                                            
              [Queue.T{this}] tmp40;                                                                
              tmp40 := this.elems;                                                                  
              tmp39 = tmp40.length;                                                                 
              tmp37 = tmp38 % tmp39;                                                                
              int tmp41;                                                                            
              tmp41 := tmp36[tmp37];                                                                
              assert tmp34 == tmp41;                                                                
              int result;                                                                           
              [Queue.T{this}] tmp42;                                                                
              tmp42 := this.elems;                                                                  
              int tmp43;                                                                            
              int tmp44;                                                                            
              tmp44 := this.head;                                                                   
              int tmp45;                                                                            
              [Queue.T{this}] tmp46;                                                                
              tmp46 := this.elems;                                                                  
              tmp45 = tmp46.length;                                                                 
              tmp43 = tmp44 % tmp45;                                                                
              result := tmp42[tmp43];                                                               
              assume forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
              Seq<int> tmp47;                                                                       
              Seq<int> tmp48;                                                                       
              tmp48 := this.spec;                                                                   
              int tmp49;                                                                            
              int tmp50;                                                                            
              Seq<int> tmp51;                                                                       
              tmp51 := this.spec;                                                                   
              tmp50 = SeqLen<int>(tmp51);                                                           
              tmp49 = tmp50 - 1;                                                                    
              tmp47 = SeqExtract<int>(tmp48,1,tmp49);                                               
              this.spec := tmp47;                                                                   
              int tmp52;                                                                            
              int tmp53;                                                                            
              tmp53 := this.head;                                                                   
              tmp52 = tmp53 + 1;                                                                    
              this.head := tmp52;                                                                   
              {                                                                                     
                release(this);                                                                      
                 return result;                                                                     
              }                                                                                     
            }                                                                                       
            release(this);                                                                          
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return 0;                                                                              
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return -1;                                                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Queue ***/                                                                          
                                                                                                    
type Queue;                                                                                         
const unique Queue.null: Queue;                                                                     
var Queue._state: [Queue]State;                                                                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.elems: [Queue]Array.Queue.T;                                                              
                                                                                                    
function {:inline} ReadEval.Queue.elems(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Array.Queue.T.null;                                                               
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.elems(tid: Tid,this : Queue,newValue: Array.Queue.T,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.head: [Queue]int;                                                                         
                                                                                                    
function {:inline} ReadEval.Queue.head(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   if ((tid==2)) then                                                                               
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if ((tid==2)) then                                                                               
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.head(tid: Tid,this : Queue,newValue: int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   if ((tid==2)) then                                                                               
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if ((tid==2)) then                                                                               
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.tail: [Queue]int;                                                                         
                                                                                                    
function {:inline} ReadEval.Queue.tail(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   if ((tid==1)) then                                                                               
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if ((tid==1)) then                                                                               
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.tail(tid: Tid,this : Queue,newValue: int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   if ((tid==1)) then                                                                               
    moverPath(_B, 6)                                                                                
   else                                                                                             
    moverPath(_N, 2)                                                                                
  else                                                                                              
   if ((tid==1)) then                                                                               
    moverPath(_N, 4)                                                                                
   else                                                                                             
    moverPath(_E, 0)                                                                                
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue.spec: [Queue]Seq.int;                                                                     
                                                                                                    
function {:inline} ReadEval.Queue.spec(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := SeqEmpty.int() : Seq.int;                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue.spec(tid: Tid,this : Queue,newValue: Seq.int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Queue._lock: [Queue]Tid;                                                                        
                                                                                                    
function {:inline} ReadEval.Queue._lock(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Queue._lock(tid: Tid,this : Queue,newValue: Tid,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Queue._lock[this]==tid)) then                                                               
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Queue._lock[this]==Tid.null)&&(newValue==tid))) then                                       
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Queue._lock[this]==tid)&&(newValue==Tid.null))) then                                      
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Queue.3923514(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
 (((0<=Queue.head[this])&&(Queue.head[this]<=Queue.tail[this]))&&(Queue.tail[this]<=(Queue.head[this]+Array.Queue.T._length[Queue.elems[this]])))
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Queue.3923522(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
 (Array.Queue.T._length[Queue.elems[this]]==512)                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Queue.3923535(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
 ((Queue.tail[this]-Queue.head[this])==SeqLen.int(Queue.spec[this]))                                
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Queue.3923577(tid: Tid,this : Queue,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
 (forall i: int ::  ((((0<=i)&&(i<(Queue.tail[this]-Queue.head[this])))==>(Array.Queue.T._elems[Queue.elems[this]][MOD((Queue.head[this]+i), Array.Queue.T._length[Queue.elems[this]])]==SeqNth.int(Queue.spec[this],i)))))
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Queue.init(tid:Tid, this : Queue)                                                        
modifies Queue._state;                                                                              
modifies Queue.elems;                                                                               
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue.spec;                                                                                
modifies Queue._lock;                                                                               
modifies Array.Queue.T._state;                                                                      
modifies Array.Queue.T._elems;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (31.5): Bad tid
requires isLocal(Queue._state[this], tid);                                                          
                                                                                                    
requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
requires (Queue.elems[this]==Array.Queue.T.null);                                                   
                                                                                                    
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && _this != this ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (31.5): Object invariant may not hold.
{                                                                                                   
 var Queue.spec3937356: [Queue]Seq.int;                                                             
 var Array.Queue.T._elems3937346: [Array.Queue.T]([int]int);                                        
 var tmp13937346: Seq.int;                                                                          
 var Queue.head3937356: [Queue]int;                                                                 
 var Queue.tail3937356: [Queue]int;                                                                 
 var Array.Queue.T._state3937369: [Array.Queue.T]State;                                             
 var Queue._lock3937356: [Queue]Tid;                                                                
 var Queue._lock3937346: [Queue]Tid;                                                                
 var Queue._lock3937369: [Queue]Tid;                                                                
 var Queue.spec3937370: [Queue]Seq.int;                                                             
 var _pc3937369: Phase;                                                                             
 var path3937369: int;                                                                              
 var tmp43937370: Array.Queue.T;                                                                    
 var moverPath3937356: MoverPath;                                                                   
 var Queue.head3937370: [Queue]int;                                                                 
 var Queue.spec3937336: [Queue]Seq.int;                                                             
 var tid3937370: Tid;                                                                               
 var mover3937346: Mover;                                                                           
 var tmp23937369: int;                                                                              
 var Queue._lock3937336: [Queue]Tid;                                                                
 var moverPath3937369: MoverPath;                                                                   
 var tmp33937369: int;                                                                              
 var Queue.spec3937346: [Queue]Seq.int;                                                             
 var moverPath3937346: MoverPath;                                                                   
 var Array.Queue.T._length3937356: [Array.Queue.T]int;                                              
 var tmp13937370: Seq.int;                                                                          
 var Array.Queue.T._elems3937369: [Array.Queue.T]([int]int);                                        
 var Queue.head3937336: [Queue]int;                                                                 
 var tmp33937356: int;                                                                              
 var Array.Queue.T._state3937370: [Array.Queue.T]State;                                             
 var Queue.tail3937346: [Queue]int;                                                                 
 var Array.Queue.T._elems3937336: [Array.Queue.T]([int]int);                                        
 var path3937346: int;                                                                              
 var this3937369: Queue;                                                                            
 var $recorded.state3937356: int;                                                                   
 var mover3937369: Mover;                                                                           
 var this3937336: Queue;                                                                            
 var Array.Queue.T._elems3937356: [Array.Queue.T]([int]int);                                        
 var _pc3937336: Phase;                                                                             
 var $recorded.state3937369: int;                                                                   
 var tmp43937369: Array.Queue.T;                                                                    
 var mover3937336: Mover;                                                                           
 var Queue.head3937369: [Queue]int;                                                                 
 var Array.Queue.T._state3937356: [Array.Queue.T]State;                                             
 var Queue.tail3937370: [Queue]int;                                                                 
 var Queue.elems3937346: [Queue]Array.Queue.T;                                                      
 var $recorded.state3937346: int;                                                                   
 var Queue._lock3937370: [Queue]Tid;                                                                
 var tid3937356: Tid;                                                                               
 var Queue.head3937346: [Queue]int;                                                                 
 var Queue.tail3937369: [Queue]int;                                                                 
 var Array.Queue.T._state3937336: [Array.Queue.T]State;                                             
 var moverPath3937336: MoverPath;                                                                   
 var this3937370: Queue;                                                                            
 var tmp13937369: Seq.int;                                                                          
 var Queue._state3937336: [Queue]State;                                                             
 var _pc3937370: Phase;                                                                             
 var Queue._state3937356: [Queue]State;                                                             
 var Queue.elems3937336: [Queue]Array.Queue.T;                                                      
 var this3937346: Queue;                                                                            
 var Array.Queue.T._length3937346: [Array.Queue.T]int;                                              
 var Queue._state3937369: [Queue]State;                                                             
 var path3937356: int;                                                                              
 var _pc3937346: Phase;                                                                             
 var tmp33937370: int;                                                                              
 var Queue.elems3937356: [Queue]Array.Queue.T;                                                      
 var this3937356: Queue;                                                                            
 var Array.Queue.T._state3937346: [Array.Queue.T]State;                                             
 var tmp23937370: int;                                                                              
 var Queue._state3937370: [Queue]State;                                                             
 var tmp4: Array.Queue.T;                                                                           
 var tid3937346: Tid;                                                                               
 var tmp23937346: int;                                                                              
 var tid3937369: Tid;                                                                               
 var Array.Queue.T._length3937336: [Array.Queue.T]int;                                              
 var tmp3: int;                                                                                     
 var Queue.spec3937369: [Queue]Seq.int;                                                             
 var mover3937356: Mover;                                                                           
 var tmp13937336: Seq.int;                                                                          
 var Array.Queue.T._elems3937370: [Array.Queue.T]([int]int);                                        
 var tmp23937356: int;                                                                              
 var _pc3937356: Phase;                                                                             
 var tmp1: Seq.int;                                                                                 
 var $recorded.state3937336: int;                                                                   
 var Array.Queue.T._length3937369: [Array.Queue.T]int;                                              
 var tid3937336: Tid;                                                                               
 var Queue.elems3937369: [Queue]Array.Queue.T;                                                      
 var $recorded.state3937370: int;                                                                   
 var tmp2: int;                                                                                     
 var Queue._state3937346: [Queue]State;                                                             
 var Queue.tail3937336: [Queue]int;                                                                 
 var path3937336: int;                                                                              
 var tmp13937356: Seq.int;                                                                          
 var Queue.elems3937370: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._length3937370: [Array.Queue.T]int;                                              
                                                                                                    
 var _pc : Phase;                                                                                   
 _pc := PreCommit;                                                                                  
                                                                                                    
 assert true && leq(m#moverPath(ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)),_R);       // (31.5): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 31.5: assume this.elems == [Queue.T{this}].null;                                                
                                                                                                    
 assume (Queue.elems[this]==Array.Queue.T.null);                                                    
                                                                                                    
 // 31.5: assume this.head == 0;                                                                    
                                                                                                    
 assume (Queue.head[this]==0);                                                                      
                                                                                                    
 // 31.5: assume this.tail == 0;                                                                    
                                                                                                    
 assume (Queue.tail[this]==0);                                                                      
                                                                                                    
 // 31.5: assume this.spec == SeqEmpty;                                                             
                                                                                                    
 assume (Queue.spec[this]==SeqEmpty.int() : Seq.int);                                               
                                                                                                    
 // 33.9: Seq<int> tmp1;                                                                            
                                                                                                    
                                                                                                    
 // 33.9: tmp1 = SeqEmpty<int>();                                                                   
                                                                                                    
 tmp1 := SeqEmpty.int();                                                                            
                                                                                                    
                                                                                                    
 // 33.9: this.spec := tmp1;                                                                        
                                                                                                    
                                                                                                    
 moverPath3937336 := WriteEval.Queue.spec(tid: Tid,this: Queue,tmp1: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937336 := m#moverPath(moverPath3937336);                                                     
 path3937336 := p#moverPath(moverPath3937336);                                                      
 assume Queue._state3937336 == Queue._state && Queue.elems3937336 == Queue.elems && Queue.head3937336 == Queue.head && Queue.tail3937336 == Queue.tail && Queue.spec3937336 == Queue.spec && Queue._lock3937336 == Queue._lock && Array.Queue.T._state3937336 == Array.Queue.T._state && Array.Queue.T._elems3937336 == Array.Queue.T._elems && Array.Queue.T._length3937336 == Array.Queue.T._length && tmp13937336 == tmp1 && this3937336 == this && tid3937336 == tid && _pc3937336 == _pc;
 assume $recorded.state3937336 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (33.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3937336);                                                              
 assert _pc != PhaseError;                                                                                 // (33.9): Reduction failure
 Queue.spec[this] := tmp1;                                                                          
                                                                                                    
 // 34.9: int tmp2;                                                                                 
                                                                                                    
                                                                                                    
 // 34.9: tmp2 = 0;                                                                                 
                                                                                                    
 tmp2 := 0;                                                                                         
                                                                                                    
                                                                                                    
 // 34.9: this.head := tmp2;                                                                        
                                                                                                    
                                                                                                    
 moverPath3937346 := WriteEval.Queue.head(tid: Tid,this: Queue,tmp2: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937346 := m#moverPath(moverPath3937346);                                                     
 path3937346 := p#moverPath(moverPath3937346);                                                      
 assume Queue._state3937346 == Queue._state && Queue.elems3937346 == Queue.elems && Queue.head3937346 == Queue.head && Queue.tail3937346 == Queue.tail && Queue.spec3937346 == Queue.spec && Queue._lock3937346 == Queue._lock && Array.Queue.T._state3937346 == Array.Queue.T._state && Array.Queue.T._elems3937346 == Array.Queue.T._elems && Array.Queue.T._length3937346 == Array.Queue.T._length && tmp23937346 == tmp2 && tmp13937346 == tmp1 && this3937346 == this && tid3937346 == tid && _pc3937346 == _pc;
 assume $recorded.state3937346 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (34.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3937346);                                                              
 assert _pc != PhaseError;                                                                                 // (34.9): Reduction failure
 Queue.head[this] := tmp2;                                                                          
                                                                                                    
 // 35.9: int tmp3;                                                                                 
                                                                                                    
                                                                                                    
 // 35.9: tmp3 = 0;                                                                                 
                                                                                                    
 tmp3 := 0;                                                                                         
                                                                                                    
                                                                                                    
 // 35.9: this.tail := tmp3;                                                                        
                                                                                                    
                                                                                                    
 moverPath3937356 := WriteEval.Queue.tail(tid: Tid,this: Queue,tmp3: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937356 := m#moverPath(moverPath3937356);                                                     
 path3937356 := p#moverPath(moverPath3937356);                                                      
 assume Queue._state3937356 == Queue._state && Queue.elems3937356 == Queue.elems && Queue.head3937356 == Queue.head && Queue.tail3937356 == Queue.tail && Queue.spec3937356 == Queue.spec && Queue._lock3937356 == Queue._lock && Array.Queue.T._state3937356 == Array.Queue.T._state && Array.Queue.T._elems3937356 == Array.Queue.T._elems && Array.Queue.T._length3937356 == Array.Queue.T._length && tmp33937356 == tmp3 && tmp23937356 == tmp2 && tmp13937356 == tmp1 && this3937356 == this && tid3937356 == tid && _pc3937356 == _pc;
 assume $recorded.state3937356 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (35.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3937356);                                                              
 assert _pc != PhaseError;                                                                                 // (35.9): Reduction failure
 Queue.tail[this] := tmp3;                                                                          
                                                                                                    
 // 36.9: [Queue.T{this}] tmp4;                                                                     
                                                                                                    
                                                                                                    
 // 36.9: tmp4 = new [Queue.T{this}](512);                                                          
                                                                                                    
 havoc tmp4;                                                                                        
 assume isFresh(Array.Queue.T._state[tmp4]);                                                        
 assume Array.Queue.T._length[tmp4] == 512;                                                         
 assume Array.Queue.T._this[tmp4] == this;                                                          
 Array.Queue.T._state[tmp4] := LOCAL(tid);                                                          
 assume (forall _i : int :: 0 <= _i ==> Array.Queue.T._elems[tmp4][_i] == 0);                       
                                                                                                    
                                                                                                    
 // 36.9: this.elems := tmp4;                                                                       
                                                                                                    
                                                                                                    
 moverPath3937369 := WriteEval.Queue.elems(tid: Tid,this: Queue,tmp4: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937369 := m#moverPath(moverPath3937369);                                                     
 path3937369 := p#moverPath(moverPath3937369);                                                      
 assume Queue._state3937369 == Queue._state && Queue.elems3937369 == Queue.elems && Queue.head3937369 == Queue.head && Queue.tail3937369 == Queue.tail && Queue.spec3937369 == Queue.spec && Queue._lock3937369 == Queue._lock && Array.Queue.T._state3937369 == Array.Queue.T._state && Array.Queue.T._elems3937369 == Array.Queue.T._elems && Array.Queue.T._length3937369 == Array.Queue.T._length && tmp43937369 == tmp4 && tmp33937369 == tmp3 && tmp23937369 == tmp2 && tmp13937369 == tmp1 && this3937369 == this && tid3937369 == tid && _pc3937369 == _pc;
 assume $recorded.state3937369 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (36.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 _pc := transition(_pc, mover3937369);                                                              
 assert _pc != PhaseError;                                                                                 // (36.9): Reduction failure
 Queue.elems[this] := tmp4;                                                                         
 if (isLocal(Array.Queue.T._state[tmp4], tid)) {                                                    
  Array.Queue.T._state[tmp4] := SHARED();                                                           
  if (isLocal(Queue._state[Array.Queue.T._this[tmp4]], tid)) {                                      
   Queue._state[Array.Queue.T._this[tmp4]] := SHARED();                                             
   assert isSharedAssignable(Array.Queue.T._state[Queue.elems[Array.Queue.T._this[tmp4]]]);                // (36.9): tmp4 became shared, but Array.Queue.T._this[tmp4].elems may not be shared.
  }                                                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 // 32.21: // return;                                                                               
                                                                                                    
 assume Queue._state3937370 == Queue._state && Queue.elems3937370 == Queue.elems && Queue.head3937370 == Queue.head && Queue.tail3937370 == Queue.tail && Queue.spec3937370 == Queue.spec && Queue._lock3937370 == Queue._lock && Array.Queue.T._state3937370 == Array.Queue.T._state && Array.Queue.T._elems3937370 == Array.Queue.T._elems && Array.Queue.T._length3937370 == Array.Queue.T._length && tmp43937370 == tmp4 && tmp33937370 == tmp3 && tmp23937370 == tmp2 && tmp13937370 == tmp1 && this3937370 == this && tid3937370 == tid;
 assume $recorded.state3937370 == 1;                                                                
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (32.21): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (32.21): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (32.21): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (32.21): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Queue.enqueue(tid:Tid, this : Queue, x : int)                                            
modifies Queue._state;                                                                              
modifies Queue.elems;                                                                               
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue.spec;                                                                                
modifies Queue._lock;                                                                               
modifies Array.Queue.T._state;                                                                      
modifies Array.Queue.T._elems;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (39.5): Bad tid
requires isShared(Queue._state[this]);                                                                     // (39.5): this is not global
                                                                                                    
requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
requires (tid==1);                                                                                  
                                                                                                    
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (39.5): Object invariant may not hold.
{                                                                                                   
 var tmp63937386: int;                                                                              
 var $recorded.state3937392: int;                                                                   
 var Queue._state3937477: [Queue]State;                                                             
 var Array.Queue.T._length3937515: [Array.Queue.T]int;                                              
 var tmp153937488: Array.Queue.T;                                                                   
 var tmp203937515: int;                                                                             
 var $recorded.state3937477: int;                                                                   
 var mover3937477: Mover;                                                                           
 var Queue.head3937488: [Queue]int;                                                                 
 var Queue._lock3937444: [Queue]Tid;                                                                
 var tmp103937419_post: Array.Queue.T;                                                              
 var path3937506: int;                                                                              
 var x3937444: int;                                                                                 
 var tmp123937463: int;                                                                             
 var _pc3937419_post: Phase;                                                                        
 var tid3937515: Tid;                                                                               
 var $recorded.state3937488: int;                                                                   
 var _pc3937525: Phase;                                                                             
 var tmp93937419_post: int;                                                                         
 var tmp63937444: int;                                                                              
 var tmp53937392: bool;                                                                             
 var tmp53937386: bool;                                                                             
 var tmp113937453: Array.Queue.T;                                                                   
 var tmp83937463: int;                                                                              
 var tid3937463: Tid;                                                                               
 var tmp63937419_post: int;                                                                         
 var tmp10: Array.Queue.T;                                                                          
 var Queue._state3937463: [Queue]State;                                                             
 var moverPath3937444: MoverPath;                                                                   
 var tmp123937453: int;                                                                             
 var mover3937408: Mover;                                                                           
 var Array.Queue.T._state3937463: [Array.Queue.T]State;                                             
 var tmp143937463: int;                                                                             
 var Array.Queue.T._elems3937525: [Array.Queue.T]([int]int);                                        
 var Queue.spec3937525: [Queue]Seq.int;                                                             
 var Array.Queue.T._length3937419_post: [Array.Queue.T]int;                                         
 var moverPath3937453: MoverPath;                                                                   
 var tid3937408: Tid;                                                                               
 var Queue._lock3937488: [Queue]Tid;                                                                
 var tmp5: bool;                                                                                    
 var tmp63937408: int;                                                                              
 var mover3937392: Mover;                                                                           
 var Array.Queue.T._state3937525: [Array.Queue.T]State;                                             
 var tmp143937506: int;                                                                             
 var tmp163937515: Seq.int;                                                                         
 var x3937515: int;                                                                                 
 var tmp113937515: Array.Queue.T;                                                                   
 var tmp73937408: int;                                                                              
 var tmp133937463: int;                                                                             
 var mover3937506: Mover;                                                                           
 var Array.Queue.T._state3937408: [Array.Queue.T]State;                                             
 var tmp103937444: Array.Queue.T;                                                                   
 var tmp183937506: Seq.int;                                                                         
 var tmp53937419_post: bool;                                                                        
 var Queue.spec3937419_post: [Queue]Seq.int;                                                        
 var tmp83937533: int;                                                                              
 var tmp63937463: int;                                                                              
 var tmp73937525: int;                                                                              
 var _pc3937444: Phase;                                                                             
 var Queue.tail3937463: [Queue]int;                                                                 
 var tmp53937515: bool;                                                                             
 var moverPath3937386: MoverPath;                                                                   
 var _pc3937386: Phase;                                                                             
 var x3937419: int;                                                                                 
 var tmp83937453: int;                                                                              
 var _pc3937392: Phase;                                                                             
 var tmp93937506: int;                                                                              
 var tmp73937419: int;                                                                              
 var tmp16: Seq.int;                                                                                
 var tmp8: int;                                                                                     
 var tmp73937477: int;                                                                              
 var x3937419_post: int;                                                                            
 var _pc3937408: Phase;                                                                             
 var tmp123937488: int;                                                                             
 var Queue.spec3937408: [Queue]Seq.int;                                                             
 var tmp143937488: int;                                                                             
 var tmp11: Array.Queue.T;                                                                          
 var tmp153937463: Array.Queue.T;                                                                   
 var Queue.elems3937488: [Queue]Array.Queue.T;                                                      
 var tmp73937463: int;                                                                              
 var tmp193937525: int;                                                                             
 var x3937488: int;                                                                                 
 var Queue._lock3937477: [Queue]Tid;                                                                
 var path3937477: int;                                                                              
 var tmp15: Array.Queue.T;                                                                          
 var Queue.elems3937419: [Queue]Array.Queue.T;                                                      
 var Queue._lock3937515: [Queue]Tid;                                                                
 var _pc3937533: Phase;                                                                             
 var Queue.spec3937477: [Queue]Seq.int;                                                             
 var tmp73937533: int;                                                                              
 var mover3937515: Mover;                                                                           
 var Queue._lock3937419_post: [Queue]Tid;                                                           
 var path3937515: int;                                                                              
 var Queue.head3937419_post: [Queue]int;                                                            
 var Array.Queue.T._elems3937463: [Array.Queue.T]([int]int);                                        
 var tmp53937444: bool;                                                                             
 var this3937386: Queue;                                                                            
 var Array.Queue.T._elems3937386: [Array.Queue.T]([int]int);                                        
 var mover3937488: Mover;                                                                           
 var tmp93937444: int;                                                                              
 var Queue._lock3937506: [Queue]Tid;                                                                
 var this3937477: Queue;                                                                            
 var tmp123937477: int;                                                                             
 var tid3937488: Tid;                                                                               
 var tmp103937408: Array.Queue.T;                                                                   
 var tmp103937463: Array.Queue.T;                                                                   
 var Queue.elems3937515: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._elems3937419: [Array.Queue.T]([int]int);                                        
 var tmp53937453: bool;                                                                             
 var $recorded.state3937506: int;                                                                   
 var Queue.head3937477: [Queue]int;                                                                 
 var Queue.spec3937463: [Queue]Seq.int;                                                             
 var x3937408: int;                                                                                 
 var tmp53937463: bool;                                                                             
 var tmp53937525: bool;                                                                             
 var this3937488: Queue;                                                                            
 var tmp9: int;                                                                                     
 var Array.Queue.T._elems3937444: [Array.Queue.T]([int]int);                                        
 var Queue.elems3937419_post: [Queue]Array.Queue.T;                                                 
 var tmp143937525: int;                                                                             
 var tmp53937506: bool;                                                                             
 var tmp93937477: int;                                                                              
 var Queue._state3937408: [Queue]State;                                                             
 var tmp14: int;                                                                                    
 var x3937453: int;                                                                                 
 var this3937506: Queue;                                                                            
 var moverPath3937525: MoverPath;                                                                   
 var tmp153937515: Array.Queue.T;                                                                   
 var tmp73937506: int;                                                                              
 var moverPath3937392: MoverPath;                                                                   
 var Array.Queue.T._elems3937506: [Array.Queue.T]([int]int);                                        
 var path3937453: int;                                                                              
 var tmp173937525: Seq.int;                                                                         
 var Array.Queue.T._state3937419: [Array.Queue.T]State;                                             
 var tid3937506: Tid;                                                                               
 var Queue._state3937515: [Queue]State;                                                             
 var tmp183937515: Seq.int;                                                                         
 var _pc3937453: Phase;                                                                             
 var path3937392: int;                                                                              
 var Queue.head3937533: [Queue]int;                                                                 
 var tmp153937525: Array.Queue.T;                                                                   
 var tmp123937506: int;                                                                             
 var tmp173937488: Seq.int;                                                                         
 var Array.Queue.T._length3937386: [Array.Queue.T]int;                                              
 var Queue.tail3937419: [Queue]int;                                                                 
 var tmp63937506: int;                                                                              
 var tmp53937408: bool;                                                                             
 var Array.Queue.T._state3937515: [Array.Queue.T]State;                                             
 var tmp93937533: int;                                                                              
 var this3937453: Queue;                                                                            
 var tmp17: Seq.int;                                                                                
 var tmp73937419_post: int;                                                                         
 var Queue.head3937463: [Queue]int;                                                                 
 var tid3937525: Tid;                                                                               
 var Queue.elems3937506: [Queue]Array.Queue.T;                                                      
 var Queue.elems3937453: [Queue]Array.Queue.T;                                                      
 var tmp83937419_post: int;                                                                         
 var mover3937525: Mover;                                                                           
 var tmp93937419: int;                                                                              
 var Queue.elems3937392: [Queue]Array.Queue.T;                                                      
 var tmp173937515: Seq.int;                                                                         
 var mover3937386: Mover;                                                                           
 var tmp163937525: Seq.int;                                                                         
 var tmp93937463: int;                                                                              
 var x3937386: int;                                                                                 
 var moverPath3937463: MoverPath;                                                                   
 var tmp193937515: int;                                                                             
 var Array.Queue.T._state3937444: [Array.Queue.T]State;                                             
 var tid3937386: Tid;                                                                               
 var x3937533: int;                                                                                 
 var tmp103937533: Array.Queue.T;                                                                   
 var $recorded.state3937444: int;                                                                   
 var tmp153937506: Array.Queue.T;                                                                   
 var x3937525: int;                                                                                 
 var Queue.tail3937506: [Queue]int;                                                                 
 var tmp53937488: bool;                                                                             
 var tmp93937525: int;                                                                              
 var mover3937444: Mover;                                                                           
 var tmp103937488: Array.Queue.T;                                                                   
 var tid3937419_post: Tid;                                                                          
 var this3937419_post: Queue;                                                                       
 var tmp123937515: int;                                                                             
 var tmp153937477: Array.Queue.T;                                                                   
 var Queue._state3937453: [Queue]State;                                                             
 var Queue.elems3937386: [Queue]Array.Queue.T;                                                      
 var path3937408: int;                                                                              
 var Array.Queue.T._length3937506: [Array.Queue.T]int;                                              
 var _pc3937477: Phase;                                                                             
 var Array.Queue.T._length3937392: [Array.Queue.T]int;                                              
 var Array.Queue.T._length3937477: [Array.Queue.T]int;                                              
 var path3937463: int;                                                                              
 var _pc3937463: Phase;                                                                             
 var $recorded.state3937419: int;                                                                   
 var Queue.elems3937444: [Queue]Array.Queue.T;                                                      
 var Queue._state3937444: [Queue]State;                                                             
 var tmp93937488: int;                                                                              
 var Queue._lock3937463: [Queue]Tid;                                                                
 var _pc3937488: Phase;                                                                             
 var path3937386: int;                                                                              
 var Queue._lock3937408: [Queue]Tid;                                                                
 var tmp103937515: Array.Queue.T;                                                                   
 var Array.Queue.T._state3937392: [Array.Queue.T]State;                                             
 var Array.Queue.T._state3937506: [Array.Queue.T]State;                                             
 var tmp133937477: int;                                                                             
 var tmp133937525: int;                                                                             
 var Queue.spec3937392: [Queue]Seq.int;                                                             
 var tmp63937525: int;                                                                              
 var tmp113937488: Array.Queue.T;                                                                   
 var Queue.head3937506: [Queue]int;                                                                 
 var Queue.elems3937463: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._length3937419: [Array.Queue.T]int;                                              
 var tmp113937506: Array.Queue.T;                                                                   
 var tmp63937419: int;                                                                              
 var tmp73937386: int;                                                                              
 var tmp93937515: int;                                                                              
 var x3937477: int;                                                                                 
 var Queue.spec3937515: [Queue]Seq.int;                                                             
 var tmp63937477: int;                                                                              
 var tmp173937506: Seq.int;                                                                         
 var $recorded.state3937386: int;                                                                   
 var tmp83937408: int;                                                                              
 var tmp123937525: int;                                                                             
 var Queue.spec3937386: [Queue]Seq.int;                                                             
 var Queue.head3937386: [Queue]int;                                                                 
 var tmp18: Seq.int;                                                                                
 var Array.Queue.T._length3937525: [Array.Queue.T]int;                                              
 var tmp73937453: int;                                                                              
 var Queue.head3937515: [Queue]int;                                                                 
 var Queue.elems3937525: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._elems3937488: [Array.Queue.T]([int]int);                                        
 var tmp13: int;                                                                                    
 var _pc3937515: Phase;                                                                             
 var $recorded.state3937463: int;                                                                   
 var Queue.elems3937533: [Queue]Array.Queue.T;                                                      
 var x3937463: int;                                                                                 
 var tmp103937477: Array.Queue.T;                                                                   
 var tid3937419: Tid;                                                                               
 var tmp113937463: Array.Queue.T;                                                                   
 var this3937444: Queue;                                                                            
 var $recorded.state3937419_post: int;                                                              
 var Queue._state3937488: [Queue]State;                                                             
 var mover3937463: Mover;                                                                           
 var Queue.spec3937453: [Queue]Seq.int;                                                             
 var Queue._state3937506: [Queue]State;                                                             
 var tmp19: int;                                                                                    
 var tmp73937515: int;                                                                              
 var tid3937533: Tid;                                                                               
 var tmp73937488: int;                                                                              
 var x3937506: int;                                                                                 
 var tmp133937515: int;                                                                             
 var tid3937477: Tid;                                                                               
 var Array.Queue.T._state3937419_post: [Array.Queue.T]State;                                        
 var Queue.elems3937408: [Queue]Array.Queue.T;                                                      
 var tmp103937525: Array.Queue.T;                                                                   
 var this3937515: Queue;                                                                            
 var tmp183937525: Seq.int;                                                                         
 var tmp73937392: int;                                                                              
 var tmp93937408: int;                                                                              
 var Queue.spec3937533: [Queue]Seq.int;                                                             
 var tmp113937477: Array.Queue.T;                                                                   
 var Queue._lock3937533: [Queue]Tid;                                                                
 var Queue._lock3937525: [Queue]Tid;                                                                
 var Queue.tail3937515: [Queue]int;                                                                 
 var Queue._lock3937453: [Queue]Tid;                                                                
 var this3937533: Queue;                                                                            
 var Array.Queue.T._elems3937477: [Array.Queue.T]([int]int);                                        
 var tmp83937392: int;                                                                              
 var tmp12: int;                                                                                    
 var tmp143937515: int;                                                                             
 var this3937408: Queue;                                                                            
 var tmp103937419: Array.Queue.T;                                                                   
 var $recorded.state3937525: int;                                                                   
 var $recorded.state3937515: int;                                                                   
 var Queue._state3937533: [Queue]State;                                                             
 var moverPath3937477: MoverPath;                                                                   
 var tid3937392: Tid;                                                                               
 var Queue.head3937453: [Queue]int;                                                                 
 var Array.Queue.T._elems3937515: [Array.Queue.T]([int]int);                                        
 var tmp93937453: int;                                                                              
 var Array.Queue.T._elems3937419_post: [Array.Queue.T]([int]int);                                   
 var x3937392: int;                                                                                 
 var Queue.tail3937533: [Queue]int;                                                                 
 var Array.Queue.T._length3937463: [Array.Queue.T]int;                                              
 var Queue._lock3937386: [Queue]Tid;                                                                
 var tmp83937506: int;                                                                              
 var tmp113937525: Array.Queue.T;                                                                   
 var tmp83937444: int;                                                                              
 var moverPath3937506: MoverPath;                                                                   
 var Queue.tail3937477: [Queue]int;                                                                 
 var tmp73937444: int;                                                                              
 var Array.Queue.T._elems3937453: [Array.Queue.T]([int]int);                                        
 var tmp7: int;                                                                                     
 var Array.Queue.T._length3937408: [Array.Queue.T]int;                                              
 var tmp63937453: int;                                                                              
 var Array.Queue.T._state3937386: [Array.Queue.T]State;                                             
 var tmp20: int;                                                                                    
 var path3937488: int;                                                                              
 var tmp103937506: Array.Queue.T;                                                                   
 var Queue.head3937525: [Queue]int;                                                                 
 var Queue.tail3937453: [Queue]int;                                                                 
 var tmp53937419: bool;                                                                             
 var Queue.head3937408: [Queue]int;                                                                 
 var tmp63937515: int;                                                                              
 var this3937463: Queue;                                                                            
 var Queue.tail3937444: [Queue]int;                                                                 
 var Array.Queue.T._length3937488: [Array.Queue.T]int;                                              
 var Queue.spec3937419: [Queue]Seq.int;                                                             
 var Queue.spec3937488: [Queue]Seq.int;                                                             
 var Array.Queue.T._length3937453: [Array.Queue.T]int;                                              
 var Array.Queue.T._length3937444: [Array.Queue.T]int;                                              
 var Array.Queue.T._length3937533: [Array.Queue.T]int;                                              
 var tmp163937506: Seq.int;                                                                         
 var tid3937453: Tid;                                                                               
 var Queue._state3937386: [Queue]State;                                                             
 var Queue.spec3937506: [Queue]Seq.int;                                                             
 var tmp133937506: int;                                                                             
 var Array.Queue.T._state3937488: [Array.Queue.T]State;                                             
 var tmp63937533: int;                                                                              
 var tmp83937525: int;                                                                              
 var tmp143937477: int;                                                                             
 var Queue.tail3937408: [Queue]int;                                                                 
 var mover3937453: Mover;                                                                           
 var Queue._lock3937419: [Queue]Tid;                                                                
 var path3937525: int;                                                                              
 var Queue.tail3937488: [Queue]int;                                                                 
 var tmp83937419: int;                                                                              
 var moverPath3937488: MoverPath;                                                                   
 var this3937392: Queue;                                                                            
 var tmp163937488: Seq.int;                                                                         
 var Queue.tail3937392: [Queue]int;                                                                 
 var Queue.head3937444: [Queue]int;                                                                 
 var tmp63937392: int;                                                                              
 var $recorded.state3937533: int;                                                                   
 var this3937419: Queue;                                                                            
 var Queue.tail3937386: [Queue]int;                                                                 
 var Array.Queue.T._state3937533: [Array.Queue.T]State;                                             
 var tmp203937525: int;                                                                             
 var tmp113937444: Array.Queue.T;                                                                   
 var Queue._state3937525: [Queue]State;                                                             
 var Queue._lock3937392: [Queue]Tid;                                                                
 var tmp133937488: int;                                                                             
 var path3937444: int;                                                                              
 var moverPath3937408: MoverPath;                                                                   
 var Queue.head3937392: [Queue]int;                                                                 
 var Queue._state3937392: [Queue]State;                                                             
 var Array.Queue.T._elems3937533: [Array.Queue.T]([int]int);                                        
 var Array.Queue.T._elems3937408: [Array.Queue.T]([int]int);                                        
 var tmp83937477: int;                                                                              
 var Array.Queue.T._elems3937392: [Array.Queue.T]([int]int);                                        
 var Queue.elems3937477: [Queue]Array.Queue.T;                                                      
 var tid3937444: Tid;                                                                               
 var tmp83937515: int;                                                                              
 var Array.Queue.T._state3937453: [Array.Queue.T]State;                                             
 var tmp133937453: int;                                                                             
 var _pc3937506: Phase;                                                                             
 var tmp63937488: int;                                                                              
 var Queue.tail3937419_post: [Queue]int;                                                            
 var Queue._state3937419: [Queue]State;                                                             
 var tmp83937488: int;                                                                              
 var Queue._state3937419_post: [Queue]State;                                                        
 var tmp53937533: bool;                                                                             
 var tmp6: int;                                                                                     
 var Queue.spec3937444: [Queue]Seq.int;                                                             
 var $recorded.state3937408: int;                                                                   
 var Queue.head3937419: [Queue]int;                                                                 
 var _pc3937419: Phase;                                                                             
 var $recorded.state3937453: int;                                                                   
 var tmp103937453: Array.Queue.T;                                                                   
 var tmp53937477: bool;                                                                             
 var Queue.tail3937525: [Queue]int;                                                                 
 var this3937525: Queue;                                                                            
 var Array.Queue.T._state3937477: [Array.Queue.T]State;                                             
 var moverPath3937515: MoverPath;                                                                   
                                                                                                    
 var _pc : Phase;                                                                                   
 _pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (39.18): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 43.9: bool tmp5;                                                                                
                                                                                                    
                                                                                                    
 // 43.9: int tmp6;                                                                                 
                                                                                                    
                                                                                                    
 // 43.9: int tmp7;                                                                                 
                                                                                                    
                                                                                                    
 // 43.9: tmp7 := this.tail;                                                                        
                                                                                                    
                                                                                                    
 moverPath3937386 := ReadEval.Queue.tail(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937386 := m#moverPath(moverPath3937386);                                                     
 path3937386 := p#moverPath(moverPath3937386);                                                      
 assume Queue._state3937386 == Queue._state && Queue.elems3937386 == Queue.elems && Queue.head3937386 == Queue.head && Queue.tail3937386 == Queue.tail && Queue.spec3937386 == Queue.spec && Queue._lock3937386 == Queue._lock && Array.Queue.T._state3937386 == Array.Queue.T._state && Array.Queue.T._elems3937386 == Array.Queue.T._elems && Array.Queue.T._length3937386 == Array.Queue.T._length && tmp73937386 == tmp7 && tmp63937386 == tmp6 && tmp53937386 == tmp5 && x3937386 == x && this3937386 == this && tid3937386 == tid && _pc3937386 == _pc;
 assume $recorded.state3937386 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (43.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 _pc := transition(_pc, mover3937386);                                                              
 assert _pc != PhaseError;                                                                                 // (43.9): Reduction failure
 tmp7 := Queue.tail[this];                                                                          
                                                                                                    
 // 43.9: int tmp8;                                                                                 
                                                                                                    
                                                                                                    
 // 43.9: tmp8 := this.head;                                                                        
                                                                                                    
                                                                                                    
 moverPath3937392 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937392 := m#moverPath(moverPath3937392);                                                     
 path3937392 := p#moverPath(moverPath3937392);                                                      
 assume Queue._state3937392 == Queue._state && Queue.elems3937392 == Queue.elems && Queue.head3937392 == Queue.head && Queue.tail3937392 == Queue.tail && Queue.spec3937392 == Queue.spec && Queue._lock3937392 == Queue._lock && Array.Queue.T._state3937392 == Array.Queue.T._state && Array.Queue.T._elems3937392 == Array.Queue.T._elems && Array.Queue.T._length3937392 == Array.Queue.T._length && tmp83937392 == tmp8 && tmp73937392 == tmp7 && tmp63937392 == tmp6 && tmp53937392 == tmp5 && x3937392 == x && this3937392 == this && tid3937392 == tid && _pc3937392 == _pc;
 assume $recorded.state3937392 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (43.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 _pc := transition(_pc, mover3937392);                                                              
 assert _pc != PhaseError;                                                                                 // (43.9): Reduction failure
 tmp8 := Queue.head[this];                                                                          
                                                                                                    
 // 43.9: tmp6 = tmp7 - tmp8;                                                                       
                                                                                                    
 tmp6 := (tmp7-tmp8);                                                                               
                                                                                                    
 // 43.9: int tmp9;                                                                                 
                                                                                                    
                                                                                                    
 // 43.9: [Queue.T{this}] tmp10;                                                                    
                                                                                                    
                                                                                                    
 // 43.9: tmp10 := this.elems;                                                                      
                                                                                                    
                                                                                                    
 moverPath3937408 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937408 := m#moverPath(moverPath3937408);                                                     
 path3937408 := p#moverPath(moverPath3937408);                                                      
 assume Queue._state3937408 == Queue._state && Queue.elems3937408 == Queue.elems && Queue.head3937408 == Queue.head && Queue.tail3937408 == Queue.tail && Queue.spec3937408 == Queue.spec && Queue._lock3937408 == Queue._lock && Array.Queue.T._state3937408 == Array.Queue.T._state && Array.Queue.T._elems3937408 == Array.Queue.T._elems && Array.Queue.T._length3937408 == Array.Queue.T._length && tmp103937408 == tmp10 && tmp93937408 == tmp9 && tmp83937408 == tmp8 && tmp73937408 == tmp7 && tmp63937408 == tmp6 && tmp53937408 == tmp5 && x3937408 == x && this3937408 == this && tid3937408 == tid && _pc3937408 == _pc;
 assume $recorded.state3937408 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (43.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 _pc := transition(_pc, mover3937408);                                                              
 assert _pc != PhaseError;                                                                                 // (43.9): Reduction failure
 tmp10 := Queue.elems[this];                                                                        
                                                                                                    
 // 43.9: tmp9 = tmp10.length;                                                                      
                                                                                                    
 tmp9 := Array.Queue.T._length[tmp10];                                                              
                                                                                                    
 // 43.9: tmp5 = tmp6 < tmp9;                                                                       
                                                                                                    
 tmp5 := (tmp6<tmp9);                                                                               
 if (tmp5 /* lowered ((Queue.tail[this]-Queue.head[this])<Array.Queue.T._length[Queue.elems[this]]) */) {
                                                                                                    
  // 44.13: yield;                                                                                  
                                                                                                    
  assume Queue._state3937419 == Queue._state && Queue.elems3937419 == Queue.elems && Queue.head3937419 == Queue.head && Queue.tail3937419 == Queue.tail && Queue.spec3937419 == Queue.spec && Queue._lock3937419 == Queue._lock && Array.Queue.T._state3937419 == Array.Queue.T._state && Array.Queue.T._elems3937419 == Array.Queue.T._elems && Array.Queue.T._length3937419 == Array.Queue.T._length && tmp103937419 == tmp10 && tmp93937419 == tmp9 && tmp83937419 == tmp8 && tmp73937419 == tmp7 && tmp63937419 == tmp6 && tmp53937419 == tmp5 && x3937419 == x && this3937419 == this && tid3937419 == tid;
  assume $recorded.state3937419 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (44.13): Object invariant may not hold.
  _pc := PreCommit;                                                                                 
  assume Queue._state3937419_post == Queue._state && Queue.elems3937419_post == Queue.elems && Queue.head3937419_post == Queue.head && Queue.tail3937419_post == Queue.tail && Queue.spec3937419_post == Queue.spec && Queue._lock3937419_post == Queue._lock && Array.Queue.T._state3937419_post == Array.Queue.T._state && Array.Queue.T._elems3937419_post == Array.Queue.T._elems && Array.Queue.T._length3937419_post == Array.Queue.T._length && tmp103937419_post == tmp10 && tmp93937419_post == tmp9 && tmp83937419_post == tmp8 && tmp73937419_post == tmp7 && tmp63937419_post == tmp6 && tmp53937419_post == tmp5 && x3937419_post == x && this3937419_post == this && tid3937419_post == tid;
  assume $recorded.state3937419_post == 1;                                                          
                                                                                                    
  // 45.13: assume !(NextSpecStep(0));                                                              
                                                                                                    
  assume !(true);                                                                                   
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (46.27): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Queue._lock[this] == Tid.null;                                                             
  _pc := transition(_pc, _R);                                                                       
  assert _pc != PhaseError;                                                                                // (46.27): Reduction failure
  Queue._lock[this] := tid;                                                                         
                                                                                                    
  // 47.17: assume this.tail - this.head < this.elems.length;                                       
                                                                                                    
  assume ((Queue.tail[this]-Queue.head[this])<Array.Queue.T._length[Queue.elems[this]]);            
                                                                                                    
  // 48.17: [Queue.T{this}] tmp11;                                                                  
                                                                                                    
                                                                                                    
  // 48.17: tmp11 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937444 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937444 := m#moverPath(moverPath3937444);                                                    
  path3937444 := p#moverPath(moverPath3937444);                                                     
  assume Queue._state3937444 == Queue._state && Queue.elems3937444 == Queue.elems && Queue.head3937444 == Queue.head && Queue.tail3937444 == Queue.tail && Queue.spec3937444 == Queue.spec && Queue._lock3937444 == Queue._lock && Array.Queue.T._state3937444 == Array.Queue.T._state && Array.Queue.T._elems3937444 == Array.Queue.T._elems && Array.Queue.T._length3937444 == Array.Queue.T._length && tmp113937444 == tmp11 && tmp103937444 == tmp10 && tmp93937444 == tmp9 && tmp83937444 == tmp8 && tmp73937444 == tmp7 && tmp63937444 == tmp6 && tmp53937444 == tmp5 && x3937444 == x && this3937444 == this && tid3937444 == tid && _pc3937444 == _pc;
  assume $recorded.state3937444 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (48.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937444);                                                             
  assert _pc != PhaseError;                                                                                // (48.17): Reduction failure
  tmp11 := Queue.elems[this];                                                                       
                                                                                                    
  // 48.17: int tmp12;                                                                              
                                                                                                    
                                                                                                    
  // 48.17: int tmp13;                                                                              
                                                                                                    
                                                                                                    
  // 48.17: tmp13 := this.tail;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937453 := ReadEval.Queue.tail(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937453 := m#moverPath(moverPath3937453);                                                    
  path3937453 := p#moverPath(moverPath3937453);                                                     
  assume Queue._state3937453 == Queue._state && Queue.elems3937453 == Queue.elems && Queue.head3937453 == Queue.head && Queue.tail3937453 == Queue.tail && Queue.spec3937453 == Queue.spec && Queue._lock3937453 == Queue._lock && Array.Queue.T._state3937453 == Array.Queue.T._state && Array.Queue.T._elems3937453 == Array.Queue.T._elems && Array.Queue.T._length3937453 == Array.Queue.T._length && tmp133937453 == tmp13 && tmp123937453 == tmp12 && tmp113937453 == tmp11 && tmp103937453 == tmp10 && tmp93937453 == tmp9 && tmp83937453 == tmp8 && tmp73937453 == tmp7 && tmp63937453 == tmp6 && tmp53937453 == tmp5 && x3937453 == x && this3937453 == this && tid3937453 == tid && _pc3937453 == _pc;
  assume $recorded.state3937453 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (48.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937453);                                                             
  assert _pc != PhaseError;                                                                                // (48.17): Reduction failure
  tmp13 := Queue.tail[this];                                                                        
                                                                                                    
  // 48.17: int tmp14;                                                                              
                                                                                                    
                                                                                                    
  // 48.17: [Queue.T{this}] tmp15;                                                                  
                                                                                                    
                                                                                                    
  // 48.17: tmp15 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937463 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937463 := m#moverPath(moverPath3937463);                                                    
  path3937463 := p#moverPath(moverPath3937463);                                                     
  assume Queue._state3937463 == Queue._state && Queue.elems3937463 == Queue.elems && Queue.head3937463 == Queue.head && Queue.tail3937463 == Queue.tail && Queue.spec3937463 == Queue.spec && Queue._lock3937463 == Queue._lock && Array.Queue.T._state3937463 == Array.Queue.T._state && Array.Queue.T._elems3937463 == Array.Queue.T._elems && Array.Queue.T._length3937463 == Array.Queue.T._length && tmp153937463 == tmp15 && tmp143937463 == tmp14 && tmp133937463 == tmp13 && tmp123937463 == tmp12 && tmp113937463 == tmp11 && tmp103937463 == tmp10 && tmp93937463 == tmp9 && tmp83937463 == tmp8 && tmp73937463 == tmp7 && tmp63937463 == tmp6 && tmp53937463 == tmp5 && x3937463 == x && this3937463 == this && tid3937463 == tid && _pc3937463 == _pc;
  assume $recorded.state3937463 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (48.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937463);                                                             
  assert _pc != PhaseError;                                                                                // (48.17): Reduction failure
  tmp15 := Queue.elems[this];                                                                       
                                                                                                    
  // 48.17: tmp14 = tmp15.length;                                                                   
                                                                                                    
  tmp14 := Array.Queue.T._length[tmp15];                                                            
                                                                                                    
  // 48.17: tmp12 = tmp13 % tmp14;                                                                  
                                                                                                    
  tmp12 := MOD(tmp13, tmp14);                                                                       
                                                                                                    
  // 48.17: tmp11[tmp12] := x;                                                                      
                                                                                                    
                                                                                                    
  moverPath3937477 := WriteEval.Array.Queue.T(tid: Tid,this: Queue,tmp11: Array.Queue.T,tmp12: int,x: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937477 := m#moverPath(moverPath3937477);                                                    
  path3937477 := p#moverPath(moverPath3937477);                                                     
  assume Queue._state3937477 == Queue._state && Queue.elems3937477 == Queue.elems && Queue.head3937477 == Queue.head && Queue.tail3937477 == Queue.tail && Queue.spec3937477 == Queue.spec && Queue._lock3937477 == Queue._lock && Array.Queue.T._state3937477 == Array.Queue.T._state && Array.Queue.T._elems3937477 == Array.Queue.T._elems && Array.Queue.T._length3937477 == Array.Queue.T._length && tmp153937477 == tmp15 && tmp143937477 == tmp14 && tmp133937477 == tmp13 && tmp123937477 == tmp12 && tmp113937477 == tmp11 && tmp103937477 == tmp10 && tmp93937477 == tmp9 && tmp83937477 == tmp8 && tmp73937477 == tmp7 && tmp63937477 == tmp6 && tmp53937477 == tmp5 && x3937477 == x && this3937477 == this && tid3937477 == tid && _pc3937477 == _pc;
  assume $recorded.state3937477 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp11 != Array.Queue.T.null;                                                              
  } else {                                                                                          
   assert tmp11 != Array.Queue.T.null;                                                                     // (48.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp12;                                                                               
  } else {                                                                                          
   assert 0 <= tmp12;                                                                                      // (48.17): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp12 < Array.Queue.T._length[tmp11];                                                     
  } else {                                                                                          
   assert tmp12 < Array.Queue.T._length[tmp11];                                                            // (48.17): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937477);                                                             
  assert _pc != PhaseError;                                                                                // (48.17): Reduction failure
  Array.Queue.T._elems[tmp11][tmp12] := x;                                                          
                                                                                                    
  // 49.17: Seq<int> tmp16;                                                                         
                                                                                                    
                                                                                                    
  // 49.17: Seq<int> tmp17;                                                                         
                                                                                                    
                                                                                                    
  // 49.17: tmp17 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937488 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937488 := m#moverPath(moverPath3937488);                                                    
  path3937488 := p#moverPath(moverPath3937488);                                                     
  assume Queue._state3937488 == Queue._state && Queue.elems3937488 == Queue.elems && Queue.head3937488 == Queue.head && Queue.tail3937488 == Queue.tail && Queue.spec3937488 == Queue.spec && Queue._lock3937488 == Queue._lock && Array.Queue.T._state3937488 == Array.Queue.T._state && Array.Queue.T._elems3937488 == Array.Queue.T._elems && Array.Queue.T._length3937488 == Array.Queue.T._length && tmp173937488 == tmp17 && tmp163937488 == tmp16 && tmp153937488 == tmp15 && tmp143937488 == tmp14 && tmp133937488 == tmp13 && tmp123937488 == tmp12 && tmp113937488 == tmp11 && tmp103937488 == tmp10 && tmp93937488 == tmp9 && tmp83937488 == tmp8 && tmp73937488 == tmp7 && tmp63937488 == tmp6 && tmp53937488 == tmp5 && x3937488 == x && this3937488 == this && tid3937488 == tid && _pc3937488 == _pc;
  assume $recorded.state3937488 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (49.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937488);                                                             
  assert _pc != PhaseError;                                                                                // (49.17): Reduction failure
  tmp17 := Queue.spec[this];                                                                        
                                                                                                    
  // 49.17: Seq<int> tmp18;                                                                         
                                                                                                    
                                                                                                    
  // 49.17: tmp18 = SeqUnit<int>(x);                                                                
                                                                                                    
  tmp18 := SeqUnit.int(x);                                                                          
                                                                                                    
  // 49.17: tmp16 = SeqConcat<int>(tmp17,tmp18);                                                    
                                                                                                    
  tmp16 := SeqConcat.int(tmp17,tmp18);                                                              
                                                                                                    
                                                                                                    
  // 49.17: this.spec := tmp16;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937506 := WriteEval.Queue.spec(tid: Tid,this: Queue,tmp16: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937506 := m#moverPath(moverPath3937506);                                                    
  path3937506 := p#moverPath(moverPath3937506);                                                     
  assume Queue._state3937506 == Queue._state && Queue.elems3937506 == Queue.elems && Queue.head3937506 == Queue.head && Queue.tail3937506 == Queue.tail && Queue.spec3937506 == Queue.spec && Queue._lock3937506 == Queue._lock && Array.Queue.T._state3937506 == Array.Queue.T._state && Array.Queue.T._elems3937506 == Array.Queue.T._elems && Array.Queue.T._length3937506 == Array.Queue.T._length && tmp183937506 == tmp18 && tmp173937506 == tmp17 && tmp163937506 == tmp16 && tmp153937506 == tmp15 && tmp143937506 == tmp14 && tmp133937506 == tmp13 && tmp123937506 == tmp12 && tmp113937506 == tmp11 && tmp103937506 == tmp10 && tmp93937506 == tmp9 && tmp83937506 == tmp8 && tmp73937506 == tmp7 && tmp63937506 == tmp6 && tmp53937506 == tmp5 && x3937506 == x && this3937506 == this && tid3937506 == tid && _pc3937506 == _pc;
  assume $recorded.state3937506 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (49.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  _pc := transition(_pc, mover3937506);                                                             
  assert _pc != PhaseError;                                                                                // (49.17): Reduction failure
  Queue.spec[this] := tmp16;                                                                        
                                                                                                    
  // 50.17: int tmp19;                                                                              
                                                                                                    
                                                                                                    
  // 50.17: int tmp20;                                                                              
                                                                                                    
                                                                                                    
  // 50.17: tmp20 := this.tail;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937515 := ReadEval.Queue.tail(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937515 := m#moverPath(moverPath3937515);                                                    
  path3937515 := p#moverPath(moverPath3937515);                                                     
  assume Queue._state3937515 == Queue._state && Queue.elems3937515 == Queue.elems && Queue.head3937515 == Queue.head && Queue.tail3937515 == Queue.tail && Queue.spec3937515 == Queue.spec && Queue._lock3937515 == Queue._lock && Array.Queue.T._state3937515 == Array.Queue.T._state && Array.Queue.T._elems3937515 == Array.Queue.T._elems && Array.Queue.T._length3937515 == Array.Queue.T._length && tmp203937515 == tmp20 && tmp193937515 == tmp19 && tmp183937515 == tmp18 && tmp173937515 == tmp17 && tmp163937515 == tmp16 && tmp153937515 == tmp15 && tmp143937515 == tmp14 && tmp133937515 == tmp13 && tmp123937515 == tmp12 && tmp113937515 == tmp11 && tmp103937515 == tmp10 && tmp93937515 == tmp9 && tmp83937515 == tmp8 && tmp73937515 == tmp7 && tmp63937515 == tmp6 && tmp53937515 == tmp5 && x3937515 == x && this3937515 == this && tid3937515 == tid && _pc3937515 == _pc;
  assume $recorded.state3937515 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (50.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937515);                                                             
  assert _pc != PhaseError;                                                                                // (50.17): Reduction failure
  tmp20 := Queue.tail[this];                                                                        
                                                                                                    
  // 50.17: tmp19 = tmp20 + 1;                                                                      
                                                                                                    
  tmp19 := (tmp20+1);                                                                               
                                                                                                    
                                                                                                    
  // 50.17: this.tail := tmp19;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937525 := WriteEval.Queue.tail(tid: Tid,this: Queue,tmp19: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937525 := m#moverPath(moverPath3937525);                                                    
  path3937525 := p#moverPath(moverPath3937525);                                                     
  assume Queue._state3937525 == Queue._state && Queue.elems3937525 == Queue.elems && Queue.head3937525 == Queue.head && Queue.tail3937525 == Queue.tail && Queue.spec3937525 == Queue.spec && Queue._lock3937525 == Queue._lock && Array.Queue.T._state3937525 == Array.Queue.T._state && Array.Queue.T._elems3937525 == Array.Queue.T._elems && Array.Queue.T._length3937525 == Array.Queue.T._length && tmp203937525 == tmp20 && tmp193937525 == tmp19 && tmp183937525 == tmp18 && tmp173937525 == tmp17 && tmp163937525 == tmp16 && tmp153937525 == tmp15 && tmp143937525 == tmp14 && tmp133937525 == tmp13 && tmp123937525 == tmp12 && tmp113937525 == tmp11 && tmp103937525 == tmp10 && tmp93937525 == tmp9 && tmp83937525 == tmp8 && tmp73937525 == tmp7 && tmp63937525 == tmp6 && tmp53937525 == tmp5 && x3937525 == x && this3937525 == this && tid3937525 == tid && _pc3937525 == _pc;
  assume $recorded.state3937525 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (50.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  _pc := transition(_pc, mover3937525);                                                             
  assert _pc != PhaseError;                                                                                // (50.17): Reduction failure
  Queue.tail[this] := tmp19;                                                                        
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (51.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert Queue._lock[this] == tid;                                                                         // (51.13): lock not held
  _pc := transition(_pc, _L);                                                                       
  assert _pc != PhaseError;                                                                                // (51.13): Reduction failure
  Queue._lock[this] := Tid.null;                                                                    
 } else {                                                                                           
 }                                                                                                  
                                                                                                    
 // 42.32: // return;                                                                               
                                                                                                    
 assume Queue._state3937533 == Queue._state && Queue.elems3937533 == Queue.elems && Queue.head3937533 == Queue.head && Queue.tail3937533 == Queue.tail && Queue.spec3937533 == Queue.spec && Queue._lock3937533 == Queue._lock && Array.Queue.T._state3937533 == Array.Queue.T._state && Array.Queue.T._elems3937533 == Array.Queue.T._elems && Array.Queue.T._length3937533 == Array.Queue.T._length && tmp103937533 == tmp10 && tmp93937533 == tmp9 && tmp83937533 == tmp8 && tmp73937533 == tmp7 && tmp63937533 == tmp6 && tmp53937533 == tmp5 && x3937533 == x && this3937533 == this && tid3937533 == tid;
 assume $recorded.state3937533 == 1;                                                                
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (42.32): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (42.32): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (42.32): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (42.32): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
procedure  Queue.dequeue(tid:Tid, this : Queue)                                                     
returns ($result : int)                                                                             
modifies Queue._state;                                                                              
modifies Queue.elems;                                                                               
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue.spec;                                                                                
modifies Queue._lock;                                                                               
modifies Array.Queue.T._state;                                                                      
modifies Array.Queue.T._elems;                                                                      
                                                                                                    
requires ValidTid(tid);                                                                                    // (55.5): Bad tid
requires isShared(Queue._state[this]);                                                                     // (55.5): this is not global
                                                                                                    
requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
requires (tid==2);                                                                                  
                                                                                                    
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (55.5): Object invariant may not hold.
{                                                                                                   
 var tmp373937876: int;                                                                             
 var tmp453937821: int;                                                                             
 var Array.Queue.T._state3937548: [Array.Queue.T]State;                                             
 var moverPath3937670: MoverPath;                                                                   
 var path3937548: int;                                                                              
 var _pc3937655: Phase;                                                                             
 var tmp473937866: Seq.int;                                                                         
 var tmp283937684: int;                                                                             
 var Queue._state3937568_post: [Queue]State;                                                        
 var tmp353937821: Seq.int;                                                                         
 var $recorded.state3937609: int;                                                                   
 var result: int;                                                                                   
 var _pc3937703: Phase;                                                                             
 var Array.Queue.T._length3937895: [Array.Queue.T]int;                                              
 var Queue.spec3937548: [Queue]Seq.int;                                                             
 var tmp30: int;                                                                                    
 var moverPath3937720: MoverPath;                                                                   
 var Queue.elems3937621: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._elems3937655: [Array.Queue.T]([int]int);                                        
 var this3937866: Queue;                                                                            
 var tmp353937703: Seq.int;                                                                         
 var tmp42: Array.Queue.T;                                                                          
 var tmp273937880: Array.Queue.T;                                                                   
 var tmp463937821: Array.Queue.T;                                                                   
 var $result3937735: int;                                                                           
 var Queue.tail3937548: [Queue]int;                                                                 
 var moverPath3937638: MoverPath;                                                                   
 var tmp393937735: int;                                                                             
 var tmp443937768: int;                                                                             
 var Array.Queue.T._state3937655: [Array.Queue.T]State;                                             
 var tmp223937876: int;                                                                             
 var _pc3937735: Phase;                                                                             
 var mover3937821: Mover;                                                                           
 var Array.Queue.T._length3937857: [Array.Queue.T]int;                                              
 var Queue._state3937876: [Queue]State;                                                             
 var tmp433937866: int;                                                                             
 var tmp233937655: int;                                                                             
 var tmp343937754: int;                                                                             
 var mover3937595: Mover;                                                                           
 var tmp353937754: Seq.int;                                                                         
 var $result3937595: int;                                                                           
 var tmp223937703: int;                                                                             
 var tmp253937735: int;                                                                             
 var tmp283937621: int;                                                                             
 var tmp243937621: int;                                                                             
 var tmp263937876: Seq.int;                                                                         
 var tmp233937554: int;                                                                             
 var tmp233937895: int;                                                                             
 var $recorded.state3937834: int;                                                                   
 var Queue._lock3937735: [Queue]Tid;                                                                
 var tmp353937768: Seq.int;                                                                         
 var Queue.elems3937703: [Queue]Array.Queue.T;                                                      
 var Queue.spec3937609: [Queue]Seq.int;                                                             
 var this3937720: Queue;                                                                            
 var tmp213937693: bool;                                                                            
 var mover3937876: Mover;                                                                           
 var path3937693: int;                                                                              
 var $recorded.state3937703: int;                                                                   
 var tmp513937876: Seq.int;                                                                         
 var mover3937693: Mover;                                                                           
 var Queue.spec3937595: [Queue]Seq.int;                                                             
 var tmp333937821: int;                                                                             
 var tmp453937857: int;                                                                             
 var tmp38: int;                                                                                    
 var Queue.spec3937744: [Queue]Seq.int;                                                             
 var tmp213937834: bool;                                                                            
 var tmp343937735: int;                                                                             
 var Queue._state3937880: [Queue]State;                                                             
 var Array.Queue.T._length3937670: [Array.Queue.T]int;                                              
 var _pc3937554: Phase;                                                                             
 var Queue.elems3937821: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._length3937866: [Array.Queue.T]int;                                              
 var $recorded.state3937595: int;                                                                   
 var Queue.head3937660: [Queue]int;                                                                 
 var tmp283937655: int;                                                                             
 var $recorded.state3937754: int;                                                                   
 var $result3937821: int;                                                                           
 var Array.Queue.T._state3937895: [Array.Queue.T]State;                                             
 var Queue._state3937735: [Queue]State;                                                             
 var tmp243937660: int;                                                                             
 var Queue._state3937821: [Queue]State;                                                             
 var $result3937609: int;                                                                           
 var path3937876: int;                                                                              
 var tmp273937857: Array.Queue.T;                                                                   
 var Array.Queue.T._elems3937568: [Array.Queue.T]([int]int);                                        
 var Queue._lock3937621: [Queue]Tid;                                                                
 var tmp263937609: Seq.int;                                                                         
 var tmp233937857: int;                                                                             
 var Array.Queue.T._state3937638: [Array.Queue.T]State;                                             
 var tmp43: int;                                                                                    
 var tid3937670: Tid;                                                                               
 var tmp313937725: int;                                                                             
 var tmp353937693: Seq.int;                                                                         
 var tmp403937720: Array.Queue.T;                                                                   
 var tmp273937725: Array.Queue.T;                                                                   
 var tmp493937866: int;                                                                             
 var Queue._lock3937725: [Queue]Tid;                                                                
 var tmp223937568_post: int;                                                                        
 var Queue.tail3937889: [Queue]int;                                                                 
 var tmp263937754: Seq.int;                                                                         
 var $recorded.state3937735: int;                                                                   
 var tmp253937768: int;                                                                             
 var tmp443937880: int;                                                                             
 var Queue._state3937866: [Queue]State;                                                             
 var tmp213937595: bool;                                                                            
 var mover3937670: Mover;                                                                           
 var Queue.head3937554: [Queue]int;                                                                 
 var tmp243937821: int;                                                                             
 var tmp373937866: int;                                                                             
 var tmp303937660: int;                                                                             
 var tid3937880: Tid;                                                                               
 var tmp463937866: Array.Queue.T;                                                                   
 var tmp283937638: int;                                                                             
 var tmp213937638: bool;                                                                            
 var tmp263937880: Seq.int;                                                                         
 var tmp533937866: int;                                                                             
 var tmp363937857: Array.Queue.T;                                                                   
 var _pc3937568_post: Phase;                                                                        
 var tmp403937754: Array.Queue.T;                                                                   
 var tmp223937895: int;                                                                             
 var Queue.head3937684: [Queue]int;                                                                 
 var tid3937621: Tid;                                                                               
 var Queue.elems3937866: [Queue]Array.Queue.T;                                                      
 var tmp253937655: int;                                                                             
 var Queue.tail3937703: [Queue]int;                                                                 
 var tmp483937821: Seq.int;                                                                         
 var Queue.head3937735: [Queue]int;                                                                 
 var Array.Queue.T._elems3937725: [Array.Queue.T]([int]int);                                        
 var tmp333937703: int;                                                                             
 var tmp243937684: int;                                                                             
 var Array.Queue.T._length3937621: [Array.Queue.T]int;                                              
 var tid3937725: Tid;                                                                               
 var tmp473937880: Seq.int;                                                                         
 var Queue.spec3937621: [Queue]Seq.int;                                                             
 var Queue.spec3937693: [Queue]Seq.int;                                                             
 var Array.Queue.T._length3937735: [Array.Queue.T]int;                                              
 var tmp383937744: int;                                                                             
 var tmp473937876: Seq.int;                                                                         
 var tmp493937857: int;                                                                             
 var Array.Queue.T._elems3937609: [Array.Queue.T]([int]int);                                        
 var Array.Queue.T._length3937638: [Array.Queue.T]int;                                              
 var Queue.tail3937554: [Queue]int;                                                                 
 var tmp243937693: int;                                                                             
 var tmp303937880: int;                                                                             
 var _pc3937889: Phase;                                                                             
 var Array.Queue.T._length3937754: [Array.Queue.T]int;                                              
 var tmp513937866: Seq.int;                                                                         
 var tmp473937821: Seq.int;                                                                         
 var Array.Queue.T._state3937670: [Array.Queue.T]State;                                             
 var tmp353937880: Seq.int;                                                                         
 var _pc3937895: Phase;                                                                             
 var Queue.spec3937866: [Queue]Seq.int;                                                             
 var _pc3937876: Phase;                                                                             
 var tid3937895: Tid;                                                                               
 var Queue._state3937595: [Queue]State;                                                             
 var tmp393937880: int;                                                                             
 var _pc3937866: Phase;                                                                             
 var this3937554: Queue;                                                                            
 var moverPath3937693: MoverPath;                                                                   
 var tmp253937720: int;                                                                             
 var mover3937684: Mover;                                                                           
 var tmp453937754: int;                                                                             
 var tmp253937857: int;                                                                             
 var Queue.tail3937670: [Queue]int;                                                                 
 var tid3937655: Tid;                                                                               
 var tmp263937684: Seq.int;                                                                         
 var $recorded.state3937568: int;                                                                   
 var this3937768: Queue;                                                                            
 var mover3937768: Mover;                                                                           
 var $result3937554: int;                                                                           
 var tmp293937670: int;                                                                             
 var tmp453937866: int;                                                                             
 var tmp323937857: Array.Queue.T;                                                                   
 var tmp413937880: int;                                                                             
 var _pc3937638: Phase;                                                                             
 var tmp463937768: Array.Queue.T;                                                                   
 var this3937660: Queue;                                                                            
 var $result3937895: int;                                                                           
 var result3937866: int;                                                                            
 var tmp343937866: int;                                                                             
 var moverPath3937857: MoverPath;                                                                   
 var Array.Queue.T._length3937889: [Array.Queue.T]int;                                              
 var tmp353937876: Seq.int;                                                                         
 var tmp303937744: int;                                                                             
 var path3937609: int;                                                                              
 var tmp263937660: Seq.int;                                                                         
 var Queue.elems3937548: [Queue]Array.Queue.T;                                                      
 var tmp233937660: int;                                                                             
 var tmp253937660: int;                                                                             
 var tmp413937720: int;                                                                             
 var tmp303937693: int;                                                                             
 var $result3937725: int;                                                                           
 var tmp283937703: int;                                                                             
 var tmp263937744: Seq.int;                                                                         
 var path3937744: int;                                                                              
 var tmp323937660: Array.Queue.T;                                                                   
 var Queue._state3937684: [Queue]State;                                                             
 var tmp233937744: int;                                                                             
 var tmp443937857: int;                                                                             
 var Array.Queue.T._length3937744: [Array.Queue.T]int;                                              
 var Queue._state3937725: [Queue]State;                                                             
 var Queue.elems3937693: [Queue]Array.Queue.T;                                                      
 var tmp393937744: int;                                                                             
 var $recorded.state3937880: int;                                                                   
 var tmp233937638: int;                                                                             
 var tmp273937609: Array.Queue.T;                                                                   
 var tmp433937876: int;                                                                             
 var Array.Queue.T._length3937655: [Array.Queue.T]int;                                              
 var tmp503937876: int;                                                                             
 var tmp223937866: int;                                                                             
 var _pc3937595: Phase;                                                                             
 var Queue._state3937744: [Queue]State;                                                             
 var tmp323937754: Array.Queue.T;                                                                   
 var tid3937876: Tid;                                                                               
 var Queue._lock3937609: [Queue]Tid;                                                                
 var Queue.head3937670: [Queue]int;                                                                 
 var Queue.spec3937876: [Queue]Seq.int;                                                             
 var tmp313937857: int;                                                                             
 var tmp273937693: Array.Queue.T;                                                                   
 var Array.Queue.T._state3937720: [Array.Queue.T]State;                                             
 var _pc3937754: Phase;                                                                             
 var tmp293937821: int;                                                                             
 var tmp523937876: int;                                                                             
 var Queue.head3937866: [Queue]int;                                                                 
 var tmp313937821: int;                                                                             
 var tmp293937754: int;                                                                             
 var tmp313937744: int;                                                                             
 var tmp353937866: Seq.int;                                                                         
 var tmp333937660: int;                                                                             
 var tmp293937725: int;                                                                             
 var tmp213937568_post: bool;                                                                       
 var Array.Queue.T._length3937876: [Array.Queue.T]int;                                              
 var Queue._state3937621: [Queue]State;                                                             
 var tmp243937670: int;                                                                             
 var $recorded.state3937857: int;                                                                   
 var tmp483937834: Seq.int;                                                                         
 var Queue._lock3937548: [Queue]Tid;                                                                
 var tmp403937880: Array.Queue.T;                                                                   
 var moverPath3937621: MoverPath;                                                                   
 var this3937754: Queue;                                                                            
 var Queue.tail3937754: [Queue]int;                                                                 
 var Queue.head3937768: [Queue]int;                                                                 
 var tmp293937768: int;                                                                             
 var $recorded.state3937821: int;                                                                   
 var tid3937660: Tid;                                                                               
 var moverPath3937609: MoverPath;                                                                   
 var tid3937735: Tid;                                                                               
 var tmp213937754: bool;                                                                            
 var tmp483937876: Seq.int;                                                                         
 var tmp223937609: int;                                                                             
 var tmp333937744: int;                                                                             
 var _pc3937609: Phase;                                                                             
 var tmp433937754: int;                                                                             
 var tmp403937768: Array.Queue.T;                                                                   
 var mover3937703: Mover;                                                                           
 var Array.Queue.T._state3937595: [Array.Queue.T]State;                                             
 var tmp303937857: int;                                                                             
 var Array.Queue.T._elems3937834: [Array.Queue.T]([int]int);                                        
 var Queue._state3937754: [Queue]State;                                                             
 var tmp253937754: int;                                                                             
 var Queue.spec3937568: [Queue]Seq.int;                                                             
 var tmp403937834: Array.Queue.T;                                                                   
 var tmp233937754: int;                                                                             
 var tmp223937638: int;                                                                             
 var moverPath3937754: MoverPath;                                                                   
 var tmp303937834: int;                                                                             
 var tmp313937866: int;                                                                             
 var Array.Queue.T._elems3937621: [Array.Queue.T]([int]int);                                        
 var moverPath3937866: MoverPath;                                                                   
 var tmp403937725: Array.Queue.T;                                                                   
 var tmp263937725: Seq.int;                                                                         
 var Queue.elems3937880: [Queue]Array.Queue.T;                                                      
 var _pc3937568: Phase;                                                                             
 var moverPath3937655: MoverPath;                                                                   
 var tmp243937725: int;                                                                             
 var tmp48: Seq.int;                                                                                
 var tid3937889: Tid;                                                                               
 var tmp353937735: Seq.int;                                                                         
 var tmp363937720: Array.Queue.T;                                                                   
 var tmp22: int;                                                                                    
 var _pc3937670: Phase;                                                                             
 var tmp343937880: int;                                                                             
 var Array.Queue.T._state3937703: [Array.Queue.T]State;                                             
 var $result3937834: int;                                                                           
 var tmp463937834: Array.Queue.T;                                                                   
 var Array.Queue.T._elems3937895: [Array.Queue.T]([int]int);                                        
 var this3937684: Queue;                                                                            
 var Array.Queue.T._elems3937568_post: [Array.Queue.T]([int]int);                                   
 var tmp513937834: Seq.int;                                                                         
 var Queue.tail3937568_post: [Queue]int;                                                            
 var Array.Queue.T._elems3937703: [Array.Queue.T]([int]int);                                        
 var tmp383937866: int;                                                                             
 var tmp313937735: int;                                                                             
 var tmp323937880: Array.Queue.T;                                                                   
 var tmp483937857: Seq.int;                                                                         
 var $result3937880: int;                                                                           
 var tmp483937880: Seq.int;                                                                         
 var tmp503937857: int;                                                                             
 var tmp503937880: int;                                                                             
 var tmp303937821: int;                                                                             
 var tmp463937876: Array.Queue.T;                                                                   
 var this3937548: Queue;                                                                            
 var path3937554: int;                                                                              
 var this3937735: Queue;                                                                            
 var tmp283937880: int;                                                                             
 var tmp47: Seq.int;                                                                                
 var Queue.tail3937866: [Queue]int;                                                                 
 var Queue._lock3937568_post: [Queue]Tid;                                                           
 var tmp233937693: int;                                                                             
 var Array.Queue.T._state3937568: [Array.Queue.T]State;                                             
 var tmp243937857: int;                                                                             
 var tmp423937744: Array.Queue.T;                                                                   
 var tmp423937876: Array.Queue.T;                                                                   
 var tmp323937735: Array.Queue.T;                                                                   
 var Queue.spec3937703: [Queue]Seq.int;                                                             
 var Array.Queue.T._length3937880: [Array.Queue.T]int;                                              
 var tid3937693: Tid;                                                                               
 var mover3937609: Mover;                                                                           
 var Queue.head3937638: [Queue]int;                                                                 
 var tid3937554: Tid;                                                                               
 var tmp343937725: int;                                                                             
 var tmp263937693: Seq.int;                                                                         
 var tmp223937684: int;                                                                             
 var tmp383937725: int;                                                                             
 var tid3937720: Tid;                                                                               
 var Queue._state3937609: [Queue]State;                                                             
 var Queue.elems3937609: [Queue]Array.Queue.T;                                                      
 var tmp233937621: int;                                                                             
 var Array.Queue.T._state3937754: [Array.Queue.T]State;                                             
 var Array.Queue.T._elems3937889: [Array.Queue.T]([int]int);                                        
 var Queue._lock3937568: [Queue]Tid;                                                                
 var tmp253937638: int;                                                                             
 var Queue._state3937857: [Queue]State;                                                             
 var tmp233937720: int;                                                                             
 var tmp413937725: int;                                                                             
 var $result3937670: int;                                                                           
 var Queue.spec3937821: [Queue]Seq.int;                                                             
 var tmp413937857: int;                                                                             
 var moverPath3937548: MoverPath;                                                                   
 var tmp243937866: int;                                                                             
 var Array.Queue.T._length3937821: [Array.Queue.T]int;                                              
 var moverPath3937834: MoverPath;                                                                   
 var tmp403937703: Array.Queue.T;                                                                   
 var tmp273937621: Array.Queue.T;                                                                   
 var Array.Queue.T._state3937660: [Array.Queue.T]State;                                             
 var tmp253937609: int;                                                                             
 var tmp253937725: int;                                                                             
 var tmp403937735: Array.Queue.T;                                                                   
 var tmp293937876: int;                                                                             
 var tmp273937720: Array.Queue.T;                                                                   
 var Queue.head3937693: [Queue]int;                                                                 
 var tmp403937876: Array.Queue.T;                                                                   
 var this3937834: Queue;                                                                            
 var tmp333937684: int;                                                                             
 var $result3937744: int;                                                                           
 var tmp423937880: Array.Queue.T;                                                                   
 var tmp343937720: int;                                                                             
 var Queue.spec3937754: [Queue]Seq.int;                                                             
 var tmp363937725: Array.Queue.T;                                                                   
 var tmp313937720: int;                                                                             
 var _pc3937744: Phase;                                                                             
 var tmp253937670: int;                                                                             
 var tmp413937754: int;                                                                             
 var Queue.head3937876: [Queue]int;                                                                 
 var Array.Queue.T._elems3937768: [Array.Queue.T]([int]int);                                        
 var tmp273937754: Array.Queue.T;                                                                   
 var Queue._state3937720: [Queue]State;                                                             
 var tmp343937857: int;                                                                             
 var Array.Queue.T._length3937609: [Array.Queue.T]int;                                              
 var $result3937703: int;                                                                           
 var tmp233937880: int;                                                                             
 var Queue.elems3937834: [Queue]Array.Queue.T;                                                      
 var tmp243937568_post: int;                                                                        
 var tid3937609: Tid;                                                                               
 var $recorded.state3937744: int;                                                                   
 var tmp243937889: int;                                                                             
 var tmp333937876: int;                                                                             
 var $result3937857: int;                                                                           
 var Queue.spec3937834: [Queue]Seq.int;                                                             
 var mover3937548: Mover;                                                                           
 var Queue.head3937821: [Queue]int;                                                                 
 var Queue._lock3937693: [Queue]Tid;                                                                
 var tmp343937834: int;                                                                             
 var Queue.head3937720: [Queue]int;                                                                 
 var tmp213937880: bool;                                                                            
 var tmp373937880: int;                                                                             
 var Queue.tail3937568: [Queue]int;                                                                 
 var tmp223937595: int;                                                                             
 var tmp333937725: int;                                                                             
 var tmp253937703: int;                                                                             
 var Array.Queue.T._state3937866: [Array.Queue.T]State;                                             
 var tmp323937725: Array.Queue.T;                                                                   
 var tmp223937834: int;                                                                             
 var tmp273937703: Array.Queue.T;                                                                   
 var path3937866: int;                                                                              
 var tmp303937866: int;                                                                             
 var tmp383937876: int;                                                                             
 var $recorded.state3937548: int;                                                                   
 var tmp373937735: int;                                                                             
 var $result3937621: int;                                                                           
 var Queue.elems3937595: [Queue]Array.Queue.T;                                                      
 var tmp303937735: int;                                                                             
 var Array.Queue.T._state3937554: [Array.Queue.T]State;                                             
 var moverPath3937821: MoverPath;                                                                   
 var this3937638: Queue;                                                                            
 var tmp413937735: int;                                                                             
 var mover3937655: Mover;                                                                           
 var tmp213937621: bool;                                                                            
 var _pc3937857: Phase;                                                                             
 var tmp263937621: Seq.int;                                                                         
 var tmp343937876: int;                                                                             
 var tmp253937834: int;                                                                             
 var tmp223937554: int;                                                                             
 var moverPath3937876: MoverPath;                                                                   
 var Queue.head3937568: [Queue]int;                                                                 
 var tmp243937735: int;                                                                             
 var tid3937821: Tid;                                                                               
 var tmp453937876: int;                                                                             
 var tmp383937880: int;                                                                             
 var $result3937866: int;                                                                           
 var this3937895: Queue;                                                                            
 var tmp28: int;                                                                                    
 var $result3937768: int;                                                                           
 var tmp423937866: Array.Queue.T;                                                                   
 var tmp393937720: int;                                                                             
 var Queue.elems3937895: [Queue]Array.Queue.T;                                                      
 var tmp303937638: int;                                                                             
 var tmp243937655: int;                                                                             
 var path3937684: int;                                                                              
 var tmp353937720: Seq.int;                                                                         
 var tmp333937735: int;                                                                             
 var $result3937548: int;                                                                           
 var this3937693: Queue;                                                                            
 var Array.Queue.T._length3937568: [Array.Queue.T]int;                                              
 var Queue._lock3937670: [Queue]Tid;                                                                
 var Array.Queue.T._length3937684: [Array.Queue.T]int;                                              
 var Array.Queue.T._state3937735: [Array.Queue.T]State;                                             
 var tmp393937754: int;                                                                             
 var path3937720: int;                                                                              
 var tmp413937834: int;                                                                             
 var mover3937744: Mover;                                                                           
 var tmp403937866: Array.Queue.T;                                                                   
 var tmp433937857: int;                                                                             
 var tmp323937744: Array.Queue.T;                                                                   
 var tmp463937857: Array.Queue.T;                                                                   
 var tmp443937876: int;                                                                             
 var result3937876: int;                                                                            
 var tmp403937821: Array.Queue.T;                                                                   
 var tmp213937866: bool;                                                                            
 var tmp243937834: int;                                                                             
 var tmp243937744: int;                                                                             
 var tmp283937720: int;                                                                             
 var tmp333937720: int;                                                                             
 var Array.Queue.T._state3937834: [Array.Queue.T]State;                                             
 var Queue.head3937857: [Queue]int;                                                                 
 var tmp353937857: Seq.int;                                                                         
 var tmp303937725: int;                                                                             
 var tmp283937768: int;                                                                             
 var tmp323937876: Array.Queue.T;                                                                   
 var Queue.elems3937735: [Queue]Array.Queue.T;                                                      
 var tmp473937834: Seq.int;                                                                         
 var tmp213937895: bool;                                                                            
 var Queue.elems3937554: [Queue]Array.Queue.T;                                                      
 var tmp343937693: int;                                                                             
 var tmp213937703: bool;                                                                            
 var tmp233937568: int;                                                                             
 var Queue.tail3937655: [Queue]int;                                                                 
 var tmp303937876: int;                                                                             
 var tmp293937638: int;                                                                             
 var Queue.head3937895: [Queue]int;                                                                 
 var tmp253937866: int;                                                                             
 var _pc3937693: Phase;                                                                             
 var tmp213937554: bool;                                                                            
 var $recorded.state3937768: int;                                                                   
 var Queue.tail3937880: [Queue]int;                                                                 
 var Array.Queue.T._state3937725: [Array.Queue.T]State;                                             
 var Queue._lock3937857: [Queue]Tid;                                                                
 var Queue.spec3937735: [Queue]Seq.int;                                                             
 var tmp283937754: int;                                                                             
 var tmp423937821: Array.Queue.T;                                                                   
 var tmp323937655: Array.Queue.T;                                                                   
 var mover3937754: Mover;                                                                           
 var tmp263937866: Seq.int;                                                                         
 var path3937857: int;                                                                              
 var path3937670: int;                                                                              
 var tmp273937670: Array.Queue.T;                                                                   
 var Queue._state3937670: [Queue]State;                                                             
 var Queue.head3937889: [Queue]int;                                                                 
 var path3937703: int;                                                                              
 var tmp303937768: int;                                                                             
 var Queue._state3937693: [Queue]State;                                                             
 var this3937821: Queue;                                                                            
 var tmp523937880: int;                                                                             
 var tmp403937857: Array.Queue.T;                                                                   
 var tmp243937768: int;                                                                             
 var tid3937638: Tid;                                                                               
 var Queue.head3937725: [Queue]int;                                                                 
 var tmp223937768: int;                                                                             
 var tmp273937735: Array.Queue.T;                                                                   
 var Queue.elems3937725: [Queue]Array.Queue.T;                                                      
 var tmp40: Array.Queue.T;                                                                          
 var tmp253937744: int;                                                                             
 var tmp223937725: int;                                                                             
 var tmp263937735: Seq.int;                                                                         
 var tmp223937621: int;                                                                             
 var tmp213937725: bool;                                                                            
 var Array.Queue.T._length3937703: [Array.Queue.T]int;                                              
 var tmp353937834: Seq.int;                                                                         
 var Queue.head3937609: [Queue]int;                                                                 
 var tmp323937684: Array.Queue.T;                                                                   
 var tmp233937768: int;                                                                             
 var tmp423937834: Array.Queue.T;                                                                   
 var $result3937720: int;                                                                           
 var tmp313937684: int;                                                                             
 var tmp293937834: int;                                                                             
 var tmp293937703: int;                                                                             
 var tmp273937638: Array.Queue.T;                                                                   
 var Queue._state3937655: [Queue]State;                                                             
 var $recorded.state3937568_post: int;                                                              
 var tmp433937821: int;                                                                             
 var Queue.spec3937568_post: [Queue]Seq.int;                                                        
 var Queue.head3937595: [Queue]int;                                                                 
 var this3937595: Queue;                                                                            
 var tmp483937866: Seq.int;                                                                         
 var path3937621: int;                                                                              
 var tmp313937693: int;                                                                             
 var tmp423937857: Array.Queue.T;                                                                   
 var tmp293937655: int;                                                                             
 var tmp293937866: int;                                                                             
 var tmp393937821: int;                                                                             
 var Array.Queue.T._state3937693: [Array.Queue.T]State;                                             
 var tmp323937693: Array.Queue.T;                                                                   
 var Queue.elems3937768: [Queue]Array.Queue.T;                                                      
 var Queue._state3937568: [Queue]State;                                                             
 var this3937670: Queue;                                                                            
 var tmp363937735: Array.Queue.T;                                                                   
 var Queue._lock3937889: [Queue]Tid;                                                                
 var Queue._lock3937866: [Queue]Tid;                                                                
 var tmp283937834: int;                                                                             
 var Queue.head3937834: [Queue]int;                                                                 
 var tmp393937768: int;                                                                             
 var Queue._state3937768: [Queue]State;                                                             
 var tmp433937744: int;                                                                             
 var this3937703: Queue;                                                                            
 var Queue._state3937895: [Queue]State;                                                             
 var tmp243937595: int;                                                                             
 var tmp213937768: bool;                                                                            
 var Queue._lock3937744: [Queue]Tid;                                                                
 var Queue.elems3937876: [Queue]Array.Queue.T;                                                      
 var Array.Queue.T._state3937684: [Array.Queue.T]State;                                             
 var tmp533937880: int;                                                                             
 var Queue.elems3937568: [Queue]Array.Queue.T;                                                      
 var Queue.tail3937744: [Queue]int;                                                                 
 var Array.Queue.T._state3937880: [Array.Queue.T]State;                                             
 var $recorded.state3937684: int;                                                                   
 var tmp273937684: Array.Queue.T;                                                                   
 var tmp26: Seq.int;                                                                                
 var Queue.elems3937568_post: [Queue]Array.Queue.T;                                                 
 var tmp253937621: int;                                                                             
 var Queue._state3937554: [Queue]State;                                                             
 var tmp213937744: bool;                                                                            
 var Queue._lock3937834: [Queue]Tid;                                                                
 var tmp313937880: int;                                                                             
 var Queue.spec3937880: [Queue]Seq.int;                                                             
 var tmp293937880: int;                                                                             
 var tmp213937857: bool;                                                                            
 var tmp513937857: Seq.int;                                                                         
 var tmp443937754: int;                                                                             
 var $recorded.state3937655: int;                                                                   
 var path3937595: int;                                                                              
 var path3937821: int;                                                                              
 var tmp233937670: int;                                                                             
 var tmp323937703: Array.Queue.T;                                                                   
 var Queue.spec3937670: [Queue]Seq.int;                                                             
 var mover3937834: Mover;                                                                           
 var tmp233937595: int;                                                                             
 var tmp263937655: Seq.int;                                                                         
 var tmp363937684: Array.Queue.T;                                                                   
 var Array.Queue.T._length3937568_post: [Array.Queue.T]int;                                         
 var tmp39: int;                                                                                    
 var tmp223937548: int;                                                                             
 var tmp303937754: int;                                                                             
 var tmp23: int;                                                                                    
 var tmp533937876: int;                                                                             
 var tmp223937889: int;                                                                             
 var Array.Queue.T._elems3937744: [Array.Queue.T]([int]int);                                        
 var tmp303937655: int;                                                                             
 var tmp413937821: int;                                                                             
 var tid3937857: Tid;                                                                               
 var tmp383937735: int;                                                                             
 var tmp233937866: int;                                                                             
 var mover3937621: Mover;                                                                           
 var Queue._state3937548: [Queue]State;                                                             
 var tmp27: Array.Queue.T;                                                                          
 var _pc3937768: Phase;                                                                             
 var Queue._state3937889: [Queue]State;                                                             
 var Queue.elems3937744: [Queue]Array.Queue.T;                                                      
 var tid3937834: Tid;                                                                               
 var tmp333937693: int;                                                                             
 var Queue.spec3937554: [Queue]Seq.int;                                                             
 var tmp37: int;                                                                                    
 var tmp223937660: int;                                                                             
 var tmp283937735: int;                                                                             
 var tmp343937821: int;                                                                             
 var $result3937684: int;                                                                           
 var tmp333937834: int;                                                                             
 var Queue.tail3937768: [Queue]int;                                                                 
 var Queue.head3937568_post: [Queue]int;                                                            
 var Queue.tail3937834: [Queue]int;                                                                 
 var tmp243937638: int;                                                                             
 var Queue._state3937703: [Queue]State;                                                             
 var Array.Queue.T._length3937834: [Array.Queue.T]int;                                              
 var Queue._lock3937703: [Queue]Tid;                                                                
 var tmp233937834: int;                                                                             
 var tmp433937880: int;                                                                             
 var Queue.tail3937609: [Queue]int;                                                                 
 var Array.Queue.T._state3937568_post: [Array.Queue.T]State;                                        
 var tmp313937703: int;                                                                             
 var $recorded.state3937866: int;                                                                   
 var tmp243937876: int;                                                                             
 var tmp413937866: int;                                                                             
 var Queue.elems3937670: [Queue]Array.Queue.T;                                                      
 var tmp273937768: Array.Queue.T;                                                                   
 var tmp333937670: int;                                                                             
 var path3937735: int;                                                                              
 var tmp423937768: Array.Queue.T;                                                                   
 var Queue.head3937703: [Queue]int;                                                                 
 var tmp363937880: Array.Queue.T;                                                                   
 var tmp213937821: bool;                                                                            
 var tid3937744: Tid;                                                                               
 var tid3937684: Tid;                                                                               
 var tmp283937670: int;                                                                             
 var tmp223937568: int;                                                                             
 var tmp343937744: int;                                                                             
 var tmp273937744: Array.Queue.T;                                                                   
 var tmp213937735: bool;                                                                            
 var tmp293937744: int;                                                                             
 var tid3937866: Tid;                                                                               
 var Queue.spec3937895: [Queue]Seq.int;                                                             
 var mover3937866: Mover;                                                                           
 var tmp293937857: int;                                                                             
 var path3937638: int;                                                                              
 var tid3937754: Tid;                                                                               
 var Array.Queue.T._elems3937720: [Array.Queue.T]([int]int);                                        
 var Queue.tail3937735: [Queue]int;                                                                 
 var tmp273937876: Array.Queue.T;                                                                   
 var tmp243937554: int;                                                                             
 var Array.Queue.T._length3937768: [Array.Queue.T]int;                                              
 var tmp243937609: int;                                                                             
 var Queue.head3937880: [Queue]int;                                                                 
 var tmp373937720: int;                                                                             
 var Array.Queue.T._elems3937754: [Array.Queue.T]([int]int);                                        
 var tmp373937754: int;                                                                             
 var $recorded.state3937876: int;                                                                   
 var Queue._lock3937821: [Queue]Tid;                                                                
 var tmp21: bool;                                                                                   
 var Queue._lock3937638: [Queue]Tid;                                                                
 var tmp213937568: bool;                                                                            
 var $recorded.state3937670: int;                                                                   
 var tmp283937866: int;                                                                             
 var Queue.tail3937638: [Queue]int;                                                                 
 var tmp303937621: int;                                                                             
 var this3937880: Queue;                                                                            
 var tmp383937754: int;                                                                             
 var $result3937889: int;                                                                           
 var tmp51: Seq.int;                                                                                
 var $recorded.state3937554: int;                                                                   
 var tmp323937638: Array.Queue.T;                                                                   
 var tmp243937895: int;                                                                             
 var Queue.tail3937876: [Queue]int;                                                                 
 var tmp293937720: int;                                                                             
 var tmp523937866: int;                                                                             
 var tmp453937834: int;                                                                             
 var tmp263937857: Seq.int;                                                                         
 var $recorded.state3937660: int;                                                                   
 var _pc3937660: Phase;                                                                             
 var tmp313937660: int;                                                                             
 var tmp323937834: Array.Queue.T;                                                                   
 var tmp253937821: int;                                                                             
 var tmp393937703: int;                                                                             
 var Queue.tail3937595: [Queue]int;                                                                 
 var tmp363937821: Array.Queue.T;                                                                   
 var $result3937568: int;                                                                           
 var tmp383937720: int;                                                                             
 var Queue.elems3937720: [Queue]Array.Queue.T;                                                      
 var tmp413937744: int;                                                                             
 var tmp353937684: Seq.int;                                                                         
 var Array.Queue.T._elems3937660: [Array.Queue.T]([int]int);                                        
 var $recorded.state3937725: int;                                                                   
 var tmp213937670: bool;                                                                            
 var Queue.tail3937684: [Queue]int;                                                                 
 var tmp373937725: int;                                                                             
 var Queue.spec3937684: [Queue]Seq.int;                                                             
 var tmp493937834: int;                                                                             
 var Queue.tail3937693: [Queue]int;                                                                 
 var tmp313937754: int;                                                                             
 var tmp313937834: int;                                                                             
 var tmp223937744: int;                                                                             
 var tmp333937655: int;                                                                             
 var tmp223937720: int;                                                                             
 var tmp233937684: int;                                                                             
 var tmp223937693: int;                                                                             
 var tmp313937768: int;                                                                             
 var Array.Queue.T._state3937821: [Array.Queue.T]State;                                             
 var tmp363937744: Array.Queue.T;                                                                   
 var tmp44: int;                                                                                    
 var Queue.tail3937720: [Queue]int;                                                                 
 var moverPath3937768: MoverPath;                                                                   
 var result3937821: int;                                                                            
 var Array.Queue.T._elems3937821: [Array.Queue.T]([int]int);                                        
 var $recorded.state3937693: int;                                                                   
 var Queue._state3937834: [Queue]State;                                                             
 var tmp34: int;                                                                                    
 var tmp343937684: int;                                                                             
 var $recorded.state3937720: int;                                                                   
 var this3937857: Queue;                                                                            
 var tmp283937876: int;                                                                             
 var Array.Queue.T._state3937609: [Array.Queue.T]State;                                             
 var tmp393937834: int;                                                                             
 var Array.Queue.T._elems3937866: [Array.Queue.T]([int]int);                                        
 var tmp49: int;                                                                                    
 var tmp263937821: Seq.int;                                                                         
 var Array.Queue.T._state3937621: [Array.Queue.T]State;                                             
 var Array.Queue.T._elems3937684: [Array.Queue.T]([int]int);                                        
 var tmp283937660: int;                                                                             
 var tmp373937744: int;                                                                             
 var tmp383937834: int;                                                                             
 var tmp323937821: Array.Queue.T;                                                                   
 var this3937568_post: Queue;                                                                       
 var tmp383937693: int;                                                                             
 var tmp243937703: int;                                                                             
 var tmp373937821: int;                                                                             
 var Queue.elems3937684: [Queue]Array.Queue.T;                                                      
 var tmp213937889: bool;                                                                            
 var tmp323937768: Array.Queue.T;                                                                   
 var tmp343937670: int;                                                                             
 var $recorded.state3937889: int;                                                                   
 var Queue.spec3937857: [Queue]Seq.int;                                                             
 var tmp253937876: int;                                                                             
 var tmp303937684: int;                                                                             
 var this3937609: Queue;                                                                            
 var tmp373937703: int;                                                                             
 var tmp393937857: int;                                                                             
 var tmp263937720: Seq.int;                                                                         
 var tid3937548: Tid;                                                                               
 var $recorded.state3937621: int;                                                                   
 var $result3937754: int;                                                                           
 var $result3937568_post: int;                                                                      
 var tmp233937821: int;                                                                             
 var Queue.head3937754: [Queue]int;                                                                 
 var tmp363937834: Array.Queue.T;                                                                   
 var Array.Queue.T._length3937725: [Array.Queue.T]int;                                              
 var Array.Queue.T._elems3937693: [Array.Queue.T]([int]int);                                        
 var path3937655: int;                                                                              
 var tmp233937876: int;                                                                             
 var Array.Queue.T._state3937768: [Array.Queue.T]State;                                             
 var result3937744: int;                                                                            
 var _pc3937621: Phase;                                                                             
 var tmp323937720: Array.Queue.T;                                                                   
 var mover3937857: Mover;                                                                           
 var tmp213937876: bool;                                                                            
 var tmp303937720: int;                                                                             
 var Queue._state3937660: [Queue]State;                                                             
 var tmp443937834: int;                                                                             
 var Queue.elems3937754: [Queue]Array.Queue.T;                                                      
 var tmp223937670: int;                                                                             
 var tid3937568: Tid;                                                                               
 var tmp263937595: Seq.int;                                                                         
 var tmp463937754: Array.Queue.T;                                                                   
 var tmp373937768: int;                                                                             
 var tmp373937834: int;                                                                             
 var tmp213937548: bool;                                                                            
 var Queue._lock3937876: [Queue]Tid;                                                                
 var Queue._state3937638: [Queue]State;                                                             
 var _pc3937821: Phase;                                                                             
 var tmp423937754: Array.Queue.T;                                                                   
 var tmp273937866: Array.Queue.T;                                                                   
 var tmp363937866: Array.Queue.T;                                                                   
 var path3937754: int;                                                                              
 var Array.Queue.T._elems3937595: [Array.Queue.T]([int]int);                                        
 var tmp35: Seq.int;                                                                                
 var Queue._lock3937595: [Queue]Tid;                                                                
 var tmp263937768: Seq.int;                                                                         
 var Queue.elems3937889: [Queue]Array.Queue.T;                                                      
 var tmp223937655: int;                                                                             
 var tmp453937768: int;                                                                             
 var tmp333937857: int;                                                                             
 var Array.Queue.T._length3937693: [Array.Queue.T]int;                                              
 var tmp323937670: Array.Queue.T;                                                                   
 var Array.Queue.T._elems3937880: [Array.Queue.T]([int]int);                                        
 var Queue.tail3937725: [Queue]int;                                                                 
 var tmp213937660: bool;                                                                            
 var tmp253937880: int;                                                                             
 var this3937876: Queue;                                                                            
 var mover3937554: Mover;                                                                           
 var Queue._lock3937768: [Queue]Tid;                                                                
 var Array.Queue.T._length3937548: [Array.Queue.T]int;                                              
 var result3937857: int;                                                                            
 var Queue.head3937621: [Queue]int;                                                                 
 var tid3937568_post: Tid;                                                                          
 var tmp253937693: int;                                                                             
 var tmp443937821: int;                                                                             
 var tmp24: int;                                                                                    
 var tmp363937754: Array.Queue.T;                                                                   
 var tmp353937725: Seq.int;                                                                         
 var moverPath3937744: MoverPath;                                                                   
 var Array.Queue.T._elems3937876: [Array.Queue.T]([int]int);                                        
 var tmp293937684: int;                                                                             
 var Queue.head3937655: [Queue]int;                                                                 
 var moverPath3937595: MoverPath;                                                                   
 var tmp393937725: int;                                                                             
 var Array.Queue.T._state3937857: [Array.Queue.T]State;                                             
 var tmp50: int;                                                                                    
 var Queue.head3937744: [Queue]int;                                                                 
 var Queue.elems3937655: [Queue]Array.Queue.T;                                                      
 var tmp393937876: int;                                                                             
 var tmp383937768: int;                                                                             
 var tmp313937670: int;                                                                             
 var moverPath3937735: MoverPath;                                                                   
 var Queue.tail3937821: [Queue]int;                                                                 
 var tmp503937866: int;                                                                             
 var $recorded.state3937895: int;                                                                   
 var tmp353937744: Seq.int;                                                                         
 var tmp33: int;                                                                                    
 var this3937621: Queue;                                                                            
 var result3937754: int;                                                                            
 var Queue.spec3937725: [Queue]Seq.int;                                                             
 var Queue._lock3937880: [Queue]Tid;                                                                
 var mover3937638: Mover;                                                                           
 var tmp233937568_post: int;                                                                        
 var _pc3937684: Phase;                                                                             
 var _pc3937720: Phase;                                                                             
 var tmp293937693: int;                                                                             
 var Queue._lock3937684: [Queue]Tid;                                                                
 var result3937834: int;                                                                            
 var tmp253937595: int;                                                                             
 var Array.Queue.T._elems3937857: [Array.Queue.T]([int]int);                                        
 var result3937735: int;                                                                            
 var Queue.tail3937857: [Queue]int;                                                                 
 var tmp273937655: Array.Queue.T;                                                                   
 var tmp233937703: int;                                                                             
 var mover3937735: Mover;                                                                           
 var Array.Queue.T._elems3937735: [Array.Queue.T]([int]int);                                        
 var tmp263937638: Seq.int;                                                                         
 var this3937725: Queue;                                                                            
 var tmp223937821: int;                                                                             
 var tmp243937720: int;                                                                             
 var tmp213937720: bool;                                                                            
 var tmp233937735: int;                                                                             
 var Array.Queue.T._elems3937638: [Array.Queue.T]([int]int);                                        
 var Queue.head3937548: [Queue]int;                                                                 
 var tmp373937857: int;                                                                             
 var tmp423937735: Array.Queue.T;                                                                   
 var _pc3937548: Phase;                                                                             
 var path3937834: int;                                                                              
 var Array.Queue.T._elems3937670: [Array.Queue.T]([int]int);                                        
 var tmp293937621: int;                                                                             
 var Array.Queue.T._state3937889: [Array.Queue.T]State;                                             
 var Queue.tail3937895: [Queue]int;                                                                 
 var tmp353937670: Seq.int;                                                                         
 var tmp283937857: int;                                                                             
 var $result3937876: int;                                                                           
 var Queue.elems3937638: [Queue]Array.Queue.T;                                                      
 var Queue.tail3937621: [Queue]int;                                                                 
 var $result3937693: int;                                                                           
 var tmp213937684: bool;                                                                            
 var tmp36: Array.Queue.T;                                                                          
 var Queue._lock3937655: [Queue]Tid;                                                                
 var this3937889: Queue;                                                                            
 var tmp503937834: int;                                                                             
 var tmp333937866: int;                                                                             
 var tmp263937834: Seq.int;                                                                         
 var tmp293937660: int;                                                                             
 var tmp213937655: bool;                                                                            
 var tmp493937876: int;                                                                             
 var tmp413937876: int;                                                                             
 var tmp283937693: int;                                                                             
 var Queue.elems3937660: [Queue]Array.Queue.T;                                                      
 var tmp32: Array.Queue.T;                                                                          
 var tmp373937693: int;                                                                             
 var tmp473937857: Seq.int;                                                                         
 var tmp46: Array.Queue.T;                                                                          
 var tmp52: int;                                                                                    
 var tmp313937655: int;                                                                             
 var tmp313937638: int;                                                                             
 var Queue.spec3937655: [Queue]Seq.int;                                                             
 var Queue.spec3937638: [Queue]Seq.int;                                                             
 var tmp323937866: Array.Queue.T;                                                                   
 var tmp303937670: int;                                                                             
 var tmp443937866: int;                                                                             
 var mover3937720: Mover;                                                                           
 var tmp333937768: int;                                                                             
 var tmp263937703: Seq.int;                                                                         
 var tmp25: int;                                                                                    
 var _pc3937880: Phase;                                                                             
 var path3937768: int;                                                                              
 var moverPath3937703: MoverPath;                                                                   
 var Queue._lock3937660: [Queue]Tid;                                                                
 var tmp243937880: int;                                                                             
 var tmp293937735: int;                                                                             
 var Queue._lock3937895: [Queue]Tid;                                                                
 var tmp333937880: int;                                                                             
 var tmp363937768: Array.Queue.T;                                                                   
 var moverPath3937554: MoverPath;                                                                   
 var tid3937768: Tid;                                                                               
 var Queue.spec3937720: [Queue]Seq.int;                                                             
 var tmp233937548: int;                                                                             
 var Queue._lock3937720: [Queue]Tid;                                                                
 var tmp413937768: int;                                                                             
 var tmp363937693: Array.Queue.T;                                                                   
 var tmp363937876: Array.Queue.T;                                                                   
 var Queue.spec3937768: [Queue]Seq.int;                                                             
 var tmp223937857: int;                                                                             
 var result3937880: int;                                                                            
 var tmp233937725: int;                                                                             
 var moverPath3937684: MoverPath;                                                                   
 var tmp263937670: Seq.int;                                                                         
 var tmp41: int;                                                                                    
 var Queue._lock3937554: [Queue]Tid;                                                                
 var tmp243937754: int;                                                                             
 var tmp433937834: int;                                                                             
 var tmp313937876: int;                                                                             
 var tmp463937880: Array.Queue.T;                                                                   
 var tmp453937880: int;                                                                             
 var $result3937638: int;                                                                           
 var tmp273937834: Array.Queue.T;                                                                   
 var tmp53: int;                                                                                    
 var tmp29: int;                                                                                    
 var tmp223937754: int;                                                                             
 var result3937768: int;                                                                            
 var Queue.elems3937857: [Queue]Array.Queue.T;                                                      
 var tmp383937821: int;                                                                             
 var this3937568: Queue;                                                                            
 var Array.Queue.T._elems3937554: [Array.Queue.T]([int]int);                                        
 var tmp283937821: int;                                                                             
 var Array.Queue.T._state3937744: [Array.Queue.T]State;                                             
 var tid3937595: Tid;                                                                               
 var $result3937660: int;                                                                           
 var Array.Queue.T._length3937660: [Array.Queue.T]int;                                              
 var _pc3937834: Phase;                                                                             
 var tmp403937744: Array.Queue.T;                                                                   
 var $result3937655: int;                                                                           
 var Array.Queue.T._length3937554: [Array.Queue.T]int;                                              
 var Array.Queue.T._state3937876: [Array.Queue.T]State;                                             
 var _pc3937725: Phase;                                                                             
 var tmp31: int;                                                                                    
 var tmp273937821: Array.Queue.T;                                                                   
 var $recorded.state3937638: int;                                                                   
 var tmp363937703: Array.Queue.T;                                                                   
 var tmp343937703: int;                                                                             
 var Array.Queue.T._elems3937548: [Array.Queue.T]([int]int);                                        
 var Array.Queue.T._length3937720: [Array.Queue.T]int;                                              
 var tmp513937880: Seq.int;                                                                         
 var Array.Queue.T._length3937595: [Array.Queue.T]int;                                              
 var tmp273937660: Array.Queue.T;                                                                   
 var tmp283937725: int;                                                                             
 var this3937744: Queue;                                                                            
 var tmp253937684: int;                                                                             
 var tmp283937744: int;                                                                             
 var tmp493937880: int;                                                                             
 var tmp433937768: int;                                                                             
 var tmp213937609: bool;                                                                            
 var tmp393937866: int;                                                                             
 var tmp223937735: int;                                                                             
 var tmp383937857: int;                                                                             
 var tmp243937568: int;                                                                             
 var tmp343937768: int;                                                                             
 var tmp233937889: int;                                                                             
 var Queue.spec3937889: [Queue]Seq.int;                                                             
 var tmp303937703: int;                                                                             
 var tmp223937880: int;                                                                             
 var this3937655: Queue;                                                                            
 var Queue.tail3937660: [Queue]int;                                                                 
 var tmp45: int;                                                                                    
 var tmp333937754: int;                                                                             
 var tmp233937609: int;                                                                             
 var tmp383937703: int;                                                                             
 var tmp443937744: int;                                                                             
 var Queue._lock3937754: [Queue]Tid;                                                                
 var Queue.spec3937660: [Queue]Seq.int;                                                             
 var tid3937703: Tid;                                                                               
                                                                                                    
 var _pc : Phase;                                                                                   
 _pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (55.18): Can only have right-mover memory accesses in requires clause
                                                                                                    
                                                                                                    
 // 60.9: bool tmp21;                                                                               
                                                                                                    
                                                                                                    
 // 60.9: int tmp22;                                                                                
                                                                                                    
                                                                                                    
 // 60.9: int tmp23;                                                                                
                                                                                                    
                                                                                                    
 // 60.9: tmp23 := this.tail;                                                                       
                                                                                                    
                                                                                                    
 moverPath3937548 := ReadEval.Queue.tail(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937548 := m#moverPath(moverPath3937548);                                                     
 path3937548 := p#moverPath(moverPath3937548);                                                      
 assume Queue._state3937548 == Queue._state && Queue.elems3937548 == Queue.elems && Queue.head3937548 == Queue.head && Queue.tail3937548 == Queue.tail && Queue.spec3937548 == Queue.spec && Queue._lock3937548 == Queue._lock && Array.Queue.T._state3937548 == Array.Queue.T._state && Array.Queue.T._elems3937548 == Array.Queue.T._elems && Array.Queue.T._length3937548 == Array.Queue.T._length && tmp233937548 == tmp23 && tmp223937548 == tmp22 && tmp213937548 == tmp21 && $result3937548 == $result && this3937548 == this && tid3937548 == tid && _pc3937548 == _pc;
 assume $recorded.state3937548 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (60.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 _pc := transition(_pc, mover3937548);                                                              
 assert _pc != PhaseError;                                                                                 // (60.9): Reduction failure
 tmp23 := Queue.tail[this];                                                                         
                                                                                                    
 // 60.9: int tmp24;                                                                                
                                                                                                    
                                                                                                    
 // 60.9: tmp24 := this.head;                                                                       
                                                                                                    
                                                                                                    
 moverPath3937554 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 mover3937554 := m#moverPath(moverPath3937554);                                                     
 path3937554 := p#moverPath(moverPath3937554);                                                      
 assume Queue._state3937554 == Queue._state && Queue.elems3937554 == Queue.elems && Queue.head3937554 == Queue.head && Queue.tail3937554 == Queue.tail && Queue.spec3937554 == Queue.spec && Queue._lock3937554 == Queue._lock && Array.Queue.T._state3937554 == Array.Queue.T._state && Array.Queue.T._elems3937554 == Array.Queue.T._elems && Array.Queue.T._length3937554 == Array.Queue.T._length && tmp243937554 == tmp24 && tmp233937554 == tmp23 && tmp223937554 == tmp22 && tmp213937554 == tmp21 && $result3937554 == $result && this3937554 == this && tid3937554 == tid && _pc3937554 == _pc;
 assume $recorded.state3937554 == 1;                                                                
 if (_pc == PreCommit) {                                                                            
  assume this != Queue.null;                                                                        
 } else {                                                                                           
  assert this != Queue.null;                                                                               // (60.9): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 _pc := transition(_pc, mover3937554);                                                              
 assert _pc != PhaseError;                                                                                 // (60.9): Reduction failure
 tmp24 := Queue.head[this];                                                                         
                                                                                                    
 // 60.9: tmp22 = tmp23 - tmp24;                                                                    
                                                                                                    
 tmp22 := (tmp23-tmp24);                                                                            
                                                                                                    
 // 60.9: tmp21 = tmp22 > 0;                                                                        
                                                                                                    
 tmp21 := (tmp22>0);                                                                                
 if (tmp21 /* lowered ((Queue.tail[this]-Queue.head[this])>0) */) {                                 
                                                                                                    
  // 61.12: yield;                                                                                  
                                                                                                    
  assume Queue._state3937568 == Queue._state && Queue.elems3937568 == Queue.elems && Queue.head3937568 == Queue.head && Queue.tail3937568 == Queue.tail && Queue.spec3937568 == Queue.spec && Queue._lock3937568 == Queue._lock && Array.Queue.T._state3937568 == Array.Queue.T._state && Array.Queue.T._elems3937568 == Array.Queue.T._elems && Array.Queue.T._length3937568 == Array.Queue.T._length && tmp243937568 == tmp24 && tmp233937568 == tmp23 && tmp223937568 == tmp22 && tmp213937568 == tmp21 && $result3937568 == $result && this3937568 == this && tid3937568 == tid;
  assume $recorded.state3937568 == 1;                                                               
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  call Yield(tid);                                                                                  
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  assume  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (61.12): Object invariant may not hold.
  _pc := PreCommit;                                                                                 
  assume Queue._state3937568_post == Queue._state && Queue.elems3937568_post == Queue.elems && Queue.head3937568_post == Queue.head && Queue.tail3937568_post == Queue.tail && Queue.spec3937568_post == Queue.spec && Queue._lock3937568_post == Queue._lock && Array.Queue.T._state3937568_post == Array.Queue.T._state && Array.Queue.T._elems3937568_post == Array.Queue.T._elems && Array.Queue.T._length3937568_post == Array.Queue.T._length && tmp243937568_post == tmp24 && tmp233937568_post == tmp23 && tmp223937568_post == tmp22 && tmp213937568_post == tmp21 && $result3937568_post == $result && this3937568_post == this && tid3937568_post == tid;
  assume $recorded.state3937568_post == 1;                                                          
                                                                                                    
  // 62.13: assume !(NextSpecStep(0));                                                              
                                                                                                    
  assume !(true);                                                                                   
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (63.27): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assume Queue._lock[this] == Tid.null;                                                             
  _pc := transition(_pc, _R);                                                                       
  assert _pc != PhaseError;                                                                                // (63.27): Reduction failure
  Queue._lock[this] := tid;                                                                         
                                                                                                    
  // 64.17: assume this.tail - this.head > 0;                                                       
                                                                                                    
  assume ((Queue.tail[this]-Queue.head[this])>0);                                                   
                                                                                                    
  // 65.21: int tmp25;                                                                              
                                                                                                    
                                                                                                    
  // 65.21: Seq<int> tmp26;                                                                         
                                                                                                    
                                                                                                    
  // 65.21: tmp26 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937595 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937595 := m#moverPath(moverPath3937595);                                                    
  path3937595 := p#moverPath(moverPath3937595);                                                     
  assume Queue._state3937595 == Queue._state && Queue.elems3937595 == Queue.elems && Queue.head3937595 == Queue.head && Queue.tail3937595 == Queue.tail && Queue.spec3937595 == Queue.spec && Queue._lock3937595 == Queue._lock && Array.Queue.T._state3937595 == Array.Queue.T._state && Array.Queue.T._elems3937595 == Array.Queue.T._elems && Array.Queue.T._length3937595 == Array.Queue.T._length && tmp263937595 == tmp26 && tmp253937595 == tmp25 && tmp243937595 == tmp24 && tmp233937595 == tmp23 && tmp223937595 == tmp22 && tmp213937595 == tmp21 && $result3937595 == $result && this3937595 == this && tid3937595 == tid && _pc3937595 == _pc;
  assume $recorded.state3937595 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (65.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937595);                                                             
  assert _pc != PhaseError;                                                                                // (65.21): Reduction failure
  tmp26 := Queue.spec[this];                                                                        
                                                                                                    
  // 65.21: tmp25 = SeqNth<int>(tmp26,0);                                                           
                                                                                                    
  tmp25 := SeqNth.int(tmp26,0);                                                                     
                                                                                                    
  // 65.21: [Queue.T{this}] tmp27;                                                                  
                                                                                                    
                                                                                                    
  // 65.21: tmp27 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937609 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937609 := m#moverPath(moverPath3937609);                                                    
  path3937609 := p#moverPath(moverPath3937609);                                                     
  assume Queue._state3937609 == Queue._state && Queue.elems3937609 == Queue.elems && Queue.head3937609 == Queue.head && Queue.tail3937609 == Queue.tail && Queue.spec3937609 == Queue.spec && Queue._lock3937609 == Queue._lock && Array.Queue.T._state3937609 == Array.Queue.T._state && Array.Queue.T._elems3937609 == Array.Queue.T._elems && Array.Queue.T._length3937609 == Array.Queue.T._length && tmp273937609 == tmp27 && tmp263937609 == tmp26 && tmp253937609 == tmp25 && tmp243937609 == tmp24 && tmp233937609 == tmp23 && tmp223937609 == tmp22 && tmp213937609 == tmp21 && $result3937609 == $result && this3937609 == this && tid3937609 == tid && _pc3937609 == _pc;
  assume $recorded.state3937609 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (65.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937609);                                                             
  assert _pc != PhaseError;                                                                                // (65.21): Reduction failure
  tmp27 := Queue.elems[this];                                                                       
                                                                                                    
  // 65.21: int tmp28;                                                                              
                                                                                                    
                                                                                                    
  // 65.21: int tmp29;                                                                              
                                                                                                    
                                                                                                    
  // 65.21: int tmp30;                                                                              
                                                                                                    
                                                                                                    
  // 65.21: tmp30 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937621 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937621 := m#moverPath(moverPath3937621);                                                    
  path3937621 := p#moverPath(moverPath3937621);                                                     
  assume Queue._state3937621 == Queue._state && Queue.elems3937621 == Queue.elems && Queue.head3937621 == Queue.head && Queue.tail3937621 == Queue.tail && Queue.spec3937621 == Queue.spec && Queue._lock3937621 == Queue._lock && Array.Queue.T._state3937621 == Array.Queue.T._state && Array.Queue.T._elems3937621 == Array.Queue.T._elems && Array.Queue.T._length3937621 == Array.Queue.T._length && tmp303937621 == tmp30 && tmp293937621 == tmp29 && tmp283937621 == tmp28 && tmp273937621 == tmp27 && tmp263937621 == tmp26 && tmp253937621 == tmp25 && tmp243937621 == tmp24 && tmp233937621 == tmp23 && tmp223937621 == tmp22 && tmp213937621 == tmp21 && $result3937621 == $result && this3937621 == this && tid3937621 == tid && _pc3937621 == _pc;
  assume $recorded.state3937621 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (65.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937621);                                                             
  assert _pc != PhaseError;                                                                                // (65.21): Reduction failure
  tmp30 := Queue.head[this];                                                                        
                                                                                                    
  // 65.21: tmp29 = tmp30 + 0;                                                                      
                                                                                                    
  tmp29 := (tmp30+0);                                                                               
                                                                                                    
  // 65.21: int tmp31;                                                                              
                                                                                                    
                                                                                                    
  // 65.21: [Queue.T{this}] tmp32;                                                                  
                                                                                                    
                                                                                                    
  // 65.21: tmp32 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937638 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937638 := m#moverPath(moverPath3937638);                                                    
  path3937638 := p#moverPath(moverPath3937638);                                                     
  assume Queue._state3937638 == Queue._state && Queue.elems3937638 == Queue.elems && Queue.head3937638 == Queue.head && Queue.tail3937638 == Queue.tail && Queue.spec3937638 == Queue.spec && Queue._lock3937638 == Queue._lock && Array.Queue.T._state3937638 == Array.Queue.T._state && Array.Queue.T._elems3937638 == Array.Queue.T._elems && Array.Queue.T._length3937638 == Array.Queue.T._length && tmp323937638 == tmp32 && tmp313937638 == tmp31 && tmp303937638 == tmp30 && tmp293937638 == tmp29 && tmp283937638 == tmp28 && tmp273937638 == tmp27 && tmp263937638 == tmp26 && tmp253937638 == tmp25 && tmp243937638 == tmp24 && tmp233937638 == tmp23 && tmp223937638 == tmp22 && tmp213937638 == tmp21 && $result3937638 == $result && this3937638 == this && tid3937638 == tid && _pc3937638 == _pc;
  assume $recorded.state3937638 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (65.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937638);                                                             
  assert _pc != PhaseError;                                                                                // (65.21): Reduction failure
  tmp32 := Queue.elems[this];                                                                       
                                                                                                    
  // 65.21: tmp31 = tmp32.length;                                                                   
                                                                                                    
  tmp31 := Array.Queue.T._length[tmp32];                                                            
                                                                                                    
  // 65.21: tmp28 = tmp29 % tmp31;                                                                  
                                                                                                    
  tmp28 := MOD(tmp29, tmp31);                                                                       
                                                                                                    
  // 65.21: int tmp33;                                                                              
                                                                                                    
                                                                                                    
  // 65.21: tmp33 := tmp27[tmp28];                                                                  
                                                                                                    
                                                                                                    
  moverPath3937655 := ReadEval.Array.Queue.T(tid: Tid,this: Queue,tmp27: Array.Queue.T,tmp28: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937655 := m#moverPath(moverPath3937655);                                                    
  path3937655 := p#moverPath(moverPath3937655);                                                     
  assume Queue._state3937655 == Queue._state && Queue.elems3937655 == Queue.elems && Queue.head3937655 == Queue.head && Queue.tail3937655 == Queue.tail && Queue.spec3937655 == Queue.spec && Queue._lock3937655 == Queue._lock && Array.Queue.T._state3937655 == Array.Queue.T._state && Array.Queue.T._elems3937655 == Array.Queue.T._elems && Array.Queue.T._length3937655 == Array.Queue.T._length && tmp333937655 == tmp33 && tmp323937655 == tmp32 && tmp313937655 == tmp31 && tmp303937655 == tmp30 && tmp293937655 == tmp29 && tmp283937655 == tmp28 && tmp273937655 == tmp27 && tmp263937655 == tmp26 && tmp253937655 == tmp25 && tmp243937655 == tmp24 && tmp233937655 == tmp23 && tmp223937655 == tmp22 && tmp213937655 == tmp21 && $result3937655 == $result && this3937655 == this && tid3937655 == tid && _pc3937655 == _pc;
  assume $recorded.state3937655 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp27 != Array.Queue.T.null;                                                              
  } else {                                                                                          
   assert tmp27 != Array.Queue.T.null;                                                                     // (65.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp28;                                                                               
  } else {                                                                                          
   assert 0 <= tmp28;                                                                                      // (65.21): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp28 < Array.Queue.T._length[tmp27];                                                     
  } else {                                                                                          
   assert tmp28 < Array.Queue.T._length[tmp27];                                                            // (65.21): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937655);                                                             
  assert _pc != PhaseError;                                                                                // (65.21): Reduction failure
  tmp33 := Array.Queue.T._elems[tmp27][tmp28];                                                      
                                                                                                    
  // 65.21: assert tmp25 == tmp33;                                                                  
                                                                                                    
  assume Queue._state3937660 == Queue._state && Queue.elems3937660 == Queue.elems && Queue.head3937660 == Queue.head && Queue.tail3937660 == Queue.tail && Queue.spec3937660 == Queue.spec && Queue._lock3937660 == Queue._lock && Array.Queue.T._state3937660 == Array.Queue.T._state && Array.Queue.T._elems3937660 == Array.Queue.T._elems && Array.Queue.T._length3937660 == Array.Queue.T._length && tmp333937660 == tmp33 && tmp323937660 == tmp32 && tmp313937660 == tmp31 && tmp303937660 == tmp30 && tmp293937660 == tmp29 && tmp283937660 == tmp28 && tmp273937660 == tmp27 && tmp263937660 == tmp26 && tmp253937660 == tmp25 && tmp243937660 == tmp24 && tmp233937660 == tmp23 && tmp223937660 == tmp22 && tmp213937660 == tmp21 && $result3937660 == $result && this3937660 == this && tid3937660 == tid;
  assume $recorded.state3937660 == 1;                                                               
  assert (tmp25==tmp33);                                                                                   // (65.21): This assertion may not hold.
                                                                                                    
  // 66.21: int tmp34;                                                                              
                                                                                                    
                                                                                                    
  // 66.21: Seq<int> tmp35;                                                                         
                                                                                                    
                                                                                                    
  // 66.21: tmp35 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937670 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937670 := m#moverPath(moverPath3937670);                                                    
  path3937670 := p#moverPath(moverPath3937670);                                                     
  assume Queue._state3937670 == Queue._state && Queue.elems3937670 == Queue.elems && Queue.head3937670 == Queue.head && Queue.tail3937670 == Queue.tail && Queue.spec3937670 == Queue.spec && Queue._lock3937670 == Queue._lock && Array.Queue.T._state3937670 == Array.Queue.T._state && Array.Queue.T._elems3937670 == Array.Queue.T._elems && Array.Queue.T._length3937670 == Array.Queue.T._length && tmp353937670 == tmp35 && tmp343937670 == tmp34 && tmp333937670 == tmp33 && tmp323937670 == tmp32 && tmp313937670 == tmp31 && tmp303937670 == tmp30 && tmp293937670 == tmp29 && tmp283937670 == tmp28 && tmp273937670 == tmp27 && tmp263937670 == tmp26 && tmp253937670 == tmp25 && tmp243937670 == tmp24 && tmp233937670 == tmp23 && tmp223937670 == tmp22 && tmp213937670 == tmp21 && $result3937670 == $result && this3937670 == this && tid3937670 == tid && _pc3937670 == _pc;
  assume $recorded.state3937670 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (66.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937670);                                                             
  assert _pc != PhaseError;                                                                                // (66.21): Reduction failure
  tmp35 := Queue.spec[this];                                                                        
                                                                                                    
  // 66.21: tmp34 = SeqNth<int>(tmp35,0);                                                           
                                                                                                    
  tmp34 := SeqNth.int(tmp35,0);                                                                     
                                                                                                    
  // 66.21: [Queue.T{this}] tmp36;                                                                  
                                                                                                    
                                                                                                    
  // 66.21: tmp36 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937684 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937684 := m#moverPath(moverPath3937684);                                                    
  path3937684 := p#moverPath(moverPath3937684);                                                     
  assume Queue._state3937684 == Queue._state && Queue.elems3937684 == Queue.elems && Queue.head3937684 == Queue.head && Queue.tail3937684 == Queue.tail && Queue.spec3937684 == Queue.spec && Queue._lock3937684 == Queue._lock && Array.Queue.T._state3937684 == Array.Queue.T._state && Array.Queue.T._elems3937684 == Array.Queue.T._elems && Array.Queue.T._length3937684 == Array.Queue.T._length && tmp363937684 == tmp36 && tmp353937684 == tmp35 && tmp343937684 == tmp34 && tmp333937684 == tmp33 && tmp323937684 == tmp32 && tmp313937684 == tmp31 && tmp303937684 == tmp30 && tmp293937684 == tmp29 && tmp283937684 == tmp28 && tmp273937684 == tmp27 && tmp263937684 == tmp26 && tmp253937684 == tmp25 && tmp243937684 == tmp24 && tmp233937684 == tmp23 && tmp223937684 == tmp22 && tmp213937684 == tmp21 && $result3937684 == $result && this3937684 == this && tid3937684 == tid && _pc3937684 == _pc;
  assume $recorded.state3937684 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (66.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937684);                                                             
  assert _pc != PhaseError;                                                                                // (66.21): Reduction failure
  tmp36 := Queue.elems[this];                                                                       
                                                                                                    
  // 66.21: int tmp37;                                                                              
                                                                                                    
                                                                                                    
  // 66.21: int tmp38;                                                                              
                                                                                                    
                                                                                                    
  // 66.21: tmp38 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937693 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937693 := m#moverPath(moverPath3937693);                                                    
  path3937693 := p#moverPath(moverPath3937693);                                                     
  assume Queue._state3937693 == Queue._state && Queue.elems3937693 == Queue.elems && Queue.head3937693 == Queue.head && Queue.tail3937693 == Queue.tail && Queue.spec3937693 == Queue.spec && Queue._lock3937693 == Queue._lock && Array.Queue.T._state3937693 == Array.Queue.T._state && Array.Queue.T._elems3937693 == Array.Queue.T._elems && Array.Queue.T._length3937693 == Array.Queue.T._length && tmp383937693 == tmp38 && tmp373937693 == tmp37 && tmp363937693 == tmp36 && tmp353937693 == tmp35 && tmp343937693 == tmp34 && tmp333937693 == tmp33 && tmp323937693 == tmp32 && tmp313937693 == tmp31 && tmp303937693 == tmp30 && tmp293937693 == tmp29 && tmp283937693 == tmp28 && tmp273937693 == tmp27 && tmp263937693 == tmp26 && tmp253937693 == tmp25 && tmp243937693 == tmp24 && tmp233937693 == tmp23 && tmp223937693 == tmp22 && tmp213937693 == tmp21 && $result3937693 == $result && this3937693 == this && tid3937693 == tid && _pc3937693 == _pc;
  assume $recorded.state3937693 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (66.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937693);                                                             
  assert _pc != PhaseError;                                                                                // (66.21): Reduction failure
  tmp38 := Queue.head[this];                                                                        
                                                                                                    
  // 66.21: int tmp39;                                                                              
                                                                                                    
                                                                                                    
  // 66.21: [Queue.T{this}] tmp40;                                                                  
                                                                                                    
                                                                                                    
  // 66.21: tmp40 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937703 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937703 := m#moverPath(moverPath3937703);                                                    
  path3937703 := p#moverPath(moverPath3937703);                                                     
  assume Queue._state3937703 == Queue._state && Queue.elems3937703 == Queue.elems && Queue.head3937703 == Queue.head && Queue.tail3937703 == Queue.tail && Queue.spec3937703 == Queue.spec && Queue._lock3937703 == Queue._lock && Array.Queue.T._state3937703 == Array.Queue.T._state && Array.Queue.T._elems3937703 == Array.Queue.T._elems && Array.Queue.T._length3937703 == Array.Queue.T._length && tmp403937703 == tmp40 && tmp393937703 == tmp39 && tmp383937703 == tmp38 && tmp373937703 == tmp37 && tmp363937703 == tmp36 && tmp353937703 == tmp35 && tmp343937703 == tmp34 && tmp333937703 == tmp33 && tmp323937703 == tmp32 && tmp313937703 == tmp31 && tmp303937703 == tmp30 && tmp293937703 == tmp29 && tmp283937703 == tmp28 && tmp273937703 == tmp27 && tmp263937703 == tmp26 && tmp253937703 == tmp25 && tmp243937703 == tmp24 && tmp233937703 == tmp23 && tmp223937703 == tmp22 && tmp213937703 == tmp21 && $result3937703 == $result && this3937703 == this && tid3937703 == tid && _pc3937703 == _pc;
  assume $recorded.state3937703 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (66.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937703);                                                             
  assert _pc != PhaseError;                                                                                // (66.21): Reduction failure
  tmp40 := Queue.elems[this];                                                                       
                                                                                                    
  // 66.21: tmp39 = tmp40.length;                                                                   
                                                                                                    
  tmp39 := Array.Queue.T._length[tmp40];                                                            
                                                                                                    
  // 66.21: tmp37 = tmp38 % tmp39;                                                                  
                                                                                                    
  tmp37 := MOD(tmp38, tmp39);                                                                       
                                                                                                    
  // 66.21: int tmp41;                                                                              
                                                                                                    
                                                                                                    
  // 66.21: tmp41 := tmp36[tmp37];                                                                  
                                                                                                    
                                                                                                    
  moverPath3937720 := ReadEval.Array.Queue.T(tid: Tid,this: Queue,tmp36: Array.Queue.T,tmp37: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937720 := m#moverPath(moverPath3937720);                                                    
  path3937720 := p#moverPath(moverPath3937720);                                                     
  assume Queue._state3937720 == Queue._state && Queue.elems3937720 == Queue.elems && Queue.head3937720 == Queue.head && Queue.tail3937720 == Queue.tail && Queue.spec3937720 == Queue.spec && Queue._lock3937720 == Queue._lock && Array.Queue.T._state3937720 == Array.Queue.T._state && Array.Queue.T._elems3937720 == Array.Queue.T._elems && Array.Queue.T._length3937720 == Array.Queue.T._length && tmp413937720 == tmp41 && tmp403937720 == tmp40 && tmp393937720 == tmp39 && tmp383937720 == tmp38 && tmp373937720 == tmp37 && tmp363937720 == tmp36 && tmp353937720 == tmp35 && tmp343937720 == tmp34 && tmp333937720 == tmp33 && tmp323937720 == tmp32 && tmp313937720 == tmp31 && tmp303937720 == tmp30 && tmp293937720 == tmp29 && tmp283937720 == tmp28 && tmp273937720 == tmp27 && tmp263937720 == tmp26 && tmp253937720 == tmp25 && tmp243937720 == tmp24 && tmp233937720 == tmp23 && tmp223937720 == tmp22 && tmp213937720 == tmp21 && $result3937720 == $result && this3937720 == this && tid3937720 == tid && _pc3937720 == _pc;
  assume $recorded.state3937720 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp36 != Array.Queue.T.null;                                                              
  } else {                                                                                          
   assert tmp36 != Array.Queue.T.null;                                                                     // (66.21): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp37;                                                                               
  } else {                                                                                          
   assert 0 <= tmp37;                                                                                      // (66.21): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp37 < Array.Queue.T._length[tmp36];                                                     
  } else {                                                                                          
   assert tmp37 < Array.Queue.T._length[tmp36];                                                            // (66.21): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937720);                                                             
  assert _pc != PhaseError;                                                                                // (66.21): Reduction failure
  tmp41 := Array.Queue.T._elems[tmp36][tmp37];                                                      
                                                                                                    
  // 66.21: assert tmp34 == tmp41;                                                                  
                                                                                                    
  assume Queue._state3937725 == Queue._state && Queue.elems3937725 == Queue.elems && Queue.head3937725 == Queue.head && Queue.tail3937725 == Queue.tail && Queue.spec3937725 == Queue.spec && Queue._lock3937725 == Queue._lock && Array.Queue.T._state3937725 == Array.Queue.T._state && Array.Queue.T._elems3937725 == Array.Queue.T._elems && Array.Queue.T._length3937725 == Array.Queue.T._length && tmp413937725 == tmp41 && tmp403937725 == tmp40 && tmp393937725 == tmp39 && tmp383937725 == tmp38 && tmp373937725 == tmp37 && tmp363937725 == tmp36 && tmp353937725 == tmp35 && tmp343937725 == tmp34 && tmp333937725 == tmp33 && tmp323937725 == tmp32 && tmp313937725 == tmp31 && tmp303937725 == tmp30 && tmp293937725 == tmp29 && tmp283937725 == tmp28 && tmp273937725 == tmp27 && tmp263937725 == tmp26 && tmp253937725 == tmp25 && tmp243937725 == tmp24 && tmp233937725 == tmp23 && tmp223937725 == tmp22 && tmp213937725 == tmp21 && $result3937725 == $result && this3937725 == this && tid3937725 == tid;
  assume $recorded.state3937725 == 1;                                                               
  assert (tmp34==tmp41);                                                                                   // (66.21): This assertion may not hold.
                                                                                                    
  // 67.17: int result;                                                                             
                                                                                                    
                                                                                                    
  // 67.17: [Queue.T{this}] tmp42;                                                                  
                                                                                                    
                                                                                                    
  // 67.17: tmp42 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937735 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937735 := m#moverPath(moverPath3937735);                                                    
  path3937735 := p#moverPath(moverPath3937735);                                                     
  assume Queue._state3937735 == Queue._state && Queue.elems3937735 == Queue.elems && Queue.head3937735 == Queue.head && Queue.tail3937735 == Queue.tail && Queue.spec3937735 == Queue.spec && Queue._lock3937735 == Queue._lock && Array.Queue.T._state3937735 == Array.Queue.T._state && Array.Queue.T._elems3937735 == Array.Queue.T._elems && Array.Queue.T._length3937735 == Array.Queue.T._length && tmp423937735 == tmp42 && result3937735 == result && tmp413937735 == tmp41 && tmp403937735 == tmp40 && tmp393937735 == tmp39 && tmp383937735 == tmp38 && tmp373937735 == tmp37 && tmp363937735 == tmp36 && tmp353937735 == tmp35 && tmp343937735 == tmp34 && tmp333937735 == tmp33 && tmp323937735 == tmp32 && tmp313937735 == tmp31 && tmp303937735 == tmp30 && tmp293937735 == tmp29 && tmp283937735 == tmp28 && tmp273937735 == tmp27 && tmp263937735 == tmp26 && tmp253937735 == tmp25 && tmp243937735 == tmp24 && tmp233937735 == tmp23 && tmp223937735 == tmp22 && tmp213937735 == tmp21 && $result3937735 == $result && this3937735 == this && tid3937735 == tid && _pc3937735 == _pc;
  assume $recorded.state3937735 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (67.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937735);                                                             
  assert _pc != PhaseError;                                                                                // (67.17): Reduction failure
  tmp42 := Queue.elems[this];                                                                       
                                                                                                    
  // 67.17: int tmp43;                                                                              
                                                                                                    
                                                                                                    
  // 67.17: int tmp44;                                                                              
                                                                                                    
                                                                                                    
  // 67.17: tmp44 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937744 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937744 := m#moverPath(moverPath3937744);                                                    
  path3937744 := p#moverPath(moverPath3937744);                                                     
  assume Queue._state3937744 == Queue._state && Queue.elems3937744 == Queue.elems && Queue.head3937744 == Queue.head && Queue.tail3937744 == Queue.tail && Queue.spec3937744 == Queue.spec && Queue._lock3937744 == Queue._lock && Array.Queue.T._state3937744 == Array.Queue.T._state && Array.Queue.T._elems3937744 == Array.Queue.T._elems && Array.Queue.T._length3937744 == Array.Queue.T._length && tmp443937744 == tmp44 && tmp433937744 == tmp43 && tmp423937744 == tmp42 && result3937744 == result && tmp413937744 == tmp41 && tmp403937744 == tmp40 && tmp393937744 == tmp39 && tmp383937744 == tmp38 && tmp373937744 == tmp37 && tmp363937744 == tmp36 && tmp353937744 == tmp35 && tmp343937744 == tmp34 && tmp333937744 == tmp33 && tmp323937744 == tmp32 && tmp313937744 == tmp31 && tmp303937744 == tmp30 && tmp293937744 == tmp29 && tmp283937744 == tmp28 && tmp273937744 == tmp27 && tmp263937744 == tmp26 && tmp253937744 == tmp25 && tmp243937744 == tmp24 && tmp233937744 == tmp23 && tmp223937744 == tmp22 && tmp213937744 == tmp21 && $result3937744 == $result && this3937744 == this && tid3937744 == tid && _pc3937744 == _pc;
  assume $recorded.state3937744 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (67.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937744);                                                             
  assert _pc != PhaseError;                                                                                // (67.17): Reduction failure
  tmp44 := Queue.head[this];                                                                        
                                                                                                    
  // 67.17: int tmp45;                                                                              
                                                                                                    
                                                                                                    
  // 67.17: [Queue.T{this}] tmp46;                                                                  
                                                                                                    
                                                                                                    
  // 67.17: tmp46 := this.elems;                                                                    
                                                                                                    
                                                                                                    
  moverPath3937754 := ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937754 := m#moverPath(moverPath3937754);                                                    
  path3937754 := p#moverPath(moverPath3937754);                                                     
  assume Queue._state3937754 == Queue._state && Queue.elems3937754 == Queue.elems && Queue.head3937754 == Queue.head && Queue.tail3937754 == Queue.tail && Queue.spec3937754 == Queue.spec && Queue._lock3937754 == Queue._lock && Array.Queue.T._state3937754 == Array.Queue.T._state && Array.Queue.T._elems3937754 == Array.Queue.T._elems && Array.Queue.T._length3937754 == Array.Queue.T._length && tmp463937754 == tmp46 && tmp453937754 == tmp45 && tmp443937754 == tmp44 && tmp433937754 == tmp43 && tmp423937754 == tmp42 && result3937754 == result && tmp413937754 == tmp41 && tmp403937754 == tmp40 && tmp393937754 == tmp39 && tmp383937754 == tmp38 && tmp373937754 == tmp37 && tmp363937754 == tmp36 && tmp353937754 == tmp35 && tmp343937754 == tmp34 && tmp333937754 == tmp33 && tmp323937754 == tmp32 && tmp313937754 == tmp31 && tmp303937754 == tmp30 && tmp293937754 == tmp29 && tmp283937754 == tmp28 && tmp273937754 == tmp27 && tmp263937754 == tmp26 && tmp253937754 == tmp25 && tmp243937754 == tmp24 && tmp233937754 == tmp23 && tmp223937754 == tmp22 && tmp213937754 == tmp21 && $result3937754 == $result && this3937754 == this && tid3937754 == tid && _pc3937754 == _pc;
  assume $recorded.state3937754 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (67.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937754);                                                             
  assert _pc != PhaseError;                                                                                // (67.17): Reduction failure
  tmp46 := Queue.elems[this];                                                                       
                                                                                                    
  // 67.17: tmp45 = tmp46.length;                                                                   
                                                                                                    
  tmp45 := Array.Queue.T._length[tmp46];                                                            
                                                                                                    
  // 67.17: tmp43 = tmp44 % tmp45;                                                                  
                                                                                                    
  tmp43 := MOD(tmp44, tmp45);                                                                       
                                                                                                    
  // 67.17: result := tmp42[tmp43];                                                                 
                                                                                                    
                                                                                                    
  moverPath3937768 := ReadEval.Array.Queue.T(tid: Tid,this: Queue,tmp42: Array.Queue.T,tmp43: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937768 := m#moverPath(moverPath3937768);                                                    
  path3937768 := p#moverPath(moverPath3937768);                                                     
  assume Queue._state3937768 == Queue._state && Queue.elems3937768 == Queue.elems && Queue.head3937768 == Queue.head && Queue.tail3937768 == Queue.tail && Queue.spec3937768 == Queue.spec && Queue._lock3937768 == Queue._lock && Array.Queue.T._state3937768 == Array.Queue.T._state && Array.Queue.T._elems3937768 == Array.Queue.T._elems && Array.Queue.T._length3937768 == Array.Queue.T._length && tmp463937768 == tmp46 && tmp453937768 == tmp45 && tmp443937768 == tmp44 && tmp433937768 == tmp43 && tmp423937768 == tmp42 && result3937768 == result && tmp413937768 == tmp41 && tmp403937768 == tmp40 && tmp393937768 == tmp39 && tmp383937768 == tmp38 && tmp373937768 == tmp37 && tmp363937768 == tmp36 && tmp353937768 == tmp35 && tmp343937768 == tmp34 && tmp333937768 == tmp33 && tmp323937768 == tmp32 && tmp313937768 == tmp31 && tmp303937768 == tmp30 && tmp293937768 == tmp29 && tmp283937768 == tmp28 && tmp273937768 == tmp27 && tmp263937768 == tmp26 && tmp253937768 == tmp25 && tmp243937768 == tmp24 && tmp233937768 == tmp23 && tmp223937768 == tmp22 && tmp213937768 == tmp21 && $result3937768 == $result && this3937768 == this && tid3937768 == tid && _pc3937768 == _pc;
  assume $recorded.state3937768 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume tmp42 != Array.Queue.T.null;                                                              
  } else {                                                                                          
   assert tmp42 != Array.Queue.T.null;                                                                     // (67.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume 0 <= tmp43;                                                                               
  } else {                                                                                          
   assert 0 <= tmp43;                                                                                      // (67.17): index < 0.
  }                                                                                                 
  if (_pc == PreCommit) {                                                                           
   assume tmp43 < Array.Queue.T._length[tmp42];                                                     
  } else {                                                                                          
   assert tmp43 < Array.Queue.T._length[tmp42];                                                            // (67.17): index is >= length.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937768);                                                             
  assert _pc != PhaseError;                                                                                // (67.17): Reduction failure
  result := Array.Queue.T._elems[tmp42][tmp43];                                                     
                                                                                                    
  // 68.17: assume forall int i ::0 <= i && i < this.tail - this.head ==> this.elems[this.head + i % this.elems.length] == SeqNth<int>(this.spec,i);
                                                                                                    
  assume (forall i: int ::  ((((0<=i)&&(i<(Queue.tail[this]-Queue.head[this])))==>(Array.Queue.T._elems[Queue.elems[this]][MOD((Queue.head[this]+i), Array.Queue.T._length[Queue.elems[this]])]==SeqNth.int(Queue.spec[this],i)))));
                                                                                                    
  // 70.17: Seq<int> tmp47;                                                                         
                                                                                                    
                                                                                                    
  // 70.17: Seq<int> tmp48;                                                                         
                                                                                                    
                                                                                                    
  // 70.17: tmp48 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937821 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937821 := m#moverPath(moverPath3937821);                                                    
  path3937821 := p#moverPath(moverPath3937821);                                                     
  assume Queue._state3937821 == Queue._state && Queue.elems3937821 == Queue.elems && Queue.head3937821 == Queue.head && Queue.tail3937821 == Queue.tail && Queue.spec3937821 == Queue.spec && Queue._lock3937821 == Queue._lock && Array.Queue.T._state3937821 == Array.Queue.T._state && Array.Queue.T._elems3937821 == Array.Queue.T._elems && Array.Queue.T._length3937821 == Array.Queue.T._length && tmp483937821 == tmp48 && tmp473937821 == tmp47 && tmp463937821 == tmp46 && tmp453937821 == tmp45 && tmp443937821 == tmp44 && tmp433937821 == tmp43 && tmp423937821 == tmp42 && result3937821 == result && tmp413937821 == tmp41 && tmp403937821 == tmp40 && tmp393937821 == tmp39 && tmp383937821 == tmp38 && tmp373937821 == tmp37 && tmp363937821 == tmp36 && tmp353937821 == tmp35 && tmp343937821 == tmp34 && tmp333937821 == tmp33 && tmp323937821 == tmp32 && tmp313937821 == tmp31 && tmp303937821 == tmp30 && tmp293937821 == tmp29 && tmp283937821 == tmp28 && tmp273937821 == tmp27 && tmp263937821 == tmp26 && tmp253937821 == tmp25 && tmp243937821 == tmp24 && tmp233937821 == tmp23 && tmp223937821 == tmp22 && tmp213937821 == tmp21 && $result3937821 == $result && this3937821 == this && tid3937821 == tid && _pc3937821 == _pc;
  assume $recorded.state3937821 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (70.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937821);                                                             
  assert _pc != PhaseError;                                                                                // (70.17): Reduction failure
  tmp48 := Queue.spec[this];                                                                        
                                                                                                    
  // 70.17: int tmp49;                                                                              
                                                                                                    
                                                                                                    
  // 70.17: int tmp50;                                                                              
                                                                                                    
                                                                                                    
  // 70.17: Seq<int> tmp51;                                                                         
                                                                                                    
                                                                                                    
  // 70.17: tmp51 := this.spec;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937834 := ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937834 := m#moverPath(moverPath3937834);                                                    
  path3937834 := p#moverPath(moverPath3937834);                                                     
  assume Queue._state3937834 == Queue._state && Queue.elems3937834 == Queue.elems && Queue.head3937834 == Queue.head && Queue.tail3937834 == Queue.tail && Queue.spec3937834 == Queue.spec && Queue._lock3937834 == Queue._lock && Array.Queue.T._state3937834 == Array.Queue.T._state && Array.Queue.T._elems3937834 == Array.Queue.T._elems && Array.Queue.T._length3937834 == Array.Queue.T._length && tmp513937834 == tmp51 && tmp503937834 == tmp50 && tmp493937834 == tmp49 && tmp483937834 == tmp48 && tmp473937834 == tmp47 && tmp463937834 == tmp46 && tmp453937834 == tmp45 && tmp443937834 == tmp44 && tmp433937834 == tmp43 && tmp423937834 == tmp42 && result3937834 == result && tmp413937834 == tmp41 && tmp403937834 == tmp40 && tmp393937834 == tmp39 && tmp383937834 == tmp38 && tmp373937834 == tmp37 && tmp363937834 == tmp36 && tmp353937834 == tmp35 && tmp343937834 == tmp34 && tmp333937834 == tmp33 && tmp323937834 == tmp32 && tmp313937834 == tmp31 && tmp303937834 == tmp30 && tmp293937834 == tmp29 && tmp283937834 == tmp28 && tmp273937834 == tmp27 && tmp263937834 == tmp26 && tmp253937834 == tmp25 && tmp243937834 == tmp24 && tmp233937834 == tmp23 && tmp223937834 == tmp22 && tmp213937834 == tmp21 && $result3937834 == $result && this3937834 == this && tid3937834 == tid && _pc3937834 == _pc;
  assume $recorded.state3937834 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (70.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937834);                                                             
  assert _pc != PhaseError;                                                                                // (70.17): Reduction failure
  tmp51 := Queue.spec[this];                                                                        
                                                                                                    
  // 70.17: tmp50 = SeqLen<int>(tmp51);                                                             
                                                                                                    
  tmp50 := SeqLen.int(tmp51);                                                                       
                                                                                                    
  // 70.17: tmp49 = tmp50 - 1;                                                                      
                                                                                                    
  tmp49 := (tmp50-1);                                                                               
                                                                                                    
  // 70.17: tmp47 = SeqExtract<int>(tmp48,1,tmp49);                                                 
                                                                                                    
  tmp47 := SeqExtract.int(tmp48,1,tmp49);                                                           
                                                                                                    
                                                                                                    
  // 70.17: this.spec := tmp47;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937857 := WriteEval.Queue.spec(tid: Tid,this: Queue,tmp47: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937857 := m#moverPath(moverPath3937857);                                                    
  path3937857 := p#moverPath(moverPath3937857);                                                     
  assume Queue._state3937857 == Queue._state && Queue.elems3937857 == Queue.elems && Queue.head3937857 == Queue.head && Queue.tail3937857 == Queue.tail && Queue.spec3937857 == Queue.spec && Queue._lock3937857 == Queue._lock && Array.Queue.T._state3937857 == Array.Queue.T._state && Array.Queue.T._elems3937857 == Array.Queue.T._elems && Array.Queue.T._length3937857 == Array.Queue.T._length && tmp513937857 == tmp51 && tmp503937857 == tmp50 && tmp493937857 == tmp49 && tmp483937857 == tmp48 && tmp473937857 == tmp47 && tmp463937857 == tmp46 && tmp453937857 == tmp45 && tmp443937857 == tmp44 && tmp433937857 == tmp43 && tmp423937857 == tmp42 && result3937857 == result && tmp413937857 == tmp41 && tmp403937857 == tmp40 && tmp393937857 == tmp39 && tmp383937857 == tmp38 && tmp373937857 == tmp37 && tmp363937857 == tmp36 && tmp353937857 == tmp35 && tmp343937857 == tmp34 && tmp333937857 == tmp33 && tmp323937857 == tmp32 && tmp313937857 == tmp31 && tmp303937857 == tmp30 && tmp293937857 == tmp29 && tmp283937857 == tmp28 && tmp273937857 == tmp27 && tmp263937857 == tmp26 && tmp253937857 == tmp25 && tmp243937857 == tmp24 && tmp233937857 == tmp23 && tmp223937857 == tmp22 && tmp213937857 == tmp21 && $result3937857 == $result && this3937857 == this && tid3937857 == tid && _pc3937857 == _pc;
  assume $recorded.state3937857 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (70.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  _pc := transition(_pc, mover3937857);                                                             
  assert _pc != PhaseError;                                                                                // (70.17): Reduction failure
  Queue.spec[this] := tmp47;                                                                        
                                                                                                    
  // 71.17: int tmp52;                                                                              
                                                                                                    
                                                                                                    
  // 71.17: int tmp53;                                                                              
                                                                                                    
                                                                                                    
  // 71.17: tmp53 := this.head;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937866 := ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937866 := m#moverPath(moverPath3937866);                                                    
  path3937866 := p#moverPath(moverPath3937866);                                                     
  assume Queue._state3937866 == Queue._state && Queue.elems3937866 == Queue.elems && Queue.head3937866 == Queue.head && Queue.tail3937866 == Queue.tail && Queue.spec3937866 == Queue.spec && Queue._lock3937866 == Queue._lock && Array.Queue.T._state3937866 == Array.Queue.T._state && Array.Queue.T._elems3937866 == Array.Queue.T._elems && Array.Queue.T._length3937866 == Array.Queue.T._length && tmp533937866 == tmp53 && tmp523937866 == tmp52 && tmp513937866 == tmp51 && tmp503937866 == tmp50 && tmp493937866 == tmp49 && tmp483937866 == tmp48 && tmp473937866 == tmp47 && tmp463937866 == tmp46 && tmp453937866 == tmp45 && tmp443937866 == tmp44 && tmp433937866 == tmp43 && tmp423937866 == tmp42 && result3937866 == result && tmp413937866 == tmp41 && tmp403937866 == tmp40 && tmp393937866 == tmp39 && tmp383937866 == tmp38 && tmp373937866 == tmp37 && tmp363937866 == tmp36 && tmp353937866 == tmp35 && tmp343937866 == tmp34 && tmp333937866 == tmp33 && tmp323937866 == tmp32 && tmp313937866 == tmp31 && tmp303937866 == tmp30 && tmp293937866 == tmp29 && tmp283937866 == tmp28 && tmp273937866 == tmp27 && tmp263937866 == tmp26 && tmp253937866 == tmp25 && tmp243937866 == tmp24 && tmp233937866 == tmp23 && tmp223937866 == tmp22 && tmp213937866 == tmp21 && $result3937866 == $result && this3937866 == this && tid3937866 == tid && _pc3937866 == _pc;
  assume $recorded.state3937866 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (71.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  _pc := transition(_pc, mover3937866);                                                             
  assert _pc != PhaseError;                                                                                // (71.17): Reduction failure
  tmp53 := Queue.head[this];                                                                        
                                                                                                    
  // 71.17: tmp52 = tmp53 + 1;                                                                      
                                                                                                    
  tmp52 := (tmp53+1);                                                                               
                                                                                                    
                                                                                                    
  // 71.17: this.head := tmp52;                                                                     
                                                                                                    
                                                                                                    
  moverPath3937876 := WriteEval.Queue.head(tid: Tid,this: Queue,tmp52: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
  mover3937876 := m#moverPath(moverPath3937876);                                                    
  path3937876 := p#moverPath(moverPath3937876);                                                     
  assume Queue._state3937876 == Queue._state && Queue.elems3937876 == Queue.elems && Queue.head3937876 == Queue.head && Queue.tail3937876 == Queue.tail && Queue.spec3937876 == Queue.spec && Queue._lock3937876 == Queue._lock && Array.Queue.T._state3937876 == Array.Queue.T._state && Array.Queue.T._elems3937876 == Array.Queue.T._elems && Array.Queue.T._length3937876 == Array.Queue.T._length && tmp533937876 == tmp53 && tmp523937876 == tmp52 && tmp513937876 == tmp51 && tmp503937876 == tmp50 && tmp493937876 == tmp49 && tmp483937876 == tmp48 && tmp473937876 == tmp47 && tmp463937876 == tmp46 && tmp453937876 == tmp45 && tmp443937876 == tmp44 && tmp433937876 == tmp43 && tmp423937876 == tmp42 && result3937876 == result && tmp413937876 == tmp41 && tmp403937876 == tmp40 && tmp393937876 == tmp39 && tmp383937876 == tmp38 && tmp373937876 == tmp37 && tmp363937876 == tmp36 && tmp353937876 == tmp35 && tmp343937876 == tmp34 && tmp333937876 == tmp33 && tmp323937876 == tmp32 && tmp313937876 == tmp31 && tmp303937876 == tmp30 && tmp293937876 == tmp29 && tmp283937876 == tmp28 && tmp273937876 == tmp27 && tmp263937876 == tmp26 && tmp253937876 == tmp25 && tmp243937876 == tmp24 && tmp233937876 == tmp23 && tmp223937876 == tmp22 && tmp213937876 == tmp21 && $result3937876 == $result && this3937876 == this && tid3937876 == tid && _pc3937876 == _pc;
  assume $recorded.state3937876 == 1;                                                               
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (71.17): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  _pc := transition(_pc, mover3937876);                                                             
  assert _pc != PhaseError;                                                                                // (71.17): Reduction failure
  Queue.head[this] := tmp52;                                                                        
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (73.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert Queue._lock[this] == tid;                                                                         // (73.13): lock not held
  _pc := transition(_pc, _L);                                                                       
  assert _pc != PhaseError;                                                                                // (73.13): Reduction failure
  Queue._lock[this] := Tid.null;                                                                    
                                                                                                    
  // 72.17:  return result;                                                                         
                                                                                                    
  assume Queue._state3937880 == Queue._state && Queue.elems3937880 == Queue.elems && Queue.head3937880 == Queue.head && Queue.tail3937880 == Queue.tail && Queue.spec3937880 == Queue.spec && Queue._lock3937880 == Queue._lock && Array.Queue.T._state3937880 == Array.Queue.T._state && Array.Queue.T._elems3937880 == Array.Queue.T._elems && Array.Queue.T._length3937880 == Array.Queue.T._length && tmp533937880 == tmp53 && tmp523937880 == tmp52 && tmp513937880 == tmp51 && tmp503937880 == tmp50 && tmp493937880 == tmp49 && tmp483937880 == tmp48 && tmp473937880 == tmp47 && tmp463937880 == tmp46 && tmp453937880 == tmp45 && tmp443937880 == tmp44 && tmp433937880 == tmp43 && tmp423937880 == tmp42 && result3937880 == result && tmp413937880 == tmp41 && tmp403937880 == tmp40 && tmp393937880 == tmp39 && tmp383937880 == tmp38 && tmp373937880 == tmp37 && tmp363937880 == tmp36 && tmp353937880 == tmp35 && tmp343937880 == tmp34 && tmp333937880 == tmp33 && tmp323937880 == tmp32 && tmp313937880 == tmp31 && tmp303937880 == tmp30 && tmp293937880 == tmp29 && tmp283937880 == tmp28 && tmp273937880 == tmp27 && tmp263937880 == tmp26 && tmp253937880 == tmp25 && tmp243937880 == tmp24 && tmp233937880 == tmp23 && tmp223937880 == tmp22 && tmp213937880 == tmp21 && $result3937880 == $result && this3937880 == this && tid3937880 == tid;
  assume $recorded.state3937880 == 1;                                                               
  $result := result;                                                                                
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (72.17): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (72.17): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (72.17): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (72.17): Object invariant may not hold.
  return;                                                                                           
  if (_pc == PreCommit) {                                                                           
   assume this != Queue.null;                                                                       
  } else {                                                                                          
   assert this != Queue.null;                                                                              // (73.13): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  assert Queue._lock[this] == tid;                                                                         // (73.13): lock not held
  _pc := transition(_pc, _L);                                                                       
  assert _pc != PhaseError;                                                                                // (73.13): Reduction failure
  Queue._lock[this] := Tid.null;                                                                    
 } else {                                                                                           
                                                                                                    
  // 75.13:  return 0;                                                                              
                                                                                                    
  assume Queue._state3937889 == Queue._state && Queue.elems3937889 == Queue.elems && Queue.head3937889 == Queue.head && Queue.tail3937889 == Queue.tail && Queue.spec3937889 == Queue.spec && Queue._lock3937889 == Queue._lock && Array.Queue.T._state3937889 == Array.Queue.T._state && Array.Queue.T._elems3937889 == Array.Queue.T._elems && Array.Queue.T._length3937889 == Array.Queue.T._length && tmp243937889 == tmp24 && tmp233937889 == tmp23 && tmp223937889 == tmp22 && tmp213937889 == tmp21 && $result3937889 == $result && this3937889 == this && tid3937889 == tid;
  assume $recorded.state3937889 == 1;                                                               
  $result := 0;                                                                                     
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (75.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (75.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (75.13): Object invariant may not hold.
  assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (75.13): Object invariant may not hold.
  return;                                                                                           
 }                                                                                                  
                                                                                                    
 // 59.26: // return -1;                                                                            
                                                                                                    
 assume Queue._state3937895 == Queue._state && Queue.elems3937895 == Queue.elems && Queue.head3937895 == Queue.head && Queue.tail3937895 == Queue.tail && Queue.spec3937895 == Queue.spec && Queue._lock3937895 == Queue._lock && Array.Queue.T._state3937895 == Array.Queue.T._state && Array.Queue.T._elems3937895 == Array.Queue.T._elems && Array.Queue.T._length3937895 == Array.Queue.T._length && tmp243937895 == tmp24 && tmp233937895 == tmp23 && tmp223937895 == tmp22 && tmp213937895 == tmp21 && $result3937895 == $result && this3937895 == this && tid3937895 == tid;
 assume $recorded.state3937895 == 1;                                                                
 $result := -1;                                                                                     
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (59.26): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (59.26): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (59.26): Object invariant may not hold.
 assert  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (59.26): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
/*** Array Array.Queue.T ***/                                                                       
                                                                                                    
type Array.Queue.T;                                                                                 
const unique Array.Queue.T.null: Array.Queue.T;                                                     
var Array.Queue.T._state: [Array.Queue.T]State;                                                     
                                                                                                    
const Array.Queue.T._this : [Array.Queue.T]Queue;                                                   
const Array.Queue.T._length : [Array.Queue.T]int;                                                   
var Array.Queue.T._elems  : [Array.Queue.T]([int]int);                                              
                                                                                                    
axiom (forall $this : Array.Queue.T :: Array.Queue.T._length[$this] >= 0);                          
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
// Array.Queue.T: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} ReadEval.Array.Queue.T(tid: Tid,this : Queue,athis : Array.Queue.T,index : int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := true;                                                                               
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
// Array.Queue.T: Spec(Cond(IsLocal(VarAccess(this),VarAccess(tid)),Cond(IsLocal(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E()))),Cond(Holds(VarAccess(this),VarAccess(tid)),ConstExpr(MoverConst(B())),ConstExpr(MoverConst(E())))),false,List())
                                                                                                    
function {:inline} WriteEval.Array.Queue.T(tid: Tid,this : Queue,athis : Array.Queue.T,index : int,newValue: int,Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Queue._state[this], tid)) then                                                         
  if (isLocal(Queue._state[this], tid)) then                                                        
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if ((isAccessible(Queue._state[this], tid) && Queue._lock[this] == tid)) then                     
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Queue._state: [Queue]State,Queue.elems: [Queue]Array.Queue.T,Queue.head: [Queue]int,Queue.tail: [Queue]int,Queue.spec: [Queue]Seq.int,Queue._lock: [Queue]Tid,Array.Queue.T._state: [Array.Queue.T]State,Array.Queue.T._elems: [Array.Queue.T]([int]int),Array.Queue.T._length: [Array.Queue.T]int) returns (bool) {
  true &&                                                                                           
  (forall _i: Queue  :: _i == Queue.null <==> isNull(Queue._state[_i])) &&                          
  (forall _i: Array.Queue.T  :: _i == Array.Queue.T.null <==> isNull(Array.Queue.T._state[_i])) &&  
  (forall _t: Tid, _i: Array.Queue.T  :: ValidTid(_t) && isAccessible(Array.Queue.T._state[_i], _t) ==> isAccessible(Queue._state[Array.Queue.T._this[_i]], _t)) &&
  (forall _i: Queue :: { Array.Queue.T._state[Queue.elems[_i]] } (isShared(Queue._state[_i]) ==> isSharedAssignable(Array.Queue.T._state[Queue.elems[_i]]))) &&
  (forall _i: Queue :: { Array.Queue.T._state[Queue.elems[_i]] } (forall _t: Tid :: (ValidTid(_t) && isLocal(Queue._state[_i],_t) ==> isLocalAssignable(Array.Queue.T._state[Queue.elems[_i]], _t)))) &&
  (forall _i: Queue :: { Queue.elems[_i] } Array.Queue.T._this[Queue.elems[_i]] == _i) &&           
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.elems[x] := v;                                                                               
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.elems[x] := v;                                                                               
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.elems(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (9.5): Queue.elems failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Queue.T;                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.elems[x];                                                                        
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.elems[x] := havocValue;                                                                      
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Array.Queue.T;                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.elems[x];                                                                        
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.elems(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (9.5): Queue.elems failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, x: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Array.Queue.T;                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.elems[x];                                                                        
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.elems[x] := havocValue;                                                                      
 _writeByU := WriteEval.Queue.elems(u: Tid,x: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (9.5): Queue.elems failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)         
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.head[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (10.5): Queue.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.head[x] := havocValue;                                                                       
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)           
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.head[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.head(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (10.5): Queue.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)               
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.head(t: Tid, u: Tid, v: int, w: int, x: Queue)                
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.head[x];                                                                         
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.head[x] := havocValue;                                                                       
 _writeByU := WriteEval.Queue.head(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): Queue.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)         
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (14.5): Queue.tail failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.tail[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (14.5): Queue.tail failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)          
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.tail[x] := havocValue;                                                                       
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (14.5): Queue.tail failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)           
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.tail[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.tail(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (14.5): Queue.tail failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)               
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (14.5): Queue.tail failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.tail(t: Tid, u: Tid, v: int, w: int, x: Queue)                
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.tail[x];                                                                         
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.tail[x] := havocValue;                                                                       
 _writeByU := WriteEval.Queue.tail(u: Tid,x: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (14.5): Queue.tail failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue) 
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.spec[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (24.5): Queue.spec failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)  
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Queue.spec[x] := v;                                                                                
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Queue.spec(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (24.5): Queue.spec failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)  
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Seq.int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.spec[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Queue.spec[x] := havocValue;                                                                       
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (24.5): Queue.spec failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)   
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Seq.int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Queue.spec[x];                                                                         
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Queue.spec(u: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (24.5): Queue.spec failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)       
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (24.5): Queue.spec failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, x: Queue)        
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[x], u);                                                         
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Seq.int;                                                                          
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Queue.spec[x];                                                                         
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Queue.spec[x] := havocValue;                                                                       
 _writeByU := WriteEval.Queue.spec(u: Tid,x: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (24.5): Queue.spec failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Queue.T._elems[x][i] := v;                                                                   
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Array.Queue.T._elems[x][i] := v;                                                                   
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.5): Array Array.Queue.T failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Array.Queue.T._elems[x][i];                                                            
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Array.Queue.T._elems[x][i] := havocValue;                                                          
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume w == Array.Queue.T._elems[x][i];                                                            
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _readByU := ReadEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.5): Array Array.Queue.T failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, x_owner: Queue, x: Array.Queue.T, i: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[x], u);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 assume w == Array.Queue.T._elems[x][i];                                                            
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_owner_pre == x_owner && x_pre == x && i_pre == i;
 assume $recorded.state_pre == 1;                                                                   
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Array.Queue.T._elems[x][i] := havocValue;                                                          
 _writeByU := WriteEval.Array.Queue.T(u: Tid,x_owner: Queue,x: Array.Queue.T,i: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.5): Array Array.Queue.T failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.elems(t: Tid, u: Tid, v: Array.Queue.T, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.head(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.tail(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Queue.spec(t: Tid, u: Tid, v: Array.Queue.T, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.elems;                                                                              
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Array.Queue.T;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var v_mid: Array.Queue.T;                                                                          
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.elems[x];                                                                            
 Queue.elems[x] := v;                                                                               
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.elems[x] := tmpV;                                                                            
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.elems(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.elems.Array.Queue.T._elems(t: Tid, u: Tid, v: Array.Queue.T, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.elems;                                                                              
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var v_pre: Array.Queue.T;                                                                          
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: Array.Queue.T;                                                                         
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.elems(t: Tid,x: Queue,v: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[x] := v;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.head;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.head[x];                                                                             
 Queue.head[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.head[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.head(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.head.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.head;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.head(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.tail;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.tail[x];                                                                             
 Queue.tail[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.tail[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.tail(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.tail.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.tail;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.tail(t: Tid,x: Queue,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.elems(t: Tid, u: Tid, v: Seq.int, w: Array.Queue.T, w0: Array.Queue.T, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var w0_post: Array.Queue.T;                                                                        
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.head(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.tail(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Queue.spec(t: Tid, u: Tid, v: Seq.int, w: Seq.int, w0: Seq.int, x: Queue, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Queue.spec;                                                                               
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: Seq.int;                                                                                
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (24.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : Seq.int;                                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var v_mid: Seq.int;                                                                                
 var x_mid: Queue;                                                                                  
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var j_mid: int;                                                                                    
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Queue.spec[x];                                                                             
 Queue.spec[x] := v;                                                                                
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Queue.spec[x] := tmpV;                                                                             
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Queue.spec(t: Tid,x: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (24.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Queue.spec.Array.Queue.T._elems(t: Tid, u: Tid, v: Seq.int, w: int, w0: int, x: Queue, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Queue._state[x], t);                                                         
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Queue.spec;                                                                               
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: Seq.int;                                                                                
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var x_pre: Queue;                                                                                  
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_post: Queue;                                                                                 
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var v_post: Seq.int;                                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Queue.spec(t: Tid,x: Queue,v: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[x] := v;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var w0_mid: Array.Queue.T;                                                                         
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Array.Queue.T;                                                                          
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.elems[y] := w;                                                                               
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.elems(u: Tid,y: Queue,w: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.elems[y] := w;                                                                               
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.elems(t: Tid, u: Tid, v: int, w: Array.Queue.T, w0: Array.Queue.T, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.elems;                                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var w0_pre: Array.Queue.T;                                                                         
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var w_pre: Array.Queue.T;                                                                          
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var w0_post: Array.Queue.T;                                                                        
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var w_post: Array.Queue.T;                                                                         
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.elems(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.head[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.head(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.head[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.head(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.head;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.head(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.tail[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.tail(u: Tid,y: Queue,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.tail[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.tail(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.tail;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.tail(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: Queue;                                                                                  
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w0_mid: Seq.int;                                                                               
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var w_mid: Seq.int;                                                                                
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Queue.spec[y] := w;                                                                                
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Queue.spec(u: Tid,y: Queue,w: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Queue.spec[y] := w;                                                                                
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Queue.spec(t: Tid, u: Tid, v: int, w: Seq.int, w0: Seq.int, x_owner: Queue, x: Array.Queue.T, i: int, y: Queue)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Queue._state[y], u);                                                         
 modifies Array.Queue.T._elems;                                                                     
 modifies Queue.spec;                                                                               
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var v_pre: int;                                                                                    
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var w0_pre: Seq.int;                                                                               
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var y_pre: Queue;                                                                                  
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var i_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var w_pre: Seq.int;                                                                                
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var w0_post: Seq.int;                                                                              
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var v_post: int;                                                                                   
 var y_post: Queue;                                                                                 
 var Queue._state_post: [Queue]State;                                                               
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var w_post: Seq.int;                                                                               
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Queue.spec(u: Tid,y: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (24.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (24.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
                                                                                                    
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._state_mid: [Array.Queue.T]State;                                                
 var y_mid: Array.Queue.T;                                                                          
 var Queue.head_mid: [Queue]int;                                                                    
 var Array.Queue.T._length_mid: [Array.Queue.T]int;                                                 
 var t_mid: Tid;                                                                                    
 var Array.Queue.T._elems_mid: [Array.Queue.T]([int]int);                                           
 var _pc_mid: Phase;                                                                                
 var u_mid: Tid;                                                                                    
 var i_mid: int;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var w_mid: int;                                                                                    
 var Queue._lock_mid: [Queue]Tid;                                                                   
 var y_owner_mid: Queue;                                                                            
 var Queue.elems_mid: [Queue]Array.Queue.T;                                                         
 var Queue.tail_mid: [Queue]int;                                                                    
 var v_mid: int;                                                                                    
 var j_mid: int;                                                                                    
 var x_mid: Array.Queue.T;                                                                          
 var x_owner_mid: Queue;                                                                            
 var Queue._state_mid: [Queue]State;                                                                
 var w0_mid: int;                                                                                   
 var Queue.spec_mid: [Queue]Seq.int;                                                                
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Array.Queue.T._elems[x][i];                                                                
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_mid == Queue._state && Queue.elems_mid == Queue.elems && Queue.head_mid == Queue.head && Queue.tail_mid == Queue.tail && Queue.spec_mid == Queue.spec && Queue._lock_mid == Queue._lock && Array.Queue.T._state_mid == Array.Queue.T._state && Array.Queue.T._elems_mid == Array.Queue.T._elems && Array.Queue.T._length_mid == Array.Queue.T._length && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_owner_mid == x_owner && x_mid == x && i_mid == i && y_owner_mid == y_owner && y_mid == y && j_mid == j;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Array.Queue.T._elems[x][i] := tmpV;                                                                
 Array.Queue.T._elems[y][j] := w;                                                                   
 _writeByTPost := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,w: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[y][j] := w;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Array.Queue.T._elems.Array.Queue.T._elems(t: Tid, u: Tid, v: int, w: int, w0: int, x_owner: Queue, x: Array.Queue.T, i: int, y_owner: Queue, y: Array.Queue.T, j: int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Array.Queue.T._state[x], t);                                                 
 requires Array.Queue.T._this[x] == x_owner;                                                        
 requires isAccessible(Array.Queue.T._state[y], u);                                                 
 requires Array.Queue.T._this[y] == y_owner;                                                        
 modifies Array.Queue.T._elems;                                                                     
 modifies Array.Queue.T._elems;                                                                     
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var j_pre: int;                                                                                    
 var v_pre: int;                                                                                    
 var y_pre: Array.Queue.T;                                                                          
 var Queue.tail_pre: [Queue]int;                                                                    
 var _pc_pre: Phase;                                                                                
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                
 var Queue._lock_pre: [Queue]Tid;                                                                   
 var y_owner_pre: Queue;                                                                            
 var i_pre: int;                                                                                    
 var w_pre: int;                                                                                    
 var Queue.spec_pre: [Queue]Seq.int;                                                                
 var Queue._state_pre: [Queue]State;                                                                
 var x_pre: Array.Queue.T;                                                                          
 var Queue.elems_pre: [Queue]Array.Queue.T;                                                         
 var x_owner_pre: Queue;                                                                            
 var Queue.head_pre: [Queue]int;                                                                    
 var t_pre: Tid;                                                                                    
 var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                           
 var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                 
                                                                                                    
 var Array.Queue.T._length_post: [Array.Queue.T]int;                                                
 var Queue.head_post: [Queue]int;                                                                   
 var $recorded.state_post: int;                                                                     
 var w0_post: int;                                                                                  
 var t_post: Tid;                                                                                   
 var x_post: Array.Queue.T;                                                                         
 var i_post: int;                                                                                   
 var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                          
 var x_owner_post: Queue;                                                                           
 var Array.Queue.T._state_post: [Array.Queue.T]State;                                               
 var j_post: int;                                                                                   
 var Queue.spec_post: [Queue]Seq.int;                                                               
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Queue._state_post: [Queue]State;                                                               
 var y_owner_post: Queue;                                                                           
 var Queue.elems_post: [Queue]Array.Queue.T;                                                        
 var _pc_post: Phase;                                                                               
 var Queue.tail_post: [Queue]int;                                                                   
 var y_post: Array.Queue.T;                                                                         
 var Queue._lock_post: [Queue]Tid;                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Array.Queue.T(t: Tid,x_owner: Queue,x: Array.Queue.T,i: int,v: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_owner_pre == x_owner && x_pre == x && i_pre == i && y_owner_pre == y_owner && y_pre == y && j_pre == j;
 assume $recorded.state_pre == 1;                                                                   
 Array.Queue.T._elems[x][i] := v;                                                                   
 assume Queue._state_post == Queue._state && Queue.elems_post == Queue.elems && Queue.head_post == Queue.head && Queue.tail_post == Queue.tail && Queue.spec_post == Queue.spec && Queue._lock_post == Queue._lock && Array.Queue.T._state_post == Array.Queue.T._state && Array.Queue.T._elems_post == Array.Queue.T._elems && Array.Queue.T._length_post == Array.Queue.T._length && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_owner_post == x_owner && x_post == x && i_post == i && y_owner_post == y_owner && y_post == y && j_post == j;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Array.Queue.T(u: Tid,y_owner: Queue,y: Array.Queue.T,j: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
requires ValidTid(tid);                                                                             
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
modifies Queue._state;                                                                              
modifies Queue.elems;                                                                               
modifies Queue.head;                                                                                
modifies Queue.tail;                                                                                
modifies Queue.spec;                                                                                
modifies Queue._lock;                                                                               
modifies Array.Queue.T._state;                                                                      
modifies Array.Queue.T._elems;                                                                      
ensures StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures Y(tid , old(Queue._state), old(Queue.elems), old(Queue.head), old(Queue.tail), old(Queue.spec), old(Queue._lock), old(Array.Queue.T._state), old(Array.Queue.T._elems), old(Array.Queue.T._length) , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Queue.elems:                                                                                     
                                                                                                    
function {:inline} Y_Queue.elems(tid : Tid, this: Queue, newValue: Array.Queue.T , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.elems(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.elems[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.elems.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Array.Queue.T , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.elems(u: Tid,this: Queue,newValue: Array.Queue.T,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.elems(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.elems.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.elems(tid, this, Queue.elems[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.elems.Transitive(tid : Tid, this: Queue, newValue : Array.Queue.T , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (9.24): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (9.24): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (9.24): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (9.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var newValue_pre: Array.Queue.T;                                                                    
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var newValue_post: Array.Queue.T;                                                                   
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.elems(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.elems(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue.head:                                                                                      
                                                                                                    
function {:inline} Y_Queue.head(tid : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.head(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.head(u: Tid,this: Queue,newValue: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.head(tid, this, Queue.head[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.head.Transitive(tid : Tid, this: Queue, newValue : int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (10.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (10.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (10.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (10.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var newValue_pre: int;                                                                              
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var newValue_post: int;                                                                             
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.head(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.head(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue.tail:                                                                                      
                                                                                                    
function {:inline} Y_Queue.tail(tid : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.tail(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.tail[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.tail(u: Tid,this: Queue,newValue: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.tail(tid, this, Queue.tail[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.tail.Transitive(tid : Tid, this: Queue, newValue : int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (14.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (14.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (14.33): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (14.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var newValue_pre: int;                                                                              
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var newValue_post: int;                                                                             
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.tail(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.tail(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue.spec:                                                                                      
                                                                                                    
function {:inline} Y_Queue.spec(tid : Tid, this: Queue, newValue: Seq.int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue.spec(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue.spec[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue.spec.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Seq.int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue.spec(u: Tid,this: Queue,newValue: Seq.int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.spec(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.spec.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue.spec(tid, this, Queue.spec[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue.spec.Transitive(tid : Tid, this: Queue, newValue : Seq.int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (24.37): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (24.37): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (24.37): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (24.37): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var newValue_pre: Seq.int;                                                                          
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var newValue_post: Seq.int;                                                                         
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue.spec(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue.spec(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Queue._lock:                                                                                     
                                                                                                    
function {:inline} Y_Queue._lock(tid : Tid, this: Queue, newValue: Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
 ((isAccessible(Queue._state[this], tid) && leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Queue._lock[this] == newValue))
 &&(((Queue._lock[this]==tid)==(newValue==tid)))                                                    
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Subsumes.W(tid : Tid, u : Tid, this: Queue, newValue: Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume isAccessible(Queue._state[this], u);                                                        
 assume !isError(m#moverPath(WriteEval.Queue._lock(u: Tid,this: Queue,newValue: Tid,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
 assume leq(m#moverPath(ReadEval.Queue._lock(tid: Tid,this: Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _N);
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Reflexive(tid : Tid, this: Queue , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Queue._lock(tid, this, Queue._lock[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Queue._lock.Transitive(tid : Tid, this: Queue, newValue : Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (3.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (3.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (3.1): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (3.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var newValue_pre: Tid;                                                                              
var this_pre: Queue;                                                                                
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var this_post: Queue;                                                                               
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var newValue_post: Tid;                                                                             
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Queue._state[this], tid);                                                      
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Queue._lock(tid, this, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Queue._lock(tid, this, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
// Array.Queue.T:                                                                                   
                                                                                                    
function {:inline} Y_Array.Queue.T(tid : Tid, athis: Array.Queue.T, index: int, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int): bool
{                                                                                                   
(var this := Array.Queue.T._this[athis];                                                            
 ((isAccessible(Array.Queue.T._state[athis], tid) && leq(m#moverPath(ReadEval.Array.Queue.T(tid: Tid,Array.Queue.T._this[athis]: Queue,athis: Array.Queue.T,index: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)), _R)) ==> (Array.Queue.T._elems[athis][index] == newValue))
                                                                                                    
)                                                                                                   
}                                                                                                   
                                                                                                    
procedure Y_Array.Queue.T.Subsumes.W(tid : Tid, u : Tid, this: Queue, athis: Array.Queue.T, index: int, newValue: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
 requires this == Array.Queue.T._this[athis];                                                       
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var athis_yield: Array.Queue.T;                                                                     
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var index_yield: int;                                                                               
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Array.Queue.T._state[athis], u);                                               
 assume !isError(m#moverPath(WriteEval.Array.Queue.T(u: Tid,Array.Queue.T._this[athis]: Queue,athis: Array.Queue.T,index: int,newValue: int,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length)));
                                                                                                    
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Queue.T(tid, athis, index, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Queue.T.Reflexive(tid : Tid, this: Queue, athis: Array.Queue.T, index: int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires ValidTid(tid);                                                                            
 requires this == Array.Queue.T._this[athis];                                                       
{                                                                                                   
var Queue._state_yield: [Queue]State;                                                               
var Queue.spec_yield: [Queue]Seq.int;                                                               
var tid_yield: Tid;                                                                                 
var Array.Queue.T._length_yield: [Array.Queue.T]int;                                                
var _pc_yield: Phase;                                                                               
var Queue.tail_yield: [Queue]int;                                                                   
var athis_yield: Array.Queue.T;                                                                     
var Array.Queue.T._state_yield: [Array.Queue.T]State;                                               
var Queue.elems_yield: [Queue]Array.Queue.T;                                                        
var Array.Queue.T._elems_yield: [Array.Queue.T]([int]int);                                          
var Queue._lock_yield: [Queue]Tid;                                                                  
var Queue.head_yield: [Queue]int;                                                                   
var index_yield: int;                                                                               
var $recorded.state_yield: int;                                                                     
var this_yield: Queue;                                                                              
                                                                                                    
 assume isAccessible(Array.Queue.T._state[athis], tid);                                             
assume Queue._state_yield == Queue._state && Queue.elems_yield == Queue.elems && Queue.head_yield == Queue.head && Queue.tail_yield == Queue.tail && Queue.spec_yield == Queue.spec && Queue._lock_yield == Queue._lock && Array.Queue.T._state_yield == Array.Queue.T._state && Array.Queue.T._elems_yield == Array.Queue.T._elems && Array.Queue.T._length_yield == Array.Queue.T._length && athis_yield == athis && index_yield == index && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Array.Queue.T(tid, athis, index, Array.Queue.T._elems[athis][index] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
procedure Y_Array.Queue.T.Transitive(tid : Tid, this: Queue, athis: Array.Queue.T, index: int, newValue : int , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int)
 requires StateInvariant(Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
 requires StateInvariant(Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923514(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (7.28): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923522(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (7.28): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923535(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (7.28): Object invariant may not hold.
requires  (forall _this : Queue ::  { Queue._state[_this] } isAccessible(Queue._state[_this], tid) && true ==> Invariant.Queue.3923577(tid: Tid,_this : Queue,Queue._state,Queue.elems,Queue.head,Queue.tail,Queue.spec,Queue._lock,Array.Queue.T._state,Array.Queue.T._elems,Array.Queue.T._length));       // (7.28): Object invariant may not hold.
                                                                                                    
 requires this == Array.Queue.T._this[athis];                                                       
 requires ValidTid(tid);                                                                            
{                                                                                                   
var Queue.tail_pre: [Queue]int;                                                                     
var _pc_pre: Phase;                                                                                 
var $recorded.state_pre: int;                                                                       
var Array.Queue.T._state_pre: [Array.Queue.T]State;                                                 
var index_pre: int;                                                                                 
var Queue._lock_pre: [Queue]Tid;                                                                    
var Queue.spec_pre: [Queue]Seq.int;                                                                 
var tid_pre: Tid;                                                                                   
var Queue._state_pre: [Queue]State;                                                                 
var Queue.elems_pre: [Queue]Array.Queue.T;                                                          
var Queue.head_pre: [Queue]int;                                                                     
var this_pre: Queue;                                                                                
var athis_pre: Array.Queue.T;                                                                       
var Array.Queue.T._elems_pre: [Array.Queue.T]([int]int);                                            
var Array.Queue.T._length_pre: [Array.Queue.T]int;                                                  
                                                                                                    
var Array.Queue.T._length_post: [Array.Queue.T]int;                                                 
var Queue.head_post: [Queue]int;                                                                    
var $recorded.state_post: int;                                                                      
var Array.Queue.T._elems_post: [Array.Queue.T]([int]int);                                           
var Array.Queue.T._state_post: [Array.Queue.T]State;                                                
var tid_post: Tid;                                                                                  
var Queue.spec_post: [Queue]Seq.int;                                                                
var athis_post: Array.Queue.T;                                                                      
var this_post: Queue;                                                                               
var index_post: int;                                                                                
var Queue._state_post: [Queue]State;                                                                
var Queue.elems_post: [Queue]Array.Queue.T;                                                         
var _pc_post: Phase;                                                                                
var Queue.tail_post: [Queue]int;                                                                    
var Queue._lock_post: [Queue]Tid;                                                                   
                                                                                                    
assume Queue._state_pre == Queue._state && Queue.elems_pre == Queue.elems && Queue.head_pre == Queue.head && Queue.tail_pre == Queue.tail && Queue.spec_pre == Queue.spec && Queue._lock_pre == Queue._lock && Array.Queue.T._state_pre == Array.Queue.T._state && Array.Queue.T._elems_pre == Array.Queue.T._elems && Array.Queue.T._length_pre == Array.Queue.T._length && athis_pre == athis && index_pre == index && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
assume Queue._state_post == Queue._state_p && Queue.elems_post == Queue.elems_p && Queue.head_post == Queue.head_p && Queue.tail_post == Queue.tail_p && Queue.spec_post == Queue.spec_p && Queue._lock_post == Queue._lock_p && Array.Queue.T._state_post == Array.Queue.T._state_p && Array.Queue.T._elems_post == Array.Queue.T._elems_p && Array.Queue.T._length_post == Array.Queue.T._length_p && athis_post == athis && index_post == index && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assume isAccessible(Array.Queue.T._state[athis], tid);                                             
 assume Y(tid , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assume Y_Array.Queue.T(tid, athis, index, newValue , Queue._state_p, Queue.elems_p, Queue.head_p, Queue.tail_p, Queue.spec_p, Queue._lock_p, Array.Queue.T._state_p, Array.Queue.T._elems_p, Array.Queue.T._length_p);
 assert Y_Array.Queue.T(tid, athis, index, newValue , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Queue._state: [Queue]State, Queue.elems: [Queue]Array.Queue.T, Queue.head: [Queue]int, Queue.tail: [Queue]int, Queue.spec: [Queue]Seq.int, Queue._lock: [Queue]Tid, Array.Queue.T._state: [Array.Queue.T]State, Array.Queue.T._elems: [Array.Queue.T]([int]int), Array.Queue.T._length: [Array.Queue.T]int , Queue._state_p: [Queue]State, Queue.elems_p: [Queue]Array.Queue.T, Queue.head_p: [Queue]int, Queue.tail_p: [Queue]int, Queue.spec_p: [Queue]Seq.int, Queue._lock_p: [Queue]Tid, Array.Queue.T._state_p: [Array.Queue.T]State, Array.Queue.T._elems_p: [Array.Queue.T]([int]int), Array.Queue.T._length_p: [Array.Queue.T]int): bool
{                                                                                                   
 (forall this: Queue :: Y_Queue.elems(tid : Tid, this, Queue.elems_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue.head(tid : Tid, this, Queue.head_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue.tail(tid : Tid, this, Queue.tail_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue.spec(tid : Tid, this, Queue.spec_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall this: Queue :: Y_Queue._lock(tid : Tid, this, Queue._lock_p[this] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall athis: Array.Queue.T, index: int :: Y_Array.Queue.T(tid : Tid, athis, index, Array.Queue.T._elems_p[athis][index] , Queue._state, Queue.elems, Queue.head, Queue.tail, Queue.spec, Queue._lock, Array.Queue.T._state, Array.Queue.T._elems, Array.Queue.T._length))
 && (forall _i : Queue :: isShared(Queue._state[_i]) ==> isShared(Queue._state_p[_i]))              
 && (forall _i : Queue :: isLocal(Queue._state[_i], tid) <==> isLocal(Queue._state_p[_i], tid))     
 && (forall _i : Array.Queue.T :: isShared(Array.Queue.T._state[_i]) ==> isShared(Array.Queue.T._state_p[_i]))
 && (forall _i : Array.Queue.T :: Array.Queue.T._length[_i] == Array.Queue.T._length_p[_i])         
 && (forall _i : Array.Queue.T :: isLocal(Array.Queue.T._state[_i], tid) <==> isLocal(Array.Queue.T._state_p[_i], tid))
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
/// Seq.int:                                                                                        
                                                                                                    
type {:builtin "(Seq Int)"} Seq.int;                                                                
                                                                                                    
function {:builtin "(as seq.empty (Seq Int))"} SeqEmpty.int(): Seq.int;                             
function {:builtin "seq.len"} SeqLen.int(s: Seq.int): int;                                          
function {:builtin "seq.++"} SeqConcat.int(s1: Seq.int, s2:Seq.int): Seq.int;                       
function {:builtin "seq.unit"} SeqUnit.int(v: int): Seq.int;                                        
function {:builtin "seq.nth"} SeqNth.int(s: Seq.int, i: int): int;                                  
function {:builtin "seq.extract"} SeqExtract.int(s: Seq.int, pos: int, len: int): Seq.int;          
                                                                                                    
function {:inline} SeqEqual.int(a: Seq.int, b: Seq.int) : bool {                                    
SeqLen.int(a) == SeqLen.int(b) &&                                                                   
(forall i : int :: 0 <= i && i < SeqLen.int(a) ==> (SeqNth.int(a, i) == SeqNth.int(b, i)))          
}                                                                                                   
                                                                                                    
function {:inline} SeqSub.int(a: Seq.int, start: int, end: int) : Seq.int {                         
SeqExtract.int(a, start, end-start)                                                                 
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
// 1365.1-1634.2: (Method:31.5)
// 1377.1-1377.24: (31.5): Bad tid
// 1383.1-1383.304: (31.5): Object invariant may not hold.
// 1384.1-1384.304: (31.5): Object invariant may not hold.
// 1385.1-1385.304: (31.5): Object invariant may not hold.
// 1386.1-1386.304: (31.5): Object invariant may not hold.
// 1389.1-1389.294: (31.5): Object invariant may not hold.
// 1390.1-1390.294: (31.5): Object invariant may not hold.
// 1391.1-1391.294: (31.5): Object invariant may not hold.
// 1392.1-1392.294: (31.5): Object invariant may not hold.
// 1493.1-1493.215: (31.5): Can only have right-mover memory accesses in requires clause
// 1495.2-1498.49: (class anchor.sink.Assume:31.5)
// 1499.2-1502.31: (class anchor.sink.Assume:31.5)
// 1503.2-1506.31: (class anchor.sink.Assume:31.5)
// 1507.2-1510.54: (class anchor.sink.Assume:31.5)
// 1511.2-1513.2: (class anchor.sink.VarDeclStmt:33.9)
// 1514.2-1517.25: (class anchor.sink.Assign:33.9)
// 1519.2-1535.27: (class anchor.sink.Write:33.9)
// 1531.1-1531.29: (33.9): Cannot have potential null deference in left-mover part.
// 1534.1-1534.27: (33.9): Reduction failure
// 1536.2-1538.2: (class anchor.sink.VarDeclStmt:34.9)
// 1539.2-1542.12: (class anchor.sink.Assign:34.9)
// 1544.2-1560.27: (class anchor.sink.Write:34.9)
// 1556.1-1556.29: (34.9): Cannot have potential null deference in left-mover part.
// 1559.1-1559.27: (34.9): Reduction failure
// 1561.2-1563.2: (class anchor.sink.VarDeclStmt:35.9)
// 1564.2-1567.12: (class anchor.sink.Assign:35.9)
// 1569.2-1585.27: (class anchor.sink.Write:35.9)
// 1581.1-1581.29: (35.9): Cannot have potential null deference in left-mover part.
// 1584.1-1584.27: (35.9): Reduction failure
// 1586.2-1588.2: (class anchor.sink.VarDeclStmt:36.9)
// 1589.2-1597.78: (class anchor.sink.AAlloc:36.9)
// 1599.2-1623.2: (class anchor.sink.Write:36.9)
// 1611.1-1611.29: (36.9): Cannot have potential null deference in left-mover part.
// 1614.1-1614.27: (36.9): Reduction failure
// 1620.1-1620.92: (36.9): tmp4 became shared, but Array.Queue.T._this[tmp4].elems may not be shared.
// 1624.2-1633.9: (class anchor.sink.Return:32.21)
// 1629.1-1629.294: (32.21): Object invariant may not hold.
// 1630.1-1630.294: (32.21): Object invariant may not hold.
// 1631.1-1631.294: (32.21): Object invariant may not hold.
// 1632.1-1632.294: (32.21): Object invariant may not hold.
// 1635.1-2387.2: (Method:39.5)
// 1647.1-1647.24: (39.5): Bad tid
// 1648.1-1648.39: (39.5): this is not global
// 1653.1-1653.295: (39.5): Object invariant may not hold.
// 1654.1-1654.295: (39.5): Object invariant may not hold.
// 1655.1-1655.295: (39.5): Object invariant may not hold.
// 1656.1-1656.295: (39.5): Object invariant may not hold.
// 1659.1-1659.294: (39.5): Object invariant may not hold.
// 1660.1-1660.294: (39.5): Object invariant may not hold.
// 1661.1-1661.294: (39.5): Object invariant may not hold.
// 1662.1-1662.294: (39.5): Object invariant may not hold.
// 2041.1-2041.14: (39.18): Can only have right-mover memory accesses in requires clause
// 2043.2-2045.2: (class anchor.sink.VarDeclStmt:43.9)
// 2046.2-2048.2: (class anchor.sink.VarDeclStmt:43.9)
// 2049.2-2051.2: (class anchor.sink.VarDeclStmt:43.9)
// 2052.2-2069.27: (class anchor.sink.Read:43.9)
// 2064.1-2064.29: (43.9): Cannot have potential null deference in left-mover part.
// 2068.1-2068.27: (43.9): Reduction failure
// 2070.2-2072.2: (class anchor.sink.VarDeclStmt:43.9)
// 2073.2-2090.27: (class anchor.sink.Read:43.9)
// 2085.1-2085.29: (43.9): Cannot have potential null deference in left-mover part.
// 2089.1-2089.27: (43.9): Reduction failure
// 2091.2-2094.22: (class anchor.sink.Assign:43.9)
// 2095.2-2097.2: (class anchor.sink.VarDeclStmt:43.9)
// 2098.2-2100.2: (class anchor.sink.VarDeclStmt:43.9)
// 2101.2-2118.29: (class anchor.sink.Read:43.9)
// 2113.1-2113.29: (43.9): Cannot have potential null deference in left-mover part.
// 2117.1-2117.27: (43.9): Reduction failure
// 2119.2-2122.39: (class anchor.sink.Assign:43.9)
// 2123.2-2126.22: (class anchor.sink.Assign:43.9)
// 2128.3-2144.43: (class anchor.sink.Yield:44.13)
// 2133.1-2133.295: (44.13): Object invariant may not hold.
// 2134.1-2134.295: (44.13): Object invariant may not hold.
// 2135.1-2135.295: (44.13): Object invariant may not hold.
// 2136.1-2136.295: (44.13): Object invariant may not hold.
// 2138.1-2138.295: (44.13): Object invariant may not hold.
// 2139.1-2139.295: (44.13): Object invariant may not hold.
// 2140.1-2140.295: (44.13): Object invariant may not hold.
// 2141.1-2141.295: (44.13): Object invariant may not hold.
// 2145.3-2148.18: (class anchor.sink.Assume:45.13)
// 2152.1-2152.30: (46.27): Cannot have potential null deference in left-mover part.
// 2156.1-2156.28: (46.27): Reduction failure
// 2158.3-2161.89: (class anchor.sink.Assume:47.17)
// 2162.3-2164.3: (class anchor.sink.VarDeclStmt:48.17)
// 2165.3-2182.30: (class anchor.sink.Read:48.17)
// 2177.1-2177.30: (48.17): Cannot have potential null deference in left-mover part.
// 2181.1-2181.28: (48.17): Reduction failure
// 2183.3-2185.3: (class anchor.sink.VarDeclStmt:48.17)
// 2186.3-2188.3: (class anchor.sink.VarDeclStmt:48.17)
// 2189.3-2206.29: (class anchor.sink.Read:48.17)
// 2201.1-2201.30: (48.17): Cannot have potential null deference in left-mover part.
// 2205.1-2205.28: (48.17): Reduction failure
// 2207.3-2209.3: (class anchor.sink.VarDeclStmt:48.17)
// 2210.3-2212.3: (class anchor.sink.VarDeclStmt:48.17)
// 2213.3-2230.30: (class anchor.sink.Read:48.17)
// 2225.1-2225.30: (48.17): Cannot have potential null deference in left-mover part.
// 2229.1-2229.28: (48.17): Reduction failure
// 2231.3-2234.41: (class anchor.sink.Assign:48.17)
// 2235.3-2238.30: (class anchor.sink.Assign:48.17)
// 2239.3-2266.43: (class anchor.sink.AWrite:48.17)
// 2251.1-2251.39: (48.17): Cannot have potential null deference in left-mover part.
// 2256.1-2256.22: (48.17): index < 0.
// 2261.1-2261.48: (48.17): index is >= length.
// 2265.1-2265.28: (48.17): Reduction failure
// 2267.3-2269.3: (class anchor.sink.VarDeclStmt:49.17)
// 2270.3-2272.3: (class anchor.sink.VarDeclStmt:49.17)
// 2273.3-2290.29: (class anchor.sink.Read:49.17)
// 2285.1-2285.30: (49.17): Cannot have potential null deference in left-mover part.
// 2289.1-2289.28: (49.17): Reduction failure
// 2291.3-2293.3: (class anchor.sink.VarDeclStmt:49.17)
// 2294.3-2297.27: (class anchor.sink.Assign:49.17)
// 2298.3-2301.39: (class anchor.sink.Assign:49.17)
// 2303.3-2319.29: (class anchor.sink.Write:49.17)
// 2315.1-2315.30: (49.17): Cannot have potential null deference in left-mover part.
// 2318.1-2318.28: (49.17): Reduction failure
// 2320.3-2322.3: (class anchor.sink.VarDeclStmt:50.17)
// 2323.3-2325.3: (class anchor.sink.VarDeclStmt:50.17)
// 2326.3-2343.29: (class anchor.sink.Read:50.17)
// 2338.1-2338.30: (50.17): Cannot have potential null deference in left-mover part.
// 2342.1-2342.28: (50.17): Reduction failure
// 2344.3-2347.22: (class anchor.sink.Assign:50.17)
// 2349.3-2365.29: (class anchor.sink.Write:50.17)
// 2361.1-2361.30: (50.17): Cannot have potential null deference in left-mover part.
// 2364.1-2364.28: (50.17): Reduction failure
// 2369.1-2369.30: (51.13): Cannot have potential null deference in left-mover part.
// 2371.1-2371.35: (51.13): lock not held
// 2373.1-2373.28: (51.13): Reduction failure
// 2377.2-2386.9: (class anchor.sink.Return:42.32)
// 2382.1-2382.294: (42.32): Object invariant may not hold.
// 2383.1-2383.294: (42.32): Object invariant may not hold.
// 2384.1-2384.294: (42.32): Object invariant may not hold.
// 2385.1-2385.294: (42.32): Object invariant may not hold.
// 2388.1-4079.2: (Method:55.5)
// 2401.1-2401.24: (55.5): Bad tid
// 2402.1-2402.39: (55.5): this is not global
// 2407.1-2407.295: (55.5): Object invariant may not hold.
// 2408.1-2408.295: (55.5): Object invariant may not hold.
// 2409.1-2409.295: (55.5): Object invariant may not hold.
// 2410.1-2410.295: (55.5): Object invariant may not hold.
// 2413.1-2413.294: (55.5): Object invariant may not hold.
// 2414.1-2414.294: (55.5): Object invariant may not hold.
// 2415.1-2415.294: (55.5): Object invariant may not hold.
// 2416.1-2416.294: (55.5): Object invariant may not hold.
// 3403.1-3403.14: (55.18): Can only have right-mover memory accesses in requires clause
// 3405.2-3407.2: (class anchor.sink.VarDeclStmt:60.9)
// 3408.2-3410.2: (class anchor.sink.VarDeclStmt:60.9)
// 3411.2-3413.2: (class anchor.sink.VarDeclStmt:60.9)
// 3414.2-3431.28: (class anchor.sink.Read:60.9)
// 3426.1-3426.29: (60.9): Cannot have potential null deference in left-mover part.
// 3430.1-3430.27: (60.9): Reduction failure
// 3432.2-3434.2: (class anchor.sink.VarDeclStmt:60.9)
// 3435.2-3452.28: (class anchor.sink.Read:60.9)
// 3447.1-3447.29: (60.9): Cannot have potential null deference in left-mover part.
// 3451.1-3451.27: (60.9): Reduction failure
// 3453.2-3456.25: (class anchor.sink.Assign:60.9)
// 3457.2-3460.21: (class anchor.sink.Assign:60.9)
// 3462.3-3478.43: (class anchor.sink.Yield:61.12)
// 3467.1-3467.295: (61.12): Object invariant may not hold.
// 3468.1-3468.295: (61.12): Object invariant may not hold.
// 3469.1-3469.295: (61.12): Object invariant may not hold.
// 3470.1-3470.295: (61.12): Object invariant may not hold.
// 3472.1-3472.295: (61.12): Object invariant may not hold.
// 3473.1-3473.295: (61.12): Object invariant may not hold.
// 3474.1-3474.295: (61.12): Object invariant may not hold.
// 3475.1-3475.295: (61.12): Object invariant may not hold.
// 3479.3-3482.18: (class anchor.sink.Assume:62.13)
// 3486.1-3486.30: (63.27): Cannot have potential null deference in left-mover part.
// 3490.1-3490.28: (63.27): Reduction failure
// 3492.3-3495.50: (class anchor.sink.Assume:64.17)
// 3496.3-3498.3: (class anchor.sink.VarDeclStmt:65.21)
// 3499.3-3501.3: (class anchor.sink.VarDeclStmt:65.21)
// 3502.3-3519.29: (class anchor.sink.Read:65.21)
// 3514.1-3514.30: (65.21): Cannot have potential null deference in left-mover part.
// 3518.1-3518.28: (65.21): Reduction failure
// 3520.3-3523.32: (class anchor.sink.Assign:65.21)
// 3524.3-3526.3: (class anchor.sink.VarDeclStmt:65.21)
// 3527.3-3544.30: (class anchor.sink.Read:65.21)
// 3539.1-3539.30: (65.21): Cannot have potential null deference in left-mover part.
// 3543.1-3543.28: (65.21): Reduction failure
// 3545.3-3547.3: (class anchor.sink.VarDeclStmt:65.21)
// 3548.3-3550.3: (class anchor.sink.VarDeclStmt:65.21)
// 3551.3-3553.3: (class anchor.sink.VarDeclStmt:65.21)
// 3554.3-3571.29: (class anchor.sink.Read:65.21)
// 3566.1-3566.30: (65.21): Cannot have potential null deference in left-mover part.
// 3570.1-3570.28: (65.21): Reduction failure
// 3572.3-3575.22: (class anchor.sink.Assign:65.21)
// 3576.3-3578.3: (class anchor.sink.VarDeclStmt:65.21)
// 3579.3-3581.3: (class anchor.sink.VarDeclStmt:65.21)
// 3582.3-3599.30: (class anchor.sink.Read:65.21)
// 3594.1-3594.30: (65.21): Cannot have potential null deference in left-mover part.
// 3598.1-3598.28: (65.21): Reduction failure
// 3600.3-3603.41: (class anchor.sink.Assign:65.21)
// 3604.3-3607.30: (class anchor.sink.Assign:65.21)
// 3608.3-3610.3: (class anchor.sink.VarDeclStmt:65.21)
// 3611.3-3638.47: (class anchor.sink.ARead:65.21)
// 3623.1-3623.39: (65.21): Cannot have potential null deference in left-mover part.
// 3628.1-3628.22: (65.21): index < 0.
// 3633.1-3633.48: (65.21): index is >= length.
// 3637.1-3637.28: (65.21): Reduction failure
// 3639.3-3644.25: (class anchor.sink.Assert:65.21)
// 3644.1-3644.25: (65.21): This assertion may not hold.
// 3645.3-3647.3: (class anchor.sink.VarDeclStmt:66.21)
// 3648.3-3650.3: (class anchor.sink.VarDeclStmt:66.21)
// 3651.3-3668.29: (class anchor.sink.Read:66.21)
// 3663.1-3663.30: (66.21): Cannot have potential null deference in left-mover part.
// 3667.1-3667.28: (66.21): Reduction failure
// 3669.3-3672.32: (class anchor.sink.Assign:66.21)
// 3673.3-3675.3: (class anchor.sink.VarDeclStmt:66.21)
// 3676.3-3693.30: (class anchor.sink.Read:66.21)
// 3688.1-3688.30: (66.21): Cannot have potential null deference in left-mover part.
// 3692.1-3692.28: (66.21): Reduction failure
// 3694.3-3696.3: (class anchor.sink.VarDeclStmt:66.21)
// 3697.3-3699.3: (class anchor.sink.VarDeclStmt:66.21)
// 3700.3-3717.29: (class anchor.sink.Read:66.21)
// 3712.1-3712.30: (66.21): Cannot have potential null deference in left-mover part.
// 3716.1-3716.28: (66.21): Reduction failure
// 3718.3-3720.3: (class anchor.sink.VarDeclStmt:66.21)
// 3721.3-3723.3: (class anchor.sink.VarDeclStmt:66.21)
// 3724.3-3741.30: (class anchor.sink.Read:66.21)
// 3736.1-3736.30: (66.21): Cannot have potential null deference in left-mover part.
// 3740.1-3740.28: (66.21): Reduction failure
// 3742.3-3745.41: (class anchor.sink.Assign:66.21)
// 3746.3-3749.30: (class anchor.sink.Assign:66.21)
// 3750.3-3752.3: (class anchor.sink.VarDeclStmt:66.21)
// 3753.3-3780.47: (class anchor.sink.ARead:66.21)
// 3765.1-3765.39: (66.21): Cannot have potential null deference in left-mover part.
// 3770.1-3770.22: (66.21): index < 0.
// 3775.1-3775.48: (66.21): index is >= length.
// 3779.1-3779.28: (66.21): Reduction failure
// 3781.3-3786.25: (class anchor.sink.Assert:66.21)
// 3786.1-3786.25: (66.21): This assertion may not hold.
// 3787.3-3789.3: (class anchor.sink.VarDeclStmt:67.17)
// 3790.3-3792.3: (class anchor.sink.VarDeclStmt:67.17)
// 3793.3-3810.30: (class anchor.sink.Read:67.17)
// 3805.1-3805.30: (67.17): Cannot have potential null deference in left-mover part.
// 3809.1-3809.28: (67.17): Reduction failure
// 3811.3-3813.3: (class anchor.sink.VarDeclStmt:67.17)
// 3814.3-3816.3: (class anchor.sink.VarDeclStmt:67.17)
// 3817.3-3834.29: (class anchor.sink.Read:67.17)
// 3829.1-3829.30: (67.17): Cannot have potential null deference in left-mover part.
// 3833.1-3833.28: (67.17): Reduction failure
// 3835.3-3837.3: (class anchor.sink.VarDeclStmt:67.17)
// 3838.3-3840.3: (class anchor.sink.VarDeclStmt:67.17)
// 3841.3-3858.30: (class anchor.sink.Read:67.17)
// 3853.1-3853.30: (67.17): Cannot have potential null deference in left-mover part.
// 3857.1-3857.28: (67.17): Reduction failure
// 3859.3-3862.41: (class anchor.sink.Assign:67.17)
// 3863.3-3866.30: (class anchor.sink.Assign:67.17)
// 3867.3-3894.48: (class anchor.sink.ARead:67.17)
// 3879.1-3879.39: (67.17): Cannot have potential null deference in left-mover part.
// 3884.1-3884.22: (67.17): index < 0.
// 3889.1-3889.48: (67.17): index is >= length.
// 3893.1-3893.28: (67.17): Reduction failure
// 3895.3-3898.229: (class anchor.sink.Assume:68.17)
// 3899.3-3901.3: (class anchor.sink.VarDeclStmt:70.17)
// 3902.3-3904.3: (class anchor.sink.VarDeclStmt:70.17)
// 3905.3-3922.29: (class anchor.sink.Read:70.17)
// 3917.1-3917.30: (70.17): Cannot have potential null deference in left-mover part.
// 3921.1-3921.28: (70.17): Reduction failure
// 3923.3-3925.3: (class anchor.sink.VarDeclStmt:70.17)
// 3926.3-3928.3: (class anchor.sink.VarDeclStmt:70.17)
// 3929.3-3931.3: (class anchor.sink.VarDeclStmt:70.17)
// 3932.3-3949.29: (class anchor.sink.Read:70.17)
// 3944.1-3944.30: (70.17): Cannot have potential null deference in left-mover part.
// 3948.1-3948.28: (70.17): Reduction failure
// 3950.3-3953.30: (class anchor.sink.Assign:70.17)
// 3954.3-3957.22: (class anchor.sink.Assign:70.17)
// 3958.3-3961.42: (class anchor.sink.Assign:70.17)
// 3963.3-3979.29: (class anchor.sink.Write:70.17)
// 3975.1-3975.30: (70.17): Cannot have potential null deference in left-mover part.
// 3978.1-3978.28: (70.17): Reduction failure
// 3980.3-3982.3: (class anchor.sink.VarDeclStmt:71.17)
// 3983.3-3985.3: (class anchor.sink.VarDeclStmt:71.17)
// 3986.3-4003.29: (class anchor.sink.Read:71.17)
// 3998.1-3998.30: (71.17): Cannot have potential null deference in left-mover part.
// 4002.1-4002.28: (71.17): Reduction failure
// 4004.3-4007.22: (class anchor.sink.Assign:71.17)
// 4009.3-4025.29: (class anchor.sink.Write:71.17)
// 4021.1-4021.30: (71.17): Cannot have potential null deference in left-mover part.
// 4024.1-4024.28: (71.17): Reduction failure
// 4029.1-4029.30: (73.13): Cannot have potential null deference in left-mover part.
// 4031.1-4031.35: (73.13): lock not held
// 4033.1-4033.28: (73.13): Reduction failure
// 4035.3-4045.10: (class anchor.sink.Return:72.17)
// 4041.1-4041.295: (72.17): Object invariant may not hold.
// 4042.1-4042.295: (72.17): Object invariant may not hold.
// 4043.1-4043.295: (72.17): Object invariant may not hold.
// 4044.1-4044.295: (72.17): Object invariant may not hold.
// 4049.1-4049.30: (73.13): Cannot have potential null deference in left-mover part.
// 4051.1-4051.35: (73.13): lock not held
// 4053.1-4053.28: (73.13): Reduction failure
// 4056.3-4066.10: (class anchor.sink.Return:75.13)
// 4062.1-4062.295: (75.13): Object invariant may not hold.
// 4063.1-4063.295: (75.13): Object invariant may not hold.
// 4064.1-4064.295: (75.13): Object invariant may not hold.
// 4065.1-4065.295: (75.13): Object invariant may not hold.
// 4068.2-4078.9: (class anchor.sink.Return:59.26)
// 4074.1-4074.294: (59.26): Object invariant may not hold.
// 4075.1-4075.294: (59.26): Object invariant may not hold.
// 4076.1-4076.294: (59.26): Object invariant may not hold.
// 4077.1-4077.294: (59.26): Object invariant may not hold.
// 4204.1-4204.34: (9.5): Queue.elems failed Write-Write Right-Mover Check
// 4254.1-4254.30: (9.5): Queue.elems failed Write-Read Right-Mover Check
// 4308.1-4308.34: (9.5): Queue.elems failed Write-Write Left-Mover Check
// 4359.1-4359.30: (9.5): Queue.elems failed Write-Read Left-Mover Check
// 4407.1-4407.34: (9.5): Queue.elems failed Read-Write Right-Mover Check
// 4458.1-4458.34: (9.5): Queue.elems failed Read-Write Left-Mover Check
// 4508.1-4508.34: (10.5): Queue.head failed Write-Write Right-Mover Check
// 4558.1-4558.30: (10.5): Queue.head failed Write-Read Right-Mover Check
// 4612.1-4612.34: (10.5): Queue.head failed Write-Write Left-Mover Check
// 4663.1-4663.30: (10.5): Queue.head failed Write-Read Left-Mover Check
// 4711.1-4711.34: (10.5): Queue.head failed Read-Write Right-Mover Check
// 4762.1-4762.34: (10.5): Queue.head failed Read-Write Left-Mover Check
// 4812.1-4812.34: (14.5): Queue.tail failed Write-Write Right-Mover Check
// 4862.1-4862.30: (14.5): Queue.tail failed Write-Read Right-Mover Check
// 4916.1-4916.34: (14.5): Queue.tail failed Write-Write Left-Mover Check
// 4967.1-4967.30: (14.5): Queue.tail failed Write-Read Left-Mover Check
// 5015.1-5015.34: (14.5): Queue.tail failed Read-Write Right-Mover Check
// 5066.1-5066.34: (14.5): Queue.tail failed Read-Write Left-Mover Check
// 5116.1-5116.34: (24.5): Queue.spec failed Write-Write Right-Mover Check
// 5166.1-5166.30: (24.5): Queue.spec failed Write-Read Right-Mover Check
// 5220.1-5220.34: (24.5): Queue.spec failed Write-Write Left-Mover Check
// 5271.1-5271.30: (24.5): Queue.spec failed Write-Read Left-Mover Check
// 5319.1-5319.34: (24.5): Queue.spec failed Read-Write Right-Mover Check
// 5370.1-5370.34: (24.5): Queue.spec failed Read-Write Left-Mover Check
// 5424.1-5424.34: (7.5): Array Array.Queue.T failed Write-Write Right-Mover Check
// 5478.1-5478.30: (7.5): Array Array.Queue.T failed Write-Read Right-Mover Check
// 5536.1-5536.34: (7.5): Array Array.Queue.T failed Write-Write Left-Mover Check
// 5591.1-5591.30: (7.5): Array Array.Queue.T failed Write-Read Left-Mover Check
// 5643.1-5643.34: (7.5): Array Array.Queue.T failed Read-Write Right-Mover Check
// 5698.1-5698.34: (7.5): Array Array.Queue.T failed Read-Write Left-Mover Check
// 5779.1-5779.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.1)
// 5780.1-5780.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.2)
// 5781.1-5781.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case A.3)
// 5892.1-5892.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case C)
// 6008.1-6008.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case D)
// 6009.1-6009.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.elems (case R)
// 6090.1-6090.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case F)
// 6091.1-6091.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case H)
// 6092.1-6092.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.elems (case I)
// 6172.1-6172.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case J)
// 6173.1-6173.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case K)
// 6174.1-6174.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.elems (case L)
// 6256.1-6256.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.1)
// 6257.1-6257.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.2)
// 6258.1-6258.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case A.3)
// 6369.1-6369.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case C)
// 6485.1-6485.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case D)
// 6486.1-6486.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case R)
// 6567.1-6567.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case F)
// 6568.1-6568.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case H)
// 6569.1-6569.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.head (case I)
// 6649.1-6649.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case J)
// 6650.1-6650.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case K)
// 6651.1-6651.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.elems (case L)
// 6733.1-6733.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.1)
// 6734.1-6734.101: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.2)
// 6735.1-6735.158: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case A.3)
// 6846.1-6846.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case C)
// 6962.1-6962.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case D)
// 6963.1-6963.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case R)
// 7044.1-7044.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case F)
// 7045.1-7045.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case H)
// 7046.1-7046.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.tail (case I)
// 7126.1-7126.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case J)
// 7127.1-7127.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case K)
// 7128.1-7128.99: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.elems (case L)
// 7210.1-7210.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.1)
// 7211.1-7211.101: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.2)
// 7212.1-7212.158: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case A.3)
// 7323.1-7323.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case C)
// 7439.1-7439.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case D)
// 7440.1-7440.144: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case R)
// 7521.1-7521.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case F)
// 7522.1-7522.136: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case H)
// 7523.1-7523.146: (9.5): Queue.elems is not Read-Write Stable with respect to Queue.spec (case I)
// 7603.1-7603.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case J)
// 7604.1-7604.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case K)
// 7605.1-7605.99: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.elems (case L)
// 7692.1-7692.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.1)
// 7693.1-7693.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.2)
// 7694.1-7694.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case A.3)
// 7812.1-7812.140: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 7935.1-7935.144: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 7936.1-7936.144: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 8022.1-8022.136: (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 8023.1-8023.136: (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 8024.1-8024.144: (9.5): Queue.elems is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 8109.1-8109.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case J)
// 8110.1-8110.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case K)
// 8111.1-8111.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.elems (case L)
// 8193.1-8193.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.1)
// 8194.1-8194.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.2)
// 8195.1-8195.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.head (case A.3)
// 8306.1-8306.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case C)
// 8422.1-8422.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case D)
// 8423.1-8423.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.elems (case R)
// 8504.1-8504.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case F)
// 8505.1-8505.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case H)
// 8506.1-8506.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.elems (case I)
// 8586.1-8586.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case J)
// 8587.1-8587.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case K)
// 8588.1-8588.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.head (case L)
// 8670.1-8670.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.1)
// 8671.1-8671.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.2)
// 8672.1-8672.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case A.3)
// 8783.1-8783.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case C)
// 8899.1-8899.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case D)
// 8900.1-8900.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.head (case R)
// 8981.1-8981.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case F)
// 8982.1-8982.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case H)
// 8983.1-8983.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.head (case I)
// 9063.1-9063.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case J)
// 9064.1-9064.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case K)
// 9065.1-9065.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.head (case L)
// 9147.1-9147.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.1)
// 9148.1-9148.101: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.2)
// 9149.1-9149.158: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case A.3)
// 9260.1-9260.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case C)
// 9376.1-9376.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case D)
// 9377.1-9377.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case R)
// 9458.1-9458.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case F)
// 9459.1-9459.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case H)
// 9460.1-9460.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.tail (case I)
// 9540.1-9540.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case J)
// 9541.1-9541.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case K)
// 9542.1-9542.99: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.head (case L)
// 9624.1-9624.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.1)
// 9625.1-9625.101: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.2)
// 9626.1-9626.158: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case A.3)
// 9737.1-9737.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case C)
// 9853.1-9853.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case D)
// 9854.1-9854.144: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case R)
// 9935.1-9935.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case F)
// 9936.1-9936.136: (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case H)
// 9937.1-9937.146: (10.5): Queue.head is not Read-Write Stable with respect to Queue.spec (case I)
// 10017.1-10017.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case J)
// 10018.1-10018.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case K)
// 10019.1-10019.99: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.head (case L)
// 10106.1-10106.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.1)
// 10107.1-10107.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.2)
// 10108.1-10108.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case A.3)
// 10226.1-10226.140: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 10349.1-10349.144: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 10350.1-10350.144: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 10436.1-10436.136: (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 10437.1-10437.136: (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 10438.1-10438.144: (10.5): Queue.head is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 10523.1-10523.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case J)
// 10524.1-10524.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case K)
// 10525.1-10525.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.head (case L)
// 10607.1-10607.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.1)
// 10608.1-10608.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.2)
// 10609.1-10609.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.tail (case A.3)
// 10720.1-10720.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case C)
// 10836.1-10836.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case D)
// 10837.1-10837.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.elems (case R)
// 10918.1-10918.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case F)
// 10919.1-10919.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case H)
// 10920.1-10920.146: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.elems (case I)
// 11000.1-11000.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case J)
// 11001.1-11001.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case K)
// 11002.1-11002.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.tail (case L)
// 11084.1-11084.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.1)
// 11085.1-11085.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.2)
// 11086.1-11086.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.tail (case A.3)
// 11197.1-11197.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case C)
// 11313.1-11313.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case D)
// 11314.1-11314.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.head (case R)
// 11395.1-11395.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case F)
// 11396.1-11396.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case H)
// 11397.1-11397.146: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.head (case I)
// 11477.1-11477.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case J)
// 11478.1-11478.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case K)
// 11479.1-11479.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.tail (case L)
// 11561.1-11561.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.1)
// 11562.1-11562.101: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.2)
// 11563.1-11563.158: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case A.3)
// 11674.1-11674.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case C)
// 11790.1-11790.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case D)
// 11791.1-11791.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.tail (case R)
// 11872.1-11872.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case F)
// 11873.1-11873.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case H)
// 11874.1-11874.146: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.tail (case I)
// 11954.1-11954.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case J)
// 11955.1-11955.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case K)
// 11956.1-11956.99: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.tail (case L)
// 12038.1-12038.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.1)
// 12039.1-12039.101: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.2)
// 12040.1-12040.158: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case A.3)
// 12151.1-12151.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case C)
// 12267.1-12267.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case D)
// 12268.1-12268.144: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case R)
// 12349.1-12349.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case F)
// 12350.1-12350.136: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case H)
// 12351.1-12351.146: (14.5): Queue.tail is not Read-Write Stable with respect to Queue.spec (case I)
// 12431.1-12431.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case J)
// 12432.1-12432.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case K)
// 12433.1-12433.99: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.tail (case L)
// 12520.1-12520.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.1)
// 12521.1-12521.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.2)
// 12522.1-12522.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case A.3)
// 12640.1-12640.140: (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 12763.1-12763.144: (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 12764.1-12764.144: (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 12850.1-12850.136: (14.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 12851.1-12851.136: (14.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 12852.1-12852.144: (14.5): Queue.tail is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 12937.1-12937.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case J)
// 12938.1-12938.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case K)
// 12939.1-12939.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.tail (case L)
// 13021.1-13021.140: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.1)
// 13022.1-13022.101: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.2)
// 13023.1-13023.158: (9.5): Queue.elems is not Write-Write Stable with respect to Queue.spec (case A.3)
// 13134.1-13134.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case C)
// 13250.1-13250.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case D)
// 13251.1-13251.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.elems (case R)
// 13332.1-13332.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case F)
// 13333.1-13333.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case H)
// 13334.1-13334.146: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.elems (case I)
// 13414.1-13414.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case J)
// 13415.1-13415.136: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case K)
// 13416.1-13416.99: (9.5): Queue.elems is not Write-Read Stable with respect to Queue.spec (case L)
// 13498.1-13498.140: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.1)
// 13499.1-13499.101: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.2)
// 13500.1-13500.158: (10.5): Queue.head is not Write-Write Stable with respect to Queue.spec (case A.3)
// 13611.1-13611.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case C)
// 13727.1-13727.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case D)
// 13728.1-13728.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.head (case R)
// 13809.1-13809.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case F)
// 13810.1-13810.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case H)
// 13811.1-13811.146: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.head (case I)
// 13891.1-13891.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case J)
// 13892.1-13892.136: (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case K)
// 13893.1-13893.99: (10.5): Queue.head is not Write-Read Stable with respect to Queue.spec (case L)
// 13975.1-13975.140: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.1)
// 13976.1-13976.101: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.2)
// 13977.1-13977.158: (14.5): Queue.tail is not Write-Write Stable with respect to Queue.spec (case A.3)
// 14088.1-14088.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case C)
// 14204.1-14204.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case D)
// 14205.1-14205.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.tail (case R)
// 14286.1-14286.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case F)
// 14287.1-14287.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case H)
// 14288.1-14288.146: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.tail (case I)
// 14368.1-14368.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case J)
// 14369.1-14369.136: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case K)
// 14370.1-14370.99: (14.5): Queue.tail is not Write-Read Stable with respect to Queue.spec (case L)
// 14452.1-14452.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.1)
// 14453.1-14453.101: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.2)
// 14454.1-14454.158: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case A.3)
// 14565.1-14565.140: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case C)
// 14681.1-14681.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case D)
// 14682.1-14682.144: (24.5): Queue.spec is not Write-Write Stable with respect to Queue.spec (case R)
// 14763.1-14763.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case F)
// 14764.1-14764.136: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case H)
// 14765.1-14765.146: (24.5): Queue.spec is not Read-Write Stable with respect to Queue.spec (case I)
// 14845.1-14845.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case J)
// 14846.1-14846.136: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case K)
// 14847.1-14847.99: (24.5): Queue.spec is not Write-Read Stable with respect to Queue.spec (case L)
// 14934.1-14934.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.1)
// 14935.1-14935.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.2)
// 14936.1-14936.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case A.3)
// 15054.1-15054.140: (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 15177.1-15177.144: (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 15178.1-15178.144: (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 15264.1-15264.136: (24.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 15265.1-15265.136: (24.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 15266.1-15266.144: (24.5): Queue.spec is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 15351.1-15351.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case J)
// 15352.1-15352.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case K)
// 15353.1-15353.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Queue.spec (case L)
// 15440.1-15440.140: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 15441.1-15441.101: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 15442.1-15442.156: (9.5): Queue.elems is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 15560.1-15560.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case C)
// 15683.1-15683.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case D)
// 15684.1-15684.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.elems (case R)
// 15770.1-15770.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case F)
// 15771.1-15771.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case H)
// 15772.1-15772.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.elems (case I)
// 15857.1-15857.136: (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 15858.1-15858.136: (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 15859.1-15859.99: (9.5): Queue.elems is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 15946.1-15946.140: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 15947.1-15947.101: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 15948.1-15948.156: (10.5): Queue.head is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 16066.1-16066.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case C)
// 16189.1-16189.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case D)
// 16190.1-16190.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.head (case R)
// 16276.1-16276.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case F)
// 16277.1-16277.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case H)
// 16278.1-16278.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.head (case I)
// 16363.1-16363.136: (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 16364.1-16364.136: (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 16365.1-16365.99: (10.5): Queue.head is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 16452.1-16452.140: (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 16453.1-16453.101: (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 16454.1-16454.156: (14.5): Queue.tail is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 16572.1-16572.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case C)
// 16695.1-16695.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case D)
// 16696.1-16696.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.tail (case R)
// 16782.1-16782.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case F)
// 16783.1-16783.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case H)
// 16784.1-16784.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.tail (case I)
// 16869.1-16869.136: (14.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 16870.1-16870.136: (14.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 16871.1-16871.99: (14.5): Queue.tail is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 16958.1-16958.140: (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 16959.1-16959.101: (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 16960.1-16960.156: (24.5): Queue.spec is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 17078.1-17078.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case C)
// 17201.1-17201.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case D)
// 17202.1-17202.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Queue.spec (case R)
// 17288.1-17288.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case F)
// 17289.1-17289.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case H)
// 17290.1-17290.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Queue.spec (case I)
// 17375.1-17375.136: (24.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 17376.1-17376.136: (24.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 17377.1-17377.99: (24.5): Queue.spec is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 17469.1-17469.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.1)
// 17470.1-17470.101: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.2)
// 17471.1-17471.156: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case A.3)
// 17596.1-17596.140: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case C)
// 17726.1-17726.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case D)
// 17727.1-17727.144: (7.5): Array Array.Queue.T is not Write-Write Stable with respect to Array Array.Queue.T (case R)
// 17818.1-17818.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case F)
// 17819.1-17819.136: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case H)
// 17820.1-17820.144: (7.5): Array Array.Queue.T is not Read-Write Stable with respect to Array Array.Queue.T (case I)
// 17910.1-17910.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case J)
// 17911.1-17911.136: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case K)
// 17912.1-17912.99: (7.5): Array Array.Queue.T is not Write-Read Stable with respect to Array Array.Queue.T (case L)
// 17919.1-17919.295: (<undefined position>): Object invariant may not hold.
// 17920.1-17920.295: (<undefined position>): Object invariant may not hold.
// 17921.1-17921.295: (<undefined position>): Object invariant may not hold.
// 17922.1-17922.295: (<undefined position>): Object invariant may not hold.
// 17933.1-17933.294: (<undefined position>): Object invariant may not hold.
// 17934.1-17934.294: (<undefined position>): Object invariant may not hold.
// 17935.1-17935.294: (<undefined position>): Object invariant may not hold.
// 17936.1-17936.294: (<undefined position>): Object invariant may not hold.
// 17950.1-17973.2: (9.24): yields_as clause for Queue.elems is not valid
// 17978.1-17998.2: (9.24): yields_as clause for Queue.elems is not reflexive
// 18004.1-18004.295: (9.24): Object invariant may not hold.
// 18005.1-18005.295: (9.24): Object invariant may not hold.
// 18006.1-18006.295: (9.24): Object invariant may not hold.
// 18007.1-18007.295: (9.24): Object invariant may not hold.
// 18008.1-18048.2: (9.24): yields_as clause for Queue.elems is not transitive
// 18061.1-18084.2: (10.33): yields_as clause for Queue.head is not valid
// 18089.1-18109.2: (10.33): yields_as clause for Queue.head is not reflexive
// 18115.1-18115.295: (10.33): Object invariant may not hold.
// 18116.1-18116.295: (10.33): Object invariant may not hold.
// 18117.1-18117.295: (10.33): Object invariant may not hold.
// 18118.1-18118.295: (10.33): Object invariant may not hold.
// 18119.1-18159.2: (10.33): yields_as clause for Queue.head is not transitive
// 18172.1-18195.2: (14.33): yields_as clause for Queue.tail is not valid
// 18200.1-18220.2: (14.33): yields_as clause for Queue.tail is not reflexive
// 18226.1-18226.295: (14.33): Object invariant may not hold.
// 18227.1-18227.295: (14.33): Object invariant may not hold.
// 18228.1-18228.295: (14.33): Object invariant may not hold.
// 18229.1-18229.295: (14.33): Object invariant may not hold.
// 18230.1-18270.2: (14.33): yields_as clause for Queue.tail is not transitive
// 18283.1-18306.2: (24.37): yields_as clause for Queue.spec is not valid
// 18311.1-18331.2: (24.37): yields_as clause for Queue.spec is not reflexive
// 18337.1-18337.295: (24.37): Object invariant may not hold.
// 18338.1-18338.295: (24.37): Object invariant may not hold.
// 18339.1-18339.295: (24.37): Object invariant may not hold.
// 18340.1-18340.295: (24.37): Object invariant may not hold.
// 18341.1-18381.2: (24.37): yields_as clause for Queue.spec is not transitive
// 18395.1-18418.2: (7.32): yields_as clause for Queue._lock is not valid
// 18423.1-18443.2: (7.32): yields_as clause for Queue._lock is not reflexive
// 18449.1-18449.295: (3.1): Object invariant may not hold.
// 18450.1-18450.295: (3.1): Object invariant may not hold.
// 18451.1-18451.295: (3.1): Object invariant may not hold.
// 18452.1-18452.295: (3.1): Object invariant may not hold.
// 18453.1-18493.2: (7.32): yields_as clause for Queue._lock is not transitive
// 18503.1-18532.2: (7.28): yields_as clause for Array.Queue.T is not valid
// 18533.1-18559.2: (7.28): yields_as clause for Array.Queue.T is not reflexive
// 18564.1-18564.295: (7.28): Object invariant may not hold.
// 18565.1-18565.295: (7.28): Object invariant may not hold.
// 18566.1-18566.295: (7.28): Object invariant may not hold.
// 18567.1-18567.295: (7.28): Object invariant may not hold.
// 18568.1-18612.2: (7.28): yields_as clause for Array.Queue.T is not transitive
