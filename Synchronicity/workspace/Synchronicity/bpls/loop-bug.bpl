                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/artifact/Synchronicity/workspace/Synchronicity/tests/loop-bug.anchor:                        
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Ref pair isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       AtomicMarkableReference next isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  forall Node n ::n != this ==> n.next != this.next;                                 
      invariant  this.next != AtomicMarkableReference.null;                                         
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next.pair.reference != Node.null ==> this.item < this.next.pair.reference.item;
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == AtomicMarkableReference.null;                                           
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.next.pair.reference != Node.null;                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) break; else {                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            assert false /* == false */;                                                            
          }                                                                                         
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Ref pair isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       AtomicMarkableReference next isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall Node n ::n != this ==> n.next != this.next;                                 
      invariant  this.next != AtomicMarkableReference.null;                                         
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next.pair.reference != Node.null ==> this.item < this.next.pair.reference.item;
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == AtomicMarkableReference.null;                                           
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.next.pair.reference != Node.null;                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            assert false /* == false */;                                                            
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Ref pair isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       AtomicMarkableReference next isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall Node n ::n != this ==> n.next != this.next;                                 
      invariant  this.next != AtomicMarkableReference.null;                                         
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next.pair.reference != Node.null ==> this.item < this.next.pair.reference.item;
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == AtomicMarkableReference.null;                                           
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.next.pair.reference != Node.null;                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            assert false /* == false */;                                                            
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Ref {                                                                                     
       Node reference isLocal(this, tid)                                                            
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.reference == Node.null;                                                         
        assume this.mark == false;                                                                  
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Ref pair isLocal(this, tid)                                                          
       ? isLocal(this, tid) ? B : E                                                                 
       : N                                                                                          
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.pair != Ref.null;                                                             
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.pair == Ref.null;                                                               
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Node {                                                                                    
       int item isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       AtomicMarkableReference next isLocal(this, tid)                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  forall Node n ::n != this ==> n.next != this.next;                                 
      invariant  this.next != AtomicMarkableReference.null;                                         
      invariant  -1073741824 <= this.item && this.item <= 1073741823;                               
      invariant  this.next.pair.reference != Node.null ==> this.item < this.next.pair.reference.item;
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.item == 0;                                                                      
        assume this.next == AtomicMarkableReference.null;                                           
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class List {                                                                                    
       Node head isLocal(this, tid)                                                                 
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
      invariant  this.head != Node.null && this.head.item == -1073741824;                           
      invariant  this.head.next.pair.reference != Node.null;                                        
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.head == Node.null;                                                              
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
      requires -1073741824 < item && item < 1073741823;                                             
                                                                                                    
      public boolean add(int item) {                                                                
        while (true)   {                                                                            
          boolean tmp1;                                                                             
          tmp1 = true;                                                                              
          if (!tmp1) {                                                                              
            break;                                                                                  
          } else {                                                                                  
                                                                                                    
          }                                                                                         
          {                                                                                         
            assert false /* == false */;                                                            
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Ref ***/                                                                            
                                                                                                    
type Ref;                                                                                           
const unique Ref.null: Ref;                                                                         
var Ref._state: [Ref]State;                                                                         
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Ref.reference: [Ref]Node;                                                                       
                                                                                                    
function {:inline} ReadEval.Ref.reference(tid: Tid,this : Ref,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Ref.reference(tid: Tid,this : Ref,newValue: Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Ref.mark: [Ref]bool;                                                                            
                                                                                                    
function {:inline} ReadEval.Ref.mark(tid: Tid,this : Ref,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := false;                                                                            
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Ref.mark(tid: Tid,this : Ref,newValue: bool,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isLocal(Ref._state[this], tid)) then                                                          
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Ref._lock: [Ref]Tid;                                                                            
                                                                                                    
function {:inline} ReadEval.Ref._lock(tid: Tid,this : Ref,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Ref._lock[this]==tid)) then                                                                 
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Ref._lock[this]==Tid.null)&&(newValue==tid))) then                                         
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Ref._lock[this]==tid)&&(newValue==Tid.null))) then                                        
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Ref._lock(tid: Tid,this : Ref,newValue: Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Ref._state[this], tid)) then                                                           
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Ref._lock[this]==tid)) then                                                                 
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Ref._lock[this]==Tid.null)&&(newValue==tid))) then                                         
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Ref._lock[this]==tid)&&(newValue==Tid.null))) then                                        
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl AtomicMarkableReference ***/                                                        
                                                                                                    
type AtomicMarkableReference;                                                                       
const unique AtomicMarkableReference.null: AtomicMarkableReference;                                 
var AtomicMarkableReference._state: [AtomicMarkableReference]State;                                 
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.pair: [AtomicMarkableReference]Ref;                                     
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.pair(tid: Tid,this : AtomicMarkableReference,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Ref.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isLocal(AtomicMarkableReference._state[this], tid)) then                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.pair(tid: Tid,this : AtomicMarkableReference,newValue: Ref,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isLocal(AtomicMarkableReference._state[this], tid)) then                                      
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  moverPath(_N, 0)                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference._lock: [AtomicMarkableReference]Tid;                                    
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,newValue: Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.AtomicMarkableReference.2454159(tid: Tid,this : AtomicMarkableReference,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 (AtomicMarkableReference.pair[this]!=Ref.null)                                                     
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Node ***/                                                                           
                                                                                                    
type Node;                                                                                          
const unique Node.null: Node;                                                                       
var Node._state: [Node]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.item: [Node]int;                                                                           
                                                                                                    
function {:inline} ReadEval.Node.item(tid: Tid,this : Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := 0;                                                                                
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.item(tid: Tid,this : Node,newValue: int,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node.next: [Node]AtomicMarkableReference;                                                       
                                                                                                    
function {:inline} ReadEval.Node.next(tid: Tid,this : Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := AtomicMarkableReference.null;                                                     
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node.next(tid: Tid,this : Node,newValue: AtomicMarkableReference,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isLocal(Node._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var Node._lock: [Node]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Node._lock(tid: Tid,this : Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Node._lock(tid: Tid,this : Node,newValue: Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Node._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Node._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Node._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Node._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.Node.2454323(tid: Tid,this : Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 (forall n: Node ::  (((n!=this)==>(Node.next[n]!=Node.next[this]))))                               
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2454331(tid: Tid,this : Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 (Node.next[this]!=AtomicMarkableReference.null)                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2454346(tid: Tid,this : Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((-1073741824<=Node.item[this])&&(Node.item[this]<=1073741823))                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Node.2454367(tid: Tid,this : Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((Ref.reference[AtomicMarkableReference.pair[Node.next[this]]]!=Node.null)==>(Node.item[this]<Node.item[Ref.reference[AtomicMarkableReference.pair[Node.next[this]]]]))
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl List ***/                                                                           
                                                                                                    
type List;                                                                                          
const unique List.null: List;                                                                       
var List._state: [List]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var List.head: [List]Node;                                                                          
                                                                                                    
function {:inline} ReadEval.List.head(tid: Tid,this : List,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Node.null;                                                                        
 if (isLocal(List._state[this], tid)) then                                                          
  if (isLocal(List._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.List.head(tid: Tid,this : List,newValue: Node,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(List._state[this], tid)) then                                                          
  if (isLocal(List._state[this], tid)) then                                                         
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var List._lock: [List]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.List._lock(tid: Tid,this : List,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(List._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((List._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((List._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((List._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.List._lock(tid: Tid,this : List,newValue: Tid,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(List._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((List._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((List._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((List._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
function {:inline} Invariant.List.2454554(tid: Tid,this : List,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 ((List.head[this]!=Node.null)&&(Node.item[List.head[this]]==-1073741824))                          
}                                                                                                   
                                                                                                    
function {:inline} Invariant.List.2454565(tid: Tid,this : List,Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
 (Ref.reference[AtomicMarkableReference.pair[Node.next[List.head[this]]]]!=Node.null)               
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  List.add(tid:Tid, this : List, item : int)                                               
returns ($result : bool)                                                                            
modifies Ref._state;                                                                                
modifies Ref.reference;                                                                             
modifies Ref.mark;                                                                                  
modifies Ref._lock;                                                                                 
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (43.5): Bad tid
requires isShared(List._state[this]);                                                                      // (43.5): this is not global
                                                                                                    
requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
requires ((-1073741824<item)&&(item<1073741823));                                                   
                                                                                                    
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
                                                                                                    
ensures StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (43.5): Object invariant may not hold.
{                                                                                                   
 var Ref.mark2460502: [Ref]bool;                                                                    
 var $result2460499_bottom: bool;                                                                   
 var item2460499_bottom: int;                                                                       
 var Node.item2460499_bottom: [Node]int;                                                            
 var List._lock2460499_bottom: [List]Tid;                                                           
 var AtomicMarkableReference._lock2460499_bottom: [AtomicMarkableReference]Tid;                     
 var $pc2460496: Phase;                                                                             
 var Ref._lock2460499: [Ref]Tid;                                                                    
 var $pc2460499_bottom: Phase;                                                                      
 var List.head2460496: [List]Node;                                                                  
 var AtomicMarkableReference._state2460502: [AtomicMarkableReference]State;                         
 var tid2460502: Tid;                                                                               
 var Ref.mark2460496: [Ref]bool;                                                                    
 var List._state2460499_bottom: [List]State;                                                        
 var AtomicMarkableReference._state2460496: [AtomicMarkableReference]State;                         
 var List._lock2460496: [List]Tid;                                                                  
 var this2460499: List;                                                                             
 var $pc2460499: Phase;                                                                             
 var Node.item2460496: [Node]int;                                                                   
 var List.head2460499_bottom: [List]Node;                                                           
 var tmp1: bool;                                                                                    
 var tid2460499: Tid;                                                                               
 var Node._state2460502: [Node]State;                                                               
 var List._state2460499: [List]State;                                                               
 var tmp12460496: bool;                                                                             
 var $recorded.state2460499_bottom: int;                                                            
 var $result2460499: bool;                                                                          
 var Node.next2460496: [Node]AtomicMarkableReference;                                               
 var Ref._lock2460499_bottom: [Ref]Tid;                                                             
 var AtomicMarkableReference._lock2460496: [AtomicMarkableReference]Tid;                            
 var Ref._state2460502: [Ref]State;                                                                 
 var Node._lock2460496: [Node]Tid;                                                                  
 var Node.next2460499: [Node]AtomicMarkableReference;                                               
 var List._lock2460499: [List]Tid;                                                                  
 var tid2460496: Tid;                                                                               
 var AtomicMarkableReference._lock2460502: [AtomicMarkableReference]Tid;                            
 var Ref.mark2460499: [Ref]bool;                                                                    
 var item2460496: int;                                                                              
 var Node._state2460499_bottom: [Node]State;                                                        
 var AtomicMarkableReference.pair2460499_bottom: [AtomicMarkableReference]Ref;                      
 var $recorded.state2460499: int;                                                                   
 var AtomicMarkableReference.pair2460499: [AtomicMarkableReference]Ref;                             
 var $result2460502: bool;                                                                          
 var this2460499_bottom: List;                                                                      
 var item2460502: int;                                                                              
 var List.head2460502: [List]Node;                                                                  
 var Ref.reference2460502: [Ref]Node;                                                               
 var Ref._lock2460496: [Ref]Tid;                                                                    
 var item2460499: int;                                                                              
 var AtomicMarkableReference._state2460499_bottom: [AtomicMarkableReference]State;                  
 var tid2460499_bottom: Tid;                                                                        
 var Node.item2460502: [Node]int;                                                                   
 var Node._lock2460499_bottom: [Node]Tid;                                                           
 var Node.next2460499_bottom: [Node]AtomicMarkableReference;                                        
 var List._state2460502: [List]State;                                                               
 var Node._state2460499: [Node]State;                                                               
 var Node.item2460499: [Node]int;                                                                   
 var Ref._state2460499_bottom: [Ref]State;                                                          
 var this2460502: List;                                                                             
 var $recorded.state2460496: int;                                                                   
 var List.head2460499: [List]Node;                                                                  
 var Ref.reference2460499_bottom: [Ref]Node;                                                        
 var $pc2460502: Phase;                                                                             
 var Node._state2460496: [Node]State;                                                               
 var Node._lock2460499: [Node]Tid;                                                                  
 var Ref._lock2460502: [Ref]Tid;                                                                    
 var Ref.reference2460496: [Ref]Node;                                                               
 var Node._lock2460502: [Node]Tid;                                                                  
 var $result2460496: bool;                                                                          
 var Ref.reference2460499: [Ref]Node;                                                               
 var List._lock2460502: [List]Tid;                                                                  
 var this2460496: List;                                                                             
 var Ref.mark2460499_bottom: [Ref]bool;                                                             
 var AtomicMarkableReference._state2460499: [AtomicMarkableReference]State;                         
 var List._state2460496: [List]State;                                                               
 var AtomicMarkableReference.pair2460502: [AtomicMarkableReference]Ref;                             
 var phase2460499: Phase;                                                                           
 var AtomicMarkableReference._lock2460499: [AtomicMarkableReference]Tid;                            
 var Node.next2460502: [Node]AtomicMarkableReference;                                               
 var Ref._state2460496: [Ref]State;                                                                 
 var AtomicMarkableReference.pair2460496: [AtomicMarkableReference]Ref;                             
 var $recorded.state2460502: int;                                                                   
 var Ref._state2460499: [Ref]State;                                                                 
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
 assert true;                                                                                              // (43.29): Can only have right-mover memory accesses in requires clause
                                                                                                    
 assume Ref._state2460499 == Ref._state && Ref.reference2460499 == Ref.reference && Ref.mark2460499 == Ref.mark && Ref._lock2460499 == Ref._lock && AtomicMarkableReference._state2460499 == AtomicMarkableReference._state && AtomicMarkableReference.pair2460499 == AtomicMarkableReference.pair && AtomicMarkableReference._lock2460499 == AtomicMarkableReference._lock && Node._state2460499 == Node._state && Node.item2460499 == Node.item && Node.next2460499 == Node.next && Node._lock2460499 == Node._lock && List._state2460499 == List._state && List.head2460499 == List.head && List._lock2460499 == List._lock && $result2460499 == $result && item2460499 == item && this2460499 == this && tid2460499 == tid;
 assume $recorded.state2460499 == 1;                                                                
                                                                                                    
 // 45.7: while (true)   {                                                                          
                                                                                                    
 phase2460499 := $pc;                                                                               
 while (true)                                                                                       
                                                                                                    
  invariant ValidTid(tid);                                                                                 // (43.5): Bad tid
  invariant isShared(List._state[this]);                                                                   // (43.5): this is not global
                                                                                                    
  invariant StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
  invariant  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (45.7): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (45.7): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (45.7): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (45.7): Object invariant may not hold.
  invariant  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (45.7): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (45.7): Object invariant may not hold.
  invariant  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (45.7): Object invariant may not hold.
  invariant (forall _this : Ref :: Invariant.Y_Ref.reference(tid : Tid, _this, Ref.reference[_this] ,Ref._state2460499,Ref.reference2460499,Ref.mark2460499,Ref._lock2460499,AtomicMarkableReference._state2460499,AtomicMarkableReference.pair2460499,AtomicMarkableReference._lock2460499,Node._state2460499,Node.item2460499,Node.next2460499,Node._lock2460499,List._state2460499,List.head2460499,List._lock2460499));       // (45.7): Loop does not preserve yields_as annotation for field reference
  invariant (forall _this : Ref :: Invariant.Y_Ref.mark(tid : Tid, _this, Ref.mark[_this] ,Ref._state2460499,Ref.reference2460499,Ref.mark2460499,Ref._lock2460499,AtomicMarkableReference._state2460499,AtomicMarkableReference.pair2460499,AtomicMarkableReference._lock2460499,Node._state2460499,Node.item2460499,Node.next2460499,Node._lock2460499,List._state2460499,List.head2460499,List._lock2460499));       // (45.7): Loop does not preserve yields_as annotation for field mark
  invariant (forall _this : AtomicMarkableReference :: Invariant.Y_AtomicMarkableReference.pair(tid : Tid, _this, AtomicMarkableReference.pair[_this] ,Ref._state2460499,Ref.reference2460499,Ref.mark2460499,Ref._lock2460499,AtomicMarkableReference._state2460499,AtomicMarkableReference.pair2460499,AtomicMarkableReference._lock2460499,Node._state2460499,Node.item2460499,Node.next2460499,Node._lock2460499,List._state2460499,List.head2460499,List._lock2460499));       // (45.7): Loop does not preserve yields_as annotation for field pair
  invariant (forall _this : Node :: Invariant.Y_Node.item(tid : Tid, _this, Node.item[_this] ,Ref._state2460499,Ref.reference2460499,Ref.mark2460499,Ref._lock2460499,AtomicMarkableReference._state2460499,AtomicMarkableReference.pair2460499,AtomicMarkableReference._lock2460499,Node._state2460499,Node.item2460499,Node.next2460499,Node._lock2460499,List._state2460499,List.head2460499,List._lock2460499));       // (45.7): Loop does not preserve yields_as annotation for field item
  invariant (forall _this : Node :: Invariant.Y_Node.next(tid : Tid, _this, Node.next[_this] ,Ref._state2460499,Ref.reference2460499,Ref.mark2460499,Ref._lock2460499,AtomicMarkableReference._state2460499,AtomicMarkableReference.pair2460499,AtomicMarkableReference._lock2460499,Node._state2460499,Node.item2460499,Node.next2460499,Node._lock2460499,List._state2460499,List.head2460499,List._lock2460499));       // (45.7): Loop does not preserve yields_as annotation for field next
  invariant (forall _this : List :: Invariant.Y_List.head(tid : Tid, _this, List.head[_this] ,Ref._state2460499,Ref.reference2460499,Ref.mark2460499,Ref._lock2460499,AtomicMarkableReference._state2460499,AtomicMarkableReference.pair2460499,AtomicMarkableReference._lock2460499,Node._state2460499,Node.item2460499,Node.next2460499,Node._lock2460499,List._state2460499,List.head2460499,List._lock2460499));       // (45.7): Loop does not preserve yields_as annotation for field head
  invariant phase2460499 == $pc;                                                                           // (45.7): Phase must be invariant at loop head
  invariant $pc == PreCommit;                                                                              // (45.7): Potentially infinite loop cannot be in post-commit phase.
 {                                                                                                  
                                                                                                    
  // 45.14: boolean tmp1;                                                                           
                                                                                                    
                                                                                                    
  // 45.14: tmp1 = true;                                                                            
                                                                                                    
  tmp1 := true;                                                                                     
  if (!(tmp1)) {                                                                                    
                                                                                                    
   // 45.7: break;                                                                                  
                                                                                                    
   break;                                                                                           
  } else {                                                                                          
  }                                                                                                 
                                                                                                    
  // 47.9: assert false /* == false */;                                                             
                                                                                                    
  assume Ref._state2460496 == Ref._state && Ref.reference2460496 == Ref.reference && Ref.mark2460496 == Ref.mark && Ref._lock2460496 == Ref._lock && AtomicMarkableReference._state2460496 == AtomicMarkableReference._state && AtomicMarkableReference.pair2460496 == AtomicMarkableReference.pair && AtomicMarkableReference._lock2460496 == AtomicMarkableReference._lock && Node._state2460496 == Node._state && Node.item2460496 == Node.item && Node.next2460496 == Node.next && Node._lock2460496 == Node._lock && List._state2460496 == List._state && List.head2460496 == List.head && List._lock2460496 == List._lock && tmp12460496 == tmp1 && $result2460496 == $result && item2460496 == item && this2460496 == this && tid2460496 == tid;
  assume $recorded.state2460496 == 1;                                                               
  assert false /* lowered false */;                                                                        // (47.9): This assertion may not hold.
  assume Ref._state2460499_bottom == Ref._state && Ref.reference2460499_bottom == Ref.reference && Ref.mark2460499_bottom == Ref.mark && Ref._lock2460499_bottom == Ref._lock && AtomicMarkableReference._state2460499_bottom == AtomicMarkableReference._state && AtomicMarkableReference.pair2460499_bottom == AtomicMarkableReference.pair && AtomicMarkableReference._lock2460499_bottom == AtomicMarkableReference._lock && Node._state2460499_bottom == Node._state && Node.item2460499_bottom == Node.item && Node.next2460499_bottom == Node.next && Node._lock2460499_bottom == Node._lock && List._state2460499_bottom == List._state && List.head2460499_bottom == List.head && List._lock2460499_bottom == List._lock && $result2460499_bottom == $result && item2460499_bottom == item && this2460499_bottom == this && tid2460499_bottom == tid;
  assume $recorded.state2460499_bottom == 1;                                                        
  assert phase2460499 == $pc;                                                                              // (45.7): Phase must be invariant at loop head
 }                                                                                                  
                                                                                                    
 // 44.34: // return false;                                                                         
                                                                                                    
 assume Ref._state2460502 == Ref._state && Ref.reference2460502 == Ref.reference && Ref.mark2460502 == Ref.mark && Ref._lock2460502 == Ref._lock && AtomicMarkableReference._state2460502 == AtomicMarkableReference._state && AtomicMarkableReference.pair2460502 == AtomicMarkableReference.pair && AtomicMarkableReference._lock2460502 == AtomicMarkableReference._lock && Node._state2460502 == Node._state && Node.item2460502 == Node.item && Node.next2460502 == Node.next && Node._lock2460502 == Node._lock && List._state2460502 == List._state && List.head2460502 == List.head && List._lock2460502 == List._lock && $result2460502 == $result && item2460502 == item && this2460502 == this && tid2460502 == tid;
 assume $recorded.state2460502 == 1;                                                                
 $result := false;                                                                                  
 assert  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (44.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (44.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (44.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (44.34): Object invariant may not hold.
 assert  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (44.34): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (44.34): Object invariant may not hold.
 assert  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (44.34): Object invariant may not hold.
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Ref._state: [Ref]State,Ref.reference: [Ref]Node,Ref.mark: [Ref]bool,Ref._lock: [Ref]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.pair: [AtomicMarkableReference]Ref,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Node._state: [Node]State,Node.item: [Node]int,Node.next: [Node]AtomicMarkableReference,Node._lock: [Node]Tid,List._state: [List]State,List.head: [List]Node,List._lock: [List]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Ref  :: _i == Ref.null <==> isNull(Ref._state[_i])) &&                                
  (forall _i: AtomicMarkableReference  :: _i == AtomicMarkableReference.null <==> isNull(AtomicMarkableReference._state[_i])) &&
  (forall _i: Node  :: _i == Node.null <==> isNull(Node._state[_i])) &&                             
  (forall _i: List  :: _i == List.null <==> isNull(List._state[_i])) &&                             
  (forall _i: Ref ::  (isShared(Ref._state[_i]) ==> isSharedAssignable(Node._state[Ref.reference[_i]]))) &&
  (forall _i: Ref ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Ref._state[_i],_t) ==> isLocalAssignable(Node._state[Ref.reference[_i]], _t)))) &&
  (forall _i: AtomicMarkableReference ::  (isShared(AtomicMarkableReference._state[_i]) ==> isSharedAssignable(Ref._state[AtomicMarkableReference.pair[_i]]))) &&
  (forall _i: AtomicMarkableReference ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(AtomicMarkableReference._state[_i],_t) ==> isLocalAssignable(Ref._state[AtomicMarkableReference.pair[_i]], _t)))) &&
  (forall _i: Node ::  (isShared(Node._state[_i]) ==> isSharedAssignable(AtomicMarkableReference._state[Node.next[_i]]))) &&
  (forall _i: Node ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(Node._state[_i],_t) ==> isLocalAssignable(AtomicMarkableReference._state[Node.next[_i]], _t)))) &&
  (forall _i: List ::  (isShared(List._state[_i]) ==> isSharedAssignable(Node._state[List.head[_i]]))) &&
  (forall _i: List ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(List._state[_i],_t) ==> isLocalAssignable(Node._state[List.head[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)      
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.5): Ref.reference failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)       
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Ref.reference(u: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (4.5): Ref.reference failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)       
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Ref.reference[x];                                                                      
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Ref.reference[x] := havocValue;                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (4.5): Ref.reference failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)        
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == Ref.reference[x];                                                                      
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Ref.reference(u: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (4.5): Ref.reference failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)            
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.5): Ref.reference failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, x: Ref)             
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == Ref.reference[x];                                                                      
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Ref.reference[x] := havocValue;                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,x: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (4.5): Ref.reference failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)           
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.mark failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)            
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Ref.mark(u: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (5.5): Ref.mark failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)            
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Ref.mark[x];                                                                           
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Ref.mark[x] := havocValue;                                                                         
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.mark failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)             
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : bool;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Ref.mark[x];                                                                           
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Ref.mark(u: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (5.5): Ref.mark failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)                 
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.mark failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, x: Ref)                  
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[x], u);                                                           
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Ref.mark[x];                                                                           
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Ref.mark[x] := havocValue;                                                                         
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,x: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (5.5): Ref.mark failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): AtomicMarkableReference.pair failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (10.5): AtomicMarkableReference.pair failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Ref;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReference.pair[x] := havocValue;                                                     
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (10.5): AtomicMarkableReference.pair failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Ref;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (10.5): AtomicMarkableReference.pair failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): AtomicMarkableReference.pair failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, x: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Ref;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReference.pair[x];                                                       
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReference.pair[x] := havocValue;                                                     
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,x: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (10.5): AtomicMarkableReference.pair failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)           
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (18.5): Node.item failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (18.5): Node.item failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)            
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.item[x] := havocValue;                                                                        
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (18.5): Node.item failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)             
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.item[x];                                                                          
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.item(u: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (18.5): Node.item failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                 
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (18.5): Node.item failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.item(t: Tid, u: Tid, v: int, w: int, x: Node)                  
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : int;                                                                              
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.item[x];                                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.item[x] := havocValue;                                                                        
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.item(u: Tid,x: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (18.5): Node.item failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, x: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): Node.next failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, x: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (19.5): Node.next failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, x: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : AtomicMarkableReference;                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 Node.next[x] := havocValue;                                                                        
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (19.5): Node.next failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, x: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : AtomicMarkableReference;                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == Node.next[x];                                                                          
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.Node.next(u: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (19.5): Node.next failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, x: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): Node.next failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, x: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[x], u);                                                          
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : AtomicMarkableReference;                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == Node.next[x];                                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 Node.next[x] := havocValue;                                                                        
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.Node.next(u: Tid,x: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (19.5): Node.next failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)         
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (35.5): List.head failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)          
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.List.head(u: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (35.5): List.head failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)          
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == List.head[x];                                                                          
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 List.head[x] := havocValue;                                                                        
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (35.5): List.head failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)           
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume w == List.head[x];                                                                          
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.List.head(u: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (35.5): List.head failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)               
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (35.5): List.head failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.List.head(t: Tid, u: Tid, v: Node, w: Node, x: List)                
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[x], u);                                                          
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Node;                                                                             
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
 assume w == List.head[x];                                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 List.head[x] := havocValue;                                                                        
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.List.head(u: Tid,x: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (35.5): List.head failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.reference;                                                                            
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.reference;                                                                            
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Node.item is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Node.next is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.reference.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.reference.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.reference.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.reference[x];                                                                          
 Ref.reference[x] := v;                                                                             
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.reference[x] := tmpV;                                                                          
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.reference.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.reference(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (4.5): Ref.reference is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.reference.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.reference;                                                                            
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.reference(t: Tid,x: Ref,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[x] := v;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Ref.reference (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Ref.reference (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (35.5): List.head is not Write-Read Stable with respect to Ref.reference (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.Ref.reference(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var v_mid: bool;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var v_mid: bool;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.Ref.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: Ref, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Ref.mark;                                                                                 
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.AtomicMarkableReference.pair(t: Tid, u: Tid, v: bool, w: Ref, w0: Ref, x: Ref, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Ref.mark;                                                                                 
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.Node.item(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.Node.item(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.Node.item(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.Node.item(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.Node.item(t: Tid, u: Tid, v: bool, w: int, w0: int, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Node.item is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.Node.next(t: Tid, u: Tid, v: bool, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.Node.next(t: Tid, u: Tid, v: bool, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.Node.next(t: Tid, u: Tid, v: bool, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.Node.next(t: Tid, u: Tid, v: bool, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.Node.next(t: Tid, u: Tid, v: bool, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Ref, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(Node._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Node.next is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Ref.mark.List.head(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Ref.mark.List.head(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Ref.mark.List.head(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var x_mid: Ref;                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var v_mid: bool;                                                                                   
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Ref.mark[x];                                                                               
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Ref.mark[x] := tmpV;                                                                               
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Ref.mark.List.head(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Ref.mark(t: Tid,x: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (5.5): Ref.mark is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Ref.mark.List.head(t: Tid, u: Tid, v: bool, w: Node, w0: Node, x: Ref, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Ref._state[x], t);                                                           
 requires isAccessible(List._state[y], u);                                                          
 modifies Ref.mark;                                                                                 
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
 var x_pre: Ref;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var x_post: Ref;                                                                                   
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: bool;                                                                                  
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Ref.mark(t: Tid,x: Ref,v: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[x] := v;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Ref.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Ref.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (35.5): List.head is not Write-Read Stable with respect to Ref.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Ref.reference(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Ref.mark(t: Tid, u: Tid, v: Ref, w: bool, w0: bool, x: AtomicMarkableReference, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Ref._state[y], u);                                                           
 modifies AtomicMarkableReference.pair;                                                             
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Ref, w: Ref, w0: Ref, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.pair;                                                             
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Node.item(t: Tid, u: Tid, v: Ref, w: int, w0: int, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Node.item(t: Tid, u: Tid, v: Ref, w: int, w0: int, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Node.item(t: Tid, u: Tid, v: Ref, w: int, w0: int, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Node.item(t: Tid, u: Tid, v: Ref, w: int, w0: int, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Node.item(t: Tid, u: Tid, v: Ref, w: int, w0: int, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Node.item is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.Node.next(t: Tid, u: Tid, v: Ref, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.Node.next(t: Tid, u: Tid, v: Ref, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.Node.next(t: Tid, u: Tid, v: Ref, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.Node.next(t: Tid, u: Tid, v: Ref, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.Node.next(t: Tid, u: Tid, v: Ref, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: AtomicMarkableReference, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(Node._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var x_post: AtomicMarkableReference;                                                               
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Node.next is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.pair.List.head(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(List._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.pair.List.head(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(List._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.pair.List.head(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(List._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Ref;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var v_mid: Ref;                                                                                    
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.pair[x];                                                           
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.pair[x] := tmpV;                                                           
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.pair.List.head(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(List._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.pair.List.head(t: Tid, u: Tid, v: Ref, w: Node, w0: Node, x: AtomicMarkableReference, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(List._state[y], u);                                                          
 modifies AtomicMarkableReference.pair;                                                             
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var v_pre: Ref;                                                                                    
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var x_pre: AtomicMarkableReference;                                                                
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: Ref;                                                                                   
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var x_post: AtomicMarkableReference;                                                               
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.pair(t: Tid,x: AtomicMarkableReference,v: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[x] := v;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (35.5): List.head is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Ref.reference(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Ref.reference(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Ref.reference(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Ref.reference(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Ref.reference (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Ref.reference(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Ref.reference is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Ref.mark(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Ref.mark(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Ref.mark(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Ref.mark(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Ref.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Ref.mark(t: Tid, u: Tid, v: int, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.item;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.mark is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.AtomicMarkableReference.pair(t: Tid, u: Tid, v: int, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.item;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.AtomicMarkableReference.pair(t: Tid, u: Tid, v: int, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.item;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.AtomicMarkableReference.pair(t: Tid, u: Tid, v: int, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.item;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.AtomicMarkableReference.pair(t: Tid, u: Tid, v: int, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.item;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.AtomicMarkableReference.pair(t: Tid, u: Tid, v: int, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.item;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.item(t: Tid, u: Tid, v: int, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.Node.next(t: Tid, u: Tid, v: int, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.Node.next(t: Tid, u: Tid, v: int, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.Node.next(t: Tid, u: Tid, v: int, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.Node.next(t: Tid, u: Tid, v: int, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.Node.next(t: Tid, u: Tid, v: int, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.item (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (35.5): List.head is not Write-Write Stable with respect to Node.item (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.item (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : int;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var v_mid: int;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.item[x];                                                                              
 Node.item[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.item[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.item(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (18.5): Node.item is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.item.List.head(t: Tid, u: Tid, v: int, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.item;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var v_pre: int;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var v_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.item(t: Tid,x: Node,v: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Node.item (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Node.item (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (35.5): List.head is not Write-Read Stable with respect to Node.item (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Ref.reference(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Ref.reference(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Ref.reference(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Ref.reference(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Ref.reference (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Ref.reference(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Ref.reference is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Ref.mark(t: Tid, u: Tid, v: AtomicMarkableReference, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Ref.mark(t: Tid, u: Tid, v: AtomicMarkableReference, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Ref.mark(t: Tid, u: Tid, v: AtomicMarkableReference, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Ref.mark(t: Tid, u: Tid, v: AtomicMarkableReference, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Ref.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Ref.mark(t: Tid, u: Tid, v: AtomicMarkableReference, w: bool, w0: bool, x: Node, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies Node.next;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.mark is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.AtomicMarkableReference.pair(t: Tid, u: Tid, v: AtomicMarkableReference, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.next;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.AtomicMarkableReference.pair(t: Tid, u: Tid, v: AtomicMarkableReference, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.next;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.AtomicMarkableReference.pair(t: Tid, u: Tid, v: AtomicMarkableReference, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.next;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.AtomicMarkableReference.pair(t: Tid, u: Tid, v: AtomicMarkableReference, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.next;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.AtomicMarkableReference.pair(t: Tid, u: Tid, v: AtomicMarkableReference, w: Ref, w0: Ref, x: Node, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies Node.next;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.item(t: Tid, u: Tid, v: AtomicMarkableReference, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.item(t: Tid, u: Tid, v: AtomicMarkableReference, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.item(t: Tid, u: Tid, v: AtomicMarkableReference, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.item(t: Tid, u: Tid, v: AtomicMarkableReference, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.item(t: Tid, u: Tid, v: AtomicMarkableReference, w: int, w0: int, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.Node.next(t: Tid, u: Tid, v: AtomicMarkableReference, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: Node, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.Node.next.List.head(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.next (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (35.5): List.head is not Write-Write Stable with respect to Node.next (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.next (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.Node.next.List.head(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.Node.next.List.head(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : AtomicMarkableReference;                                                                
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var v_mid: AtomicMarkableReference;                                                                
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var x_mid: Node;                                                                                   
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := Node.next[x];                                                                              
 Node.next[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 Node.next[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.Node.next.List.head(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.Node.next(t: Tid,x: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to List.head (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (19.5): Node.next is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.Node.next.List.head(t: Tid, u: Tid, v: AtomicMarkableReference, w: Node, w0: Node, x: Node, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(Node._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies Node.next;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var x_pre: Node;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: AtomicMarkableReference;                                                                
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var x_post: Node;                                                                                  
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Node;                                                                                 
 var v_post: AtomicMarkableReference;                                                               
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.Node.next(t: Tid,x: Node,v: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Node.next (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to Node.next (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (35.5): List.head is not Write-Read Stable with respect to Node.next (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Ref.reference[y] := w;                                                                             
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.reference(u: Tid,y: Ref,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.reference[y] := w;                                                                             
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Ref.reference (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Ref.reference (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Ref.reference (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Ref.reference(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.reference;                                                                            
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.reference(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (4.5): Ref.reference is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (4.5): Ref.reference is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var y_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: bool;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Ref.mark[y] := w;                                                                                  
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Ref.mark(u: Tid,y: Ref,w: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Ref.mark[y] := w;                                                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Ref.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Ref.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Ref.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Ref.mark(t: Tid, u: Tid, v: Node, w: bool, w0: bool, x: List, y: Ref)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Ref._state[y], u);                                                           
 modifies List.head;                                                                                
 modifies Ref.mark;                                                                                 
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var y_pre: Ref;                                                                                    
 var w_pre: bool;                                                                                   
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var w0_pre: bool;                                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var y_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Ref.mark(u: Tid,y: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (5.5): Ref.mark is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (5.5): Ref.mark is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: List, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies List.head;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: List, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies List.head;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: List, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies List.head;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: Ref;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Ref;                                                                                   
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 AtomicMarkableReference.pair[y] := w;                                                              
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: List, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies List.head;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,w: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.pair[y] := w;                                                              
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.AtomicMarkableReference.pair(t: Tid, u: Tid, v: Node, w: Ref, w0: Ref, x: List, y: AtomicMarkableReference)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies List.head;                                                                                
 modifies AtomicMarkableReference.pair;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var w_pre: Ref;                                                                                    
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Ref;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var w0_post: Ref;                                                                                  
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: Ref;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.pair(u: Tid,y: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (18.5): Node.item is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (18.5): Node.item is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.item (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var w_mid: int;                                                                                    
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var w0_mid: int;                                                                                   
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.item[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.item (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.item (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.item(u: Tid,y: Node,w: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.item[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Node.item (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Node.item (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Node.item (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.item(t: Tid, u: Tid, v: Node, w: int, w0: int, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.item;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var w0_pre: int;                                                                                   
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w_pre: int;                                                                                    
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var w0_post: int;                                                                                  
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: int;                                                                                   
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.item(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (18.5): Node.item is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (18.5): Node.item is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (19.5): Node.next is not Write-Write Stable with respect to List.head (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (19.5): Node.next is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.next (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var w0_mid: AtomicMarkableReference;                                                               
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w_mid: AtomicMarkableReference;                                                                
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var y_mid: Node;                                                                                   
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 Node.next[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.next (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to Node.next (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.Node.next(u: Tid,y: Node,w: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 Node.next[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Node.next (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Node.next (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to Node.next (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.Node.next(t: Tid, u: Tid, v: Node, w: AtomicMarkableReference, w0: AtomicMarkableReference, x: List, y: Node)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(Node._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies Node.next;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var w_pre: AtomicMarkableReference;                                                                
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var Node._state_pre: [Node]State;                                                                  
 var y_pre: Node;                                                                                   
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var w0_pre: AtomicMarkableReference;                                                               
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var y_post: Node;                                                                                  
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var List.head_post: [List]Node;                                                                    
 var w_post: AtomicMarkableReference;                                                               
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var w0_post: AtomicMarkableReference;                                                              
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.Node.next(u: Tid,y: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (19.5): Node.next is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (19.5): Node.next is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to List.head (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (35.5): List.head is not Write-Write Stable with respect to List.head (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to List.head (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
                                                                                                    
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 List.head[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to List.head (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var tmpV : Node;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Ref.reference_mid: [Ref]Node;                                                                  
 var Ref.mark_mid: [Ref]bool;                                                                       
 var t_mid: Tid;                                                                                    
 var x_mid: List;                                                                                   
 var u_mid: Tid;                                                                                    
 var w_mid: Node;                                                                                   
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var List._lock_mid: [List]Tid;                                                                     
 var Node.next_mid: [Node]AtomicMarkableReference;                                                  
 var v_mid: Node;                                                                                   
 var Ref._lock_mid: [Ref]Tid;                                                                       
 var Ref._state_mid: [Ref]State;                                                                    
 var w0_mid: Node;                                                                                  
 var List._state_mid: [List]State;                                                                  
 var AtomicMarkableReference.pair_mid: [AtomicMarkableReference]Ref;                                
 var y_mid: List;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Node._lock_mid: [Node]Tid;                                                                     
 var Node._state_mid: [Node]State;                                                                  
 var $pc_mid: Phase;                                                                                
 var Node.item_mid: [Node]int;                                                                      
 var List.head_mid: [List]Node;                                                                     
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := List.head[x];                                                                              
 List.head[x] := v;                                                                                 
 assume Ref._state_mid == Ref._state && Ref.reference_mid == Ref.reference && Ref.mark_mid == Ref.mark && Ref._lock_mid == Ref._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.pair_mid == AtomicMarkableReference.pair && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Node._state_mid == Node._state && Node.item_mid == Node.item && Node.next_mid == Node.next && Node._lock_mid == Node._lock && List._state_mid == List._state && List.head_mid == List.head && List._lock_mid == List._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 List.head[x] := tmpV;                                                                              
 List.head[y] := w;                                                                                 
 _writeByTPost := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to List.head (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (35.5): List.head is not Write-Write Stable with respect to List.head (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByT := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.List.head(u: Tid,y: List,w: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[y] := w;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.List.head(t: Tid,x: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to List.head (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to List.head (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (35.5): List.head is not Read-Write Stable with respect to List.head (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.List.head.List.head(t: Tid, u: Tid, v: Node, w: Node, w0: Node, x: List, y: List)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(List._state[x], t);                                                          
 requires isAccessible(List._state[y], u);                                                          
 modifies List.head;                                                                                
 modifies List.head;                                                                                
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var Node._lock_pre: [Node]Tid;                                                                     
 var Ref._state_pre: [Ref]State;                                                                    
 var Ref.reference_pre: [Ref]Node;                                                                  
 var Ref.mark_pre: [Ref]bool;                                                                       
 var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var List.head_pre: [List]Node;                                                                     
 var y_pre: List;                                                                                   
 var Node._state_pre: [Node]State;                                                                  
 var Node.next_pre: [Node]AtomicMarkableReference;                                                  
 var v_pre: Node;                                                                                   
 var List._state_pre: [List]State;                                                                  
 var Ref._lock_pre: [Ref]Tid;                                                                       
 var $pc_pre: Phase;                                                                                
 var w0_pre: Node;                                                                                  
 var w_pre: Node;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var x_pre: List;                                                                                   
 var Node.item_pre: [Node]int;                                                                      
 var List._lock_pre: [List]Tid;                                                                     
 var t_pre: Tid;                                                                                    
                                                                                                    
 var Node.next_post: [Node]AtomicMarkableReference;                                                 
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                               
 var Node.item_post: [Node]int;                                                                     
 var List._lock_post: [List]Tid;                                                                    
 var t_post: Tid;                                                                                   
 var Ref.mark_post: [Ref]bool;                                                                      
 var $pc_post: Phase;                                                                               
 var Node._lock_post: [Node]Tid;                                                                    
 var x_post: List;                                                                                  
 var w0_post: Node;                                                                                 
 var List.head_post: [List]Node;                                                                    
 var Ref._state_post: [Ref]State;                                                                   
 var Node._state_post: [Node]State;                                                                 
 var y_post: List;                                                                                  
 var List._state_post: [List]State;                                                                 
 var Ref._lock_post: [Ref]Tid;                                                                      
 var Ref.reference_post: [Ref]Node;                                                                 
 var v_post: Node;                                                                                  
 var u_post: Tid;                                                                                   
 var w_post: Node;                                                                                  
                                                                                                    
                                                                                                    
 _readByU := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.List.head(t: Tid,x: List,v: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 List.head[x] := v;                                                                                 
 assume Ref._state_post == Ref._state && Ref.reference_post == Ref.reference && Ref.mark_post == Ref.mark && Ref._lock_post == Ref._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Node._state_post == Node._state && Node.item_post == Node.item && Node.next_post == Node.next && Node._lock_post == Node._lock && List._state_post == List._state && List.head_post == List.head && List._lock_post == List._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.List.head(u: Tid,y: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to List.head (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (35.5): List.head is not Write-Read Stable with respect to List.head (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (35.5): List.head is not Write-Read Stable with respect to List.head (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
requires ValidTid(tid);                                                                             
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
modifies Ref._state;                                                                                
modifies Ref.reference;                                                                             
modifies Ref.mark;                                                                                  
modifies Ref._lock;                                                                                 
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.pair;                                                              
modifies AtomicMarkableReference._lock;                                                             
modifies Node._state;                                                                               
modifies Node.item;                                                                                 
modifies Node.next;                                                                                 
modifies Node._lock;                                                                                
modifies List._state;                                                                               
modifies List.head;                                                                                 
modifies List._lock;                                                                                
ensures StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
ensures Y(tid , old(Ref._state), old(Ref.reference), old(Ref.mark), old(Ref._lock), old(AtomicMarkableReference._state), old(AtomicMarkableReference.pair), old(AtomicMarkableReference._lock), old(Node._state), old(Node.item), old(Node.next), old(Node._lock), old(List._state), old(List.head), old(List._lock) , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
ensures  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
ensures  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (<undefined position>): Object invariant may not hold.
                                                                                                    
// Ref.reference:                                                                                   
                                                                                                    
function {:inline} Y_Ref.reference(tid : Tid, this: Ref, newValue: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Ref._state[this], tid) && leq(m#moverPath(ReadEval.Ref.reference(tid: Tid,this: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Ref.reference[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Ref.reference(tid : Tid, this: Ref, newValue: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Ref.reference.Subsumes.W(tid : Tid, u : Tid, this: Ref, newValue: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume isAccessible(Ref._state[this], u);                                                          
 assume !isError(m#moverPath(WriteEval.Ref.reference(u: Tid,this: Ref,newValue: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.reference(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Ref.reference.Reflexive(tid : Tid, this: Ref , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.reference(tid, this, Ref.reference[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Ref.reference.Transitive(tid : Tid, this: Ref, newValue : Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (4.32): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (4.32): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (4.32): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (4.32): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (4.32): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (4.32): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (4.32): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var this_pre: Ref;                                                                                  
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var this_post: Ref;                                                                                 
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Ref.reference(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Ref.reference(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Ref.mark:                                                                                        
                                                                                                    
function {:inline} Y_Ref.mark(tid : Tid, this: Ref, newValue: bool , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Ref._state[this], tid) && leq(m#moverPath(ReadEval.Ref.mark(tid: Tid,this: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Ref.mark[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Ref.mark(tid : Tid, this: Ref, newValue: bool , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Ref.mark.Subsumes.W(tid : Tid, u : Tid, this: Ref, newValue: bool , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var newValue_yield: bool;                                                                           
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume isAccessible(Ref._state[this], u);                                                          
 assume !isError(m#moverPath(WriteEval.Ref.mark(u: Tid,this: Ref,newValue: bool,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.mark(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Ref.mark.Reflexive(tid : Tid, this: Ref , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref.mark(tid, this, Ref.mark[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Ref.mark.Transitive(tid : Tid, this: Ref, newValue : bool , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (5.35): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (5.35): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (5.35): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (5.35): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (5.35): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (5.35): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (5.35): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var newValue_pre: bool;                                                                             
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var this_pre: Ref;                                                                                  
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var this_post: Ref;                                                                                 
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var newValue_post: bool;                                                                            
var List._state_post: [List]State;                                                                  
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Ref.mark(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Ref.mark(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Ref._lock:                                                                                       
                                                                                                    
function {:inline} Y_Ref._lock(tid : Tid, this: Ref, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Ref._state[this], tid) && leq(m#moverPath(ReadEval.Ref._lock(tid: Tid,this: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Ref._lock[this] == newValue))
 &&(((Ref._lock[this]==tid)==(newValue==tid)))                                                      
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Ref._lock(tid : Tid, this: Ref, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Ref._lock.Subsumes.W(tid : Tid, u : Tid, this: Ref, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume isAccessible(Ref._state[this], u);                                                          
 assume !isError(m#moverPath(WriteEval.Ref._lock(u: Tid,this: Ref,newValue: Tid,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
 assume leq(m#moverPath(ReadEval.Ref._lock(tid: Tid,this: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _N);
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Ref._lock.Reflexive(tid : Tid, this: Ref , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var this_yield: Ref;                                                                                
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Ref._lock(tid, this, Ref._lock[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Ref._lock.Transitive(tid : Tid, this: Ref, newValue : Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (3.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (3.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (3.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (3.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (3.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (3.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (3.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var this_pre: Ref;                                                                                  
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var this_post: Ref;                                                                                 
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var newValue_post: Tid;                                                                             
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Ref._state[this], tid);                                                        
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Ref._lock(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Ref._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// AtomicMarkableReference.pair:                                                                    
                                                                                                    
function {:inline} Y_AtomicMarkableReference.pair(tid : Tid, this: AtomicMarkableReference, newValue: Ref , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.pair(tid: Tid,this: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (AtomicMarkableReference.pair[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.pair(tid : Tid, this: AtomicMarkableReference, newValue: Ref , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Ref , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Ref;                                                                            
var this_yield: AtomicMarkableReference;                                                            
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference.pair(u: Tid,this: AtomicMarkableReference,newValue: Ref,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.pair(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Reflexive(tid : Tid, this: AtomicMarkableReference , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var this_yield: AtomicMarkableReference;                                                            
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.pair(tid, this, AtomicMarkableReference.pair[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.pair.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Ref , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (10.33): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (10.33): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (10.33): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (10.33): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (10.33): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (10.33): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (10.33): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var this_pre: AtomicMarkableReference;                                                              
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var newValue_pre: Ref;                                                                              
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var newValue_post: Ref;                                                                             
var this_post: AtomicMarkableReference;                                                             
var List.head_post: [List]Node;                                                                     
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_AtomicMarkableReference.pair(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference.pair(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// AtomicMarkableReference._lock:                                                                   
                                                                                                    
function {:inline} Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (AtomicMarkableReference._lock[this] == newValue))
 &&(((AtomicMarkableReference._lock[this]==tid)==(newValue==tid)))                                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var this_yield: AtomicMarkableReference;                                                            
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference._lock(u: Tid,this: AtomicMarkableReference,newValue: Tid,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
 assume leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _N);
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Reflexive(tid : Tid, this: AtomicMarkableReference , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var this_yield: AtomicMarkableReference;                                                            
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, AtomicMarkableReference._lock[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (8.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (8.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (8.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (8.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (8.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (8.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (8.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var this_pre: AtomicMarkableReference;                                                              
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var this_post: AtomicMarkableReference;                                                             
var List.head_post: [List]Node;                                                                     
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var newValue_post: Tid;                                                                             
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_AtomicMarkableReference._lock(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Node.item:                                                                                       
                                                                                                    
function {:inline} Y_Node.item(tid : Tid, this: Node, newValue: int , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.item(tid: Tid,this: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Node.item[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.item(tid : Tid, this: Node, newValue: int , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: int , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var newValue_yield: int;                                                                            
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.item(u: Tid,this: Node,newValue: int,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Reflexive(tid : Tid, this: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.item(tid, this, Node.item[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.item.Transitive(tid : Tid, this: Node, newValue : int , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (18.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (18.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (18.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (18.23): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (18.23): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (18.23): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (18.23): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var newValue_pre: int;                                                                              
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var newValue_post: int;                                                                             
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Node.item(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.item(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Node.next:                                                                                       
                                                                                                    
function {:inline} Y_Node.next(tid : Tid, this: Node, newValue: AtomicMarkableReference , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node.next(tid: Tid,this: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Node.next[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node.next(tid : Tid, this: Node, newValue: AtomicMarkableReference , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: AtomicMarkableReference , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: AtomicMarkableReference;                                                        
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node.next(u: Tid,this: Node,newValue: AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Reflexive(tid : Tid, this: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node.next(tid, this, Node.next[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node.next.Transitive(tid : Tid, this: Node, newValue : AtomicMarkableReference , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (19.43): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (19.43): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (19.43): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (19.43): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (19.43): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (19.43): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (19.43): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var newValue_pre: AtomicMarkableReference;                                                          
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
var newValue_post: AtomicMarkableReference;                                                         
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Node.next(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node.next(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// Node._lock:                                                                                      
                                                                                                    
function {:inline} Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(Node._state[this], tid) && leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (Node._lock[this] == newValue))
 &&(((Node._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Node._lock(tid : Tid, this: Node, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Subsumes.W(tid : Tid, u : Tid, this: Node, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume isAccessible(Node._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Node._lock(u: Tid,this: Node,newValue: Tid,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
 assume leq(m#moverPath(ReadEval.Node._lock(tid: Tid,this: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _N);
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Reflexive(tid : Tid, this: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var this_yield: Node;                                                                               
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
                                                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Node._lock(tid, this, Node._lock[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_Node._lock.Transitive(tid : Tid, this: Node, newValue : Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (17.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (17.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (17.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (17.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (17.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (17.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (17.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var this_pre: Node;                                                                                 
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var this_post: Node;                                                                                
var newValue_post: Tid;                                                                             
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Node._state[this], tid);                                                       
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_Node._lock(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Node._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// List.head:                                                                                       
                                                                                                    
function {:inline} Y_List.head(tid : Tid, this: List, newValue: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(List._state[this], tid) && leq(m#moverPath(ReadEval.List.head(tid: Tid,this: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (List.head[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_List.head(tid : Tid, this: List, newValue: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_List.head.Subsumes.W(tid : Tid, u : Tid, this: List, newValue: Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var newValue_yield: Node;                                                                           
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume isAccessible(List._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.List.head(u: Tid,this: List,newValue: Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
                                                                                                    
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List.head(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List.head.Reflexive(tid : Tid, this: List , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List.head(tid, this, List.head[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List.head.Transitive(tid : Tid, this: List, newValue : Node , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (35.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (35.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (35.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (35.24): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (35.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (35.24): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (35.24): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var newValue_pre: Node;                                                                             
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
var this_pre: List;                                                                                 
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var newValue_post: Node;                                                                            
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var this_post: List;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_List.head(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_List.head(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
// List._lock:                                                                                      
                                                                                                    
function {:inline} Y_List._lock(tid : Tid, this: List, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 ((isAccessible(List._state[this], tid) && leq(m#moverPath(ReadEval.List._lock(tid: Tid,this: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _R)) ==> (List._lock[this] == newValue))
 &&(((List._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_List._lock(tid : Tid, this: List, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Subsumes.W(tid : Tid, u : Tid, this: List, newValue: Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var newValue_yield: Tid;                                                                            
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume isAccessible(List._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.List._lock(u: Tid,this: List,newValue: Tid,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)));
 assume leq(m#moverPath(ReadEval.List._lock(tid: Tid,this: List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock)), _N);
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Reflexive(tid : Tid, this: List , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var Ref._lock_yield: [Ref]Tid;                                                                      
var Node.item_yield: [Node]int;                                                                     
var AtomicMarkableReference.pair_yield: [AtomicMarkableReference]Ref;                               
var Ref.mark_yield: [Ref]bool;                                                                      
var Node._state_yield: [Node]State;                                                                 
var tid_yield: Tid;                                                                                 
var Ref._state_yield: [Ref]State;                                                                   
var $pc_yield: Phase;                                                                               
var Ref.reference_yield: [Ref]Node;                                                                 
var Node.next_yield: [Node]AtomicMarkableReference;                                                 
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var Node._lock_yield: [Node]Tid;                                                                    
var List.head_yield: [List]Node;                                                                    
var List._lock_yield: [List]Tid;                                                                    
var List._state_yield: [List]State;                                                                 
var $recorded.state_yield: int;                                                                     
var this_yield: List;                                                                               
                                                                                                    
 assume isAccessible(List._state[this], tid);                                                       
assume Ref._state_yield == Ref._state && Ref.reference_yield == Ref.reference && Ref.mark_yield == Ref.mark && Ref._lock_yield == Ref._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.pair_yield == AtomicMarkableReference.pair && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Node._state_yield == Node._state && Node.item_yield == Node.item && Node.next_yield == Node.next && Node._lock_yield == Node._lock && List._state_yield == List._state && List.head_yield == List.head && List._lock_yield == List._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_List._lock(tid, this, List._lock[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
procedure Y_List._lock.Transitive(tid : Tid, this: List, newValue : Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid)
 requires StateInvariant(Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
 requires StateInvariant(Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 requires ValidTid(tid);                                                                            
requires  (forall _this : AtomicMarkableReference ::  { AtomicMarkableReference._state[_this] } isAccessible(AtomicMarkableReference._state[_this], tid) && true ==> Invariant.AtomicMarkableReference.2454159(tid: Tid,_this : AtomicMarkableReference,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (33.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454323(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (33.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454331(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (33.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454346(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (33.1): Object invariant may not hold.
requires  (forall _this : Node ::  { Node._state[_this] } isAccessible(Node._state[_this], tid) && true ==> Invariant.Node.2454367(tid: Tid,_this : Node,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (33.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454554(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (33.1): Object invariant may not hold.
requires  (forall _this : List ::  { List._state[_this] } isAccessible(List._state[_this], tid) && true ==> Invariant.List.2454565(tid: Tid,_this : List,Ref._state,Ref.reference,Ref.mark,Ref._lock,AtomicMarkableReference._state,AtomicMarkableReference.pair,AtomicMarkableReference._lock,Node._state,Node.item,Node.next,Node._lock,List._state,List.head,List._lock));       // (33.1): Object invariant may not hold.
                                                                                                    
{                                                                                                   
var Node._lock_pre: [Node]Tid;                                                                      
var Ref._state_pre: [Ref]State;                                                                     
var Ref.reference_pre: [Ref]Node;                                                                   
var Ref.mark_pre: [Ref]bool;                                                                        
var AtomicMarkableReference.pair_pre: [AtomicMarkableReference]Ref;                                 
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var List.head_pre: [List]Node;                                                                      
var Node._state_pre: [Node]State;                                                                   
var Node.next_pre: [Node]AtomicMarkableReference;                                                   
var tid_pre: Tid;                                                                                   
var List._state_pre: [List]State;                                                                   
var Ref._lock_pre: [Ref]Tid;                                                                        
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var Node.item_pre: [Node]int;                                                                       
var List._lock_pre: [List]Tid;                                                                      
var this_pre: List;                                                                                 
                                                                                                    
var Node.next_post: [Node]AtomicMarkableReference;                                                  
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var AtomicMarkableReference.pair_post: [AtomicMarkableReference]Ref;                                
var Node.item_post: [Node]int;                                                                      
var List._lock_post: [List]Tid;                                                                     
var Ref.mark_post: [Ref]bool;                                                                       
var $pc_post: Phase;                                                                                
var this_post: List;                                                                                
var Node._lock_post: [Node]Tid;                                                                     
var tid_post: Tid;                                                                                  
var List.head_post: [List]Node;                                                                     
var Ref._state_post: [Ref]State;                                                                    
var Node._state_post: [Node]State;                                                                  
var List._state_post: [List]State;                                                                  
var newValue_post: Tid;                                                                             
var Ref._lock_post: [Ref]Tid;                                                                       
var Ref.reference_post: [Ref]Node;                                                                  
                                                                                                    
assume Ref._state_pre == Ref._state && Ref.reference_pre == Ref.reference && Ref.mark_pre == Ref.mark && Ref._lock_pre == Ref._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.pair_pre == AtomicMarkableReference.pair && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Node._state_pre == Node._state && Node.item_pre == Node.item && Node.next_pre == Node.next && Node._lock_pre == Node._lock && List._state_pre == List._state && List.head_pre == List.head && List._lock_pre == List._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(List._state[this], tid);                                                       
 assume Y(tid , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
 assume Y_List._lock(tid, this, newValue , Ref._state_p, Ref.reference_p, Ref.mark_p, Ref._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.pair_p, AtomicMarkableReference._lock_p, Node._state_p, Node.item_p, Node.next_p, Node._lock_p, List._state_p, List.head_p, List._lock_p);
assume Ref._state_post == Ref._state_p && Ref.reference_post == Ref.reference_p && Ref.mark_post == Ref.mark_p && Ref._lock_post == Ref._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.pair_post == AtomicMarkableReference.pair_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Node._state_post == Node._state_p && Node.item_post == Node.item_p && Node.next_post == Node.next_p && Node._lock_post == Node._lock_p && List._state_post == List._state_p && List.head_post == List.head_p && List._lock_post == List._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_List._lock(tid, this, newValue , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Ref._state: [Ref]State, Ref.reference: [Ref]Node, Ref.mark: [Ref]bool, Ref._lock: [Ref]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.pair: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Node._state: [Node]State, Node.item: [Node]int, Node.next: [Node]AtomicMarkableReference, Node._lock: [Node]Tid, List._state: [List]State, List.head: [List]Node, List._lock: [List]Tid , Ref._state_p: [Ref]State, Ref.reference_p: [Ref]Node, Ref.mark_p: [Ref]bool, Ref._lock_p: [Ref]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.pair_p: [AtomicMarkableReference]Ref, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Node._state_p: [Node]State, Node.item_p: [Node]int, Node.next_p: [Node]AtomicMarkableReference, Node._lock_p: [Node]Tid, List._state_p: [List]State, List.head_p: [List]Node, List._lock_p: [List]Tid): bool
{                                                                                                   
 (forall this: Ref :: Y_Ref.reference(tid : Tid, this, Ref.reference_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: Ref :: Y_Ref.mark(tid : Tid, this, Ref.mark_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: Ref :: Y_Ref._lock(tid : Tid, this, Ref._lock_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.pair(tid : Tid, this, AtomicMarkableReference.pair_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference._lock(tid : Tid, this, AtomicMarkableReference._lock_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: Node :: Y_Node.item(tid : Tid, this, Node.item_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: Node :: Y_Node.next(tid : Tid, this, Node.next_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: Node :: Y_Node._lock(tid : Tid, this, Node._lock_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: List :: Y_List.head(tid : Tid, this, List.head_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall this: List :: Y_List._lock(tid : Tid, this, List._lock_p[this] , Ref._state, Ref.reference, Ref.mark, Ref._lock, AtomicMarkableReference._state, AtomicMarkableReference.pair, AtomicMarkableReference._lock, Node._state, Node.item, Node.next, Node._lock, List._state, List.head, List._lock))
 && (forall _i : Ref :: isShared(Ref._state[_i]) ==> isShared(Ref._state_p[_i]))                    
 && (forall _i : Ref :: isLocal(Ref._state[_i], tid) <==> isLocal(Ref._state_p[_i], tid))           
 && (forall _i : AtomicMarkableReference :: isShared(AtomicMarkableReference._state[_i]) ==> isShared(AtomicMarkableReference._state_p[_i]))
 && (forall _i : AtomicMarkableReference :: isLocal(AtomicMarkableReference._state[_i], tid) <==> isLocal(AtomicMarkableReference._state_p[_i], tid))
 && (forall _i : Node :: isShared(Node._state[_i]) ==> isShared(Node._state_p[_i]))                 
 && (forall _i : Node :: isLocal(Node._state[_i], tid) <==> isLocal(Node._state_p[_i], tid))        
 && (forall _i : List :: isShared(List._state[_i]) ==> isShared(List._state_p[_i]))                 
 && (forall _i : List :: isLocal(List._state[_i], tid) <==> isLocal(List._state_p[_i], tid))        
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 1301.1-1498.2: (Method:43.5)
// 1320.1-1320.24: (43.5): Bad tid
// 1321.1-1321.38: (43.5): this is not global
// 1326.1-1326.461: (43.5): Object invariant may not hold.
// 1327.1-1327.366: (43.5): Object invariant may not hold.
// 1328.1-1328.366: (43.5): Object invariant may not hold.
// 1329.1-1329.366: (43.5): Object invariant may not hold.
// 1330.1-1330.366: (43.5): Object invariant may not hold.
// 1331.1-1331.366: (43.5): Object invariant may not hold.
// 1332.1-1332.366: (43.5): Object invariant may not hold.
// 1335.1-1335.460: (43.5): Object invariant may not hold.
// 1336.1-1336.365: (43.5): Object invariant may not hold.
// 1337.1-1337.365: (43.5): Object invariant may not hold.
// 1338.1-1338.365: (43.5): Object invariant may not hold.
// 1339.1-1339.365: (43.5): Object invariant may not hold.
// 1340.1-1340.365: (43.5): Object invariant may not hold.
// 1341.1-1341.365: (43.5): Object invariant may not hold.
// 1430.1-1430.14: (43.29): Can only have right-mover memory accesses in requires clause
// 1434.2-1438.14: (class anchor.sink.While:45.7)
// 1440.1-1440.27: (43.5): Bad tid
// 1441.1-1441.41: (43.5): this is not global
// 1444.1-1444.464: (45.7): Object invariant may not hold.
// 1445.1-1445.369: (45.7): Object invariant may not hold.
// 1446.1-1446.369: (45.7): Object invariant may not hold.
// 1447.1-1447.369: (45.7): Object invariant may not hold.
// 1448.1-1448.369: (45.7): Object invariant may not hold.
// 1449.1-1449.369: (45.7): Object invariant may not hold.
// 1450.1-1450.369: (45.7): Object invariant may not hold.
// 1451.1-1451.412: (45.7): Loop does not preserve yields_as annotation for field reference
// 1452.1-1452.402: (45.7): Loop does not preserve yields_as annotation for field mark
// 1453.1-1453.462: (45.7): Loop does not preserve yields_as annotation for field pair
// 1454.1-1454.405: (45.7): Loop does not preserve yields_as annotation for field item
// 1455.1-1455.405: (45.7): Loop does not preserve yields_as annotation for field next
// 1456.1-1456.405: (45.7): Loop does not preserve yields_as annotation for field head
// 1457.1-1457.33: (45.7): Phase must be invariant at loop head
// 1458.1-1458.30: (45.7): Potentially infinite loop cannot be in post-commit phase.
// 1460.3-1462.3: (class anchor.sink.VarDeclStmt:45.14)
// 1463.3-1466.16: (class anchor.sink.Assign:45.14)
// 1468.4-1471.10: (class anchor.sink.Break:45.7)
// 1474.3-1479.36: (class anchor.sink.Assert:47.9)
// 1479.1-1479.36: (47.9): This assertion may not hold.
// 1482.1-1482.30: (45.7): Phase must be invariant at loop head
// 1484.2-1497.9: (class anchor.sink.Return:44.34)
// 1490.1-1490.460: (44.34): Object invariant may not hold.
// 1491.1-1491.365: (44.34): Object invariant may not hold.
// 1492.1-1492.365: (44.34): Object invariant may not hold.
// 1493.1-1493.365: (44.34): Object invariant may not hold.
// 1494.1-1494.365: (44.34): Object invariant may not hold.
// 1495.1-1495.365: (44.34): Object invariant may not hold.
// 1496.1-1496.365: (44.34): Object invariant may not hold.
// 1605.1-1605.34: (4.5): Ref.reference failed Write-Write Right-Mover Check
// 1684.1-1684.30: (4.5): Ref.reference failed Write-Read Right-Mover Check
// 1767.1-1767.34: (4.5): Ref.reference failed Write-Write Left-Mover Check
// 1847.1-1847.30: (4.5): Ref.reference failed Write-Read Left-Mover Check
// 1924.1-1924.34: (4.5): Ref.reference failed Read-Write Right-Mover Check
// 2004.1-2004.34: (4.5): Ref.reference failed Read-Write Left-Mover Check
// 2083.1-2083.34: (5.5): Ref.mark failed Write-Write Right-Mover Check
// 2162.1-2162.30: (5.5): Ref.mark failed Write-Read Right-Mover Check
// 2245.1-2245.34: (5.5): Ref.mark failed Write-Write Left-Mover Check
// 2325.1-2325.30: (5.5): Ref.mark failed Write-Read Left-Mover Check
// 2402.1-2402.34: (5.5): Ref.mark failed Read-Write Right-Mover Check
// 2482.1-2482.34: (5.5): Ref.mark failed Read-Write Left-Mover Check
// 2561.1-2561.34: (10.5): AtomicMarkableReference.pair failed Write-Write Right-Mover Check
// 2640.1-2640.30: (10.5): AtomicMarkableReference.pair failed Write-Read Right-Mover Check
// 2723.1-2723.34: (10.5): AtomicMarkableReference.pair failed Write-Write Left-Mover Check
// 2803.1-2803.30: (10.5): AtomicMarkableReference.pair failed Write-Read Left-Mover Check
// 2880.1-2880.34: (10.5): AtomicMarkableReference.pair failed Read-Write Right-Mover Check
// 2960.1-2960.34: (10.5): AtomicMarkableReference.pair failed Read-Write Left-Mover Check
// 3039.1-3039.34: (18.5): Node.item failed Write-Write Right-Mover Check
// 3118.1-3118.30: (18.5): Node.item failed Write-Read Right-Mover Check
// 3201.1-3201.34: (18.5): Node.item failed Write-Write Left-Mover Check
// 3281.1-3281.30: (18.5): Node.item failed Write-Read Left-Mover Check
// 3358.1-3358.34: (18.5): Node.item failed Read-Write Right-Mover Check
// 3438.1-3438.34: (18.5): Node.item failed Read-Write Left-Mover Check
// 3517.1-3517.34: (19.5): Node.next failed Write-Write Right-Mover Check
// 3596.1-3596.30: (19.5): Node.next failed Write-Read Right-Mover Check
// 3679.1-3679.34: (19.5): Node.next failed Write-Write Left-Mover Check
// 3759.1-3759.30: (19.5): Node.next failed Write-Read Left-Mover Check
// 3836.1-3836.34: (19.5): Node.next failed Read-Write Right-Mover Check
// 3916.1-3916.34: (19.5): Node.next failed Read-Write Left-Mover Check
// 3995.1-3995.34: (35.5): List.head failed Write-Write Right-Mover Check
// 4074.1-4074.30: (35.5): List.head failed Write-Read Right-Mover Check
// 4157.1-4157.34: (35.5): List.head failed Write-Write Left-Mover Check
// 4237.1-4237.30: (35.5): List.head failed Write-Read Left-Mover Check
// 4314.1-4314.34: (35.5): List.head failed Read-Write Right-Mover Check
// 4394.1-4394.34: (35.5): List.head failed Read-Write Left-Mover Check
// 4485.1-4485.140: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.1)
// 4486.1-4486.101: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.2)
// 4487.1-4487.158: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case A.3)
// 4613.1-4613.140: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case C)
// 4744.1-4744.144: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case D)
// 4745.1-4745.144: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.reference (case R)
// 4836.1-4836.136: (4.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case F)
// 4837.1-4837.136: (4.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case H)
// 4838.1-4838.146: (4.5): Ref.reference is not Read-Write Stable with respect to Ref.reference (case I)
// 4928.1-4928.136: (4.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case J)
// 4929.1-4929.136: (4.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case K)
// 4930.1-4930.99: (4.5): Ref.reference is not Write-Read Stable with respect to Ref.reference (case L)
// 5022.1-5022.140: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.1)
// 5023.1-5023.101: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.2)
// 5024.1-5024.158: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case A.3)
// 5150.1-5150.140: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case C)
// 5281.1-5281.144: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case D)
// 5282.1-5282.144: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case R)
// 5373.1-5373.136: (4.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case F)
// 5374.1-5374.136: (4.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case H)
// 5375.1-5375.146: (4.5): Ref.reference is not Read-Write Stable with respect to Ref.mark (case I)
// 5465.1-5465.136: (5.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case J)
// 5466.1-5466.136: (5.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case K)
// 5467.1-5467.99: (5.5): Ref.mark is not Write-Read Stable with respect to Ref.reference (case L)
// 5559.1-5559.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.1)
// 5560.1-5560.101: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.2)
// 5561.1-5561.156: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case A.3)
// 5687.1-5687.140: (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 5818.1-5818.144: (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 5819.1-5819.144: (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 5910.1-5910.136: (4.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 5911.1-5911.136: (4.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 5912.1-5912.144: (4.5): Ref.reference is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 6002.1-6002.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case J)
// 6003.1-6003.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case K)
// 6004.1-6004.99: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.reference (case L)
// 6096.1-6096.140: (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case A.1)
// 6097.1-6097.101: (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case A.2)
// 6098.1-6098.156: (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case A.3)
// 6224.1-6224.140: (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case C)
// 6355.1-6355.144: (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case D)
// 6356.1-6356.144: (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case R)
// 6447.1-6447.136: (4.5): Ref.reference is not Read-Write Stable with respect to Node.item (case F)
// 6448.1-6448.136: (4.5): Ref.reference is not Read-Write Stable with respect to Node.item (case H)
// 6449.1-6449.144: (4.5): Ref.reference is not Read-Write Stable with respect to Node.item (case I)
// 6539.1-6539.136: (18.5): Node.item is not Write-Read Stable with respect to Ref.reference (case J)
// 6540.1-6540.136: (18.5): Node.item is not Write-Read Stable with respect to Ref.reference (case K)
// 6541.1-6541.99: (18.5): Node.item is not Write-Read Stable with respect to Ref.reference (case L)
// 6633.1-6633.140: (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case A.1)
// 6634.1-6634.101: (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case A.2)
// 6635.1-6635.156: (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case A.3)
// 6761.1-6761.140: (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case C)
// 6892.1-6892.144: (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case D)
// 6893.1-6893.144: (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case R)
// 6984.1-6984.136: (4.5): Ref.reference is not Read-Write Stable with respect to Node.next (case F)
// 6985.1-6985.136: (4.5): Ref.reference is not Read-Write Stable with respect to Node.next (case H)
// 6986.1-6986.144: (4.5): Ref.reference is not Read-Write Stable with respect to Node.next (case I)
// 7076.1-7076.136: (19.5): Node.next is not Write-Read Stable with respect to Ref.reference (case J)
// 7077.1-7077.136: (19.5): Node.next is not Write-Read Stable with respect to Ref.reference (case K)
// 7078.1-7078.99: (19.5): Node.next is not Write-Read Stable with respect to Ref.reference (case L)
// 7170.1-7170.140: (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case A.1)
// 7171.1-7171.101: (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case A.2)
// 7172.1-7172.156: (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case A.3)
// 7298.1-7298.140: (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case C)
// 7429.1-7429.144: (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case D)
// 7430.1-7430.144: (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case R)
// 7521.1-7521.136: (4.5): Ref.reference is not Read-Write Stable with respect to List.head (case F)
// 7522.1-7522.136: (4.5): Ref.reference is not Read-Write Stable with respect to List.head (case H)
// 7523.1-7523.144: (4.5): Ref.reference is not Read-Write Stable with respect to List.head (case I)
// 7613.1-7613.136: (35.5): List.head is not Write-Read Stable with respect to Ref.reference (case J)
// 7614.1-7614.136: (35.5): List.head is not Write-Read Stable with respect to Ref.reference (case K)
// 7615.1-7615.99: (35.5): List.head is not Write-Read Stable with respect to Ref.reference (case L)
// 7707.1-7707.140: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.1)
// 7708.1-7708.101: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.2)
// 7709.1-7709.158: (4.5): Ref.reference is not Write-Write Stable with respect to Ref.mark (case A.3)
// 7835.1-7835.140: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case C)
// 7966.1-7966.144: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case D)
// 7967.1-7967.144: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.reference (case R)
// 8058.1-8058.136: (5.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case F)
// 8059.1-8059.136: (5.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case H)
// 8060.1-8060.146: (5.5): Ref.mark is not Read-Write Stable with respect to Ref.reference (case I)
// 8150.1-8150.136: (4.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case J)
// 8151.1-8151.136: (4.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case K)
// 8152.1-8152.99: (4.5): Ref.reference is not Write-Read Stable with respect to Ref.mark (case L)
// 8244.1-8244.140: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.1)
// 8245.1-8245.101: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.2)
// 8246.1-8246.158: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case A.3)
// 8372.1-8372.140: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case C)
// 8503.1-8503.144: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case D)
// 8504.1-8504.144: (5.5): Ref.mark is not Write-Write Stable with respect to Ref.mark (case R)
// 8595.1-8595.136: (5.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case F)
// 8596.1-8596.136: (5.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case H)
// 8597.1-8597.146: (5.5): Ref.mark is not Read-Write Stable with respect to Ref.mark (case I)
// 8687.1-8687.136: (5.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case J)
// 8688.1-8688.136: (5.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case K)
// 8689.1-8689.99: (5.5): Ref.mark is not Write-Read Stable with respect to Ref.mark (case L)
// 8781.1-8781.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.1)
// 8782.1-8782.101: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.2)
// 8783.1-8783.156: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case A.3)
// 8909.1-8909.140: (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 9040.1-9040.144: (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 9041.1-9041.144: (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 9132.1-9132.136: (5.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 9133.1-9133.136: (5.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 9134.1-9134.144: (5.5): Ref.mark is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 9224.1-9224.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case J)
// 9225.1-9225.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case K)
// 9226.1-9226.99: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Ref.mark (case L)
// 9318.1-9318.140: (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case A.1)
// 9319.1-9319.101: (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case A.2)
// 9320.1-9320.156: (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case A.3)
// 9446.1-9446.140: (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case C)
// 9577.1-9577.144: (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case D)
// 9578.1-9578.144: (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case R)
// 9669.1-9669.136: (5.5): Ref.mark is not Read-Write Stable with respect to Node.item (case F)
// 9670.1-9670.136: (5.5): Ref.mark is not Read-Write Stable with respect to Node.item (case H)
// 9671.1-9671.144: (5.5): Ref.mark is not Read-Write Stable with respect to Node.item (case I)
// 9761.1-9761.136: (18.5): Node.item is not Write-Read Stable with respect to Ref.mark (case J)
// 9762.1-9762.136: (18.5): Node.item is not Write-Read Stable with respect to Ref.mark (case K)
// 9763.1-9763.99: (18.5): Node.item is not Write-Read Stable with respect to Ref.mark (case L)
// 9855.1-9855.140: (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case A.1)
// 9856.1-9856.101: (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case A.2)
// 9857.1-9857.156: (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case A.3)
// 9983.1-9983.140: (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case C)
// 10114.1-10114.144: (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case D)
// 10115.1-10115.144: (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case R)
// 10206.1-10206.136: (5.5): Ref.mark is not Read-Write Stable with respect to Node.next (case F)
// 10207.1-10207.136: (5.5): Ref.mark is not Read-Write Stable with respect to Node.next (case H)
// 10208.1-10208.144: (5.5): Ref.mark is not Read-Write Stable with respect to Node.next (case I)
// 10298.1-10298.136: (19.5): Node.next is not Write-Read Stable with respect to Ref.mark (case J)
// 10299.1-10299.136: (19.5): Node.next is not Write-Read Stable with respect to Ref.mark (case K)
// 10300.1-10300.99: (19.5): Node.next is not Write-Read Stable with respect to Ref.mark (case L)
// 10392.1-10392.140: (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case A.1)
// 10393.1-10393.101: (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case A.2)
// 10394.1-10394.156: (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case A.3)
// 10520.1-10520.140: (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case C)
// 10651.1-10651.144: (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case D)
// 10652.1-10652.144: (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case R)
// 10743.1-10743.136: (5.5): Ref.mark is not Read-Write Stable with respect to List.head (case F)
// 10744.1-10744.136: (5.5): Ref.mark is not Read-Write Stable with respect to List.head (case H)
// 10745.1-10745.144: (5.5): Ref.mark is not Read-Write Stable with respect to List.head (case I)
// 10835.1-10835.136: (35.5): List.head is not Write-Read Stable with respect to Ref.mark (case J)
// 10836.1-10836.136: (35.5): List.head is not Write-Read Stable with respect to Ref.mark (case K)
// 10837.1-10837.99: (35.5): List.head is not Write-Read Stable with respect to Ref.mark (case L)
// 10929.1-10929.140: (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 10930.1-10930.101: (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 10931.1-10931.156: (4.5): Ref.reference is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 11057.1-11057.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case C)
// 11188.1-11188.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case D)
// 11189.1-11189.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.reference (case R)
// 11280.1-11280.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case F)
// 11281.1-11281.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case H)
// 11282.1-11282.144: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.reference (case I)
// 11372.1-11372.136: (4.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 11373.1-11373.136: (4.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 11374.1-11374.99: (4.5): Ref.reference is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 11466.1-11466.140: (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 11467.1-11467.101: (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 11468.1-11468.156: (5.5): Ref.mark is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 11594.1-11594.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case C)
// 11725.1-11725.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case D)
// 11726.1-11726.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Ref.mark (case R)
// 11817.1-11817.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case F)
// 11818.1-11818.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case H)
// 11819.1-11819.144: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Ref.mark (case I)
// 11909.1-11909.136: (5.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 11910.1-11910.136: (5.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 11911.1-11911.99: (5.5): Ref.mark is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 12003.1-12003.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 12004.1-12004.101: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 12005.1-12005.158: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 12131.1-12131.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 12262.1-12262.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 12263.1-12263.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 12354.1-12354.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 12355.1-12355.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 12356.1-12356.146: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 12446.1-12446.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 12447.1-12447.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 12448.1-12448.99: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 12540.1-12540.140: (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 12541.1-12541.101: (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 12542.1-12542.156: (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 12668.1-12668.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case C)
// 12799.1-12799.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case D)
// 12800.1-12800.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case R)
// 12891.1-12891.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.item (case F)
// 12892.1-12892.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.item (case H)
// 12893.1-12893.144: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.item (case I)
// 12983.1-12983.136: (18.5): Node.item is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 12984.1-12984.136: (18.5): Node.item is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 12985.1-12985.99: (18.5): Node.item is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 13077.1-13077.140: (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 13078.1-13078.101: (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 13079.1-13079.156: (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 13205.1-13205.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case C)
// 13336.1-13336.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case D)
// 13337.1-13337.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case R)
// 13428.1-13428.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.next (case F)
// 13429.1-13429.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.next (case H)
// 13430.1-13430.144: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to Node.next (case I)
// 13520.1-13520.136: (19.5): Node.next is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 13521.1-13521.136: (19.5): Node.next is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 13522.1-13522.99: (19.5): Node.next is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 13614.1-13614.140: (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.1)
// 13615.1-13615.101: (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.2)
// 13616.1-13616.156: (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case A.3)
// 13742.1-13742.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case C)
// 13873.1-13873.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case D)
// 13874.1-13874.144: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case R)
// 13965.1-13965.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to List.head (case F)
// 13966.1-13966.136: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to List.head (case H)
// 13967.1-13967.144: (10.5): AtomicMarkableReference.pair is not Read-Write Stable with respect to List.head (case I)
// 14057.1-14057.136: (35.5): List.head is not Write-Read Stable with respect to AtomicMarkableReference.pair (case J)
// 14058.1-14058.136: (35.5): List.head is not Write-Read Stable with respect to AtomicMarkableReference.pair (case K)
// 14059.1-14059.99: (35.5): List.head is not Write-Read Stable with respect to AtomicMarkableReference.pair (case L)
// 14151.1-14151.140: (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case A.1)
// 14152.1-14152.101: (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case A.2)
// 14153.1-14153.156: (4.5): Ref.reference is not Write-Write Stable with respect to Node.item (case A.3)
// 14279.1-14279.140: (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case C)
// 14410.1-14410.144: (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case D)
// 14411.1-14411.144: (18.5): Node.item is not Write-Write Stable with respect to Ref.reference (case R)
// 14502.1-14502.136: (18.5): Node.item is not Read-Write Stable with respect to Ref.reference (case F)
// 14503.1-14503.136: (18.5): Node.item is not Read-Write Stable with respect to Ref.reference (case H)
// 14504.1-14504.144: (18.5): Node.item is not Read-Write Stable with respect to Ref.reference (case I)
// 14594.1-14594.136: (4.5): Ref.reference is not Write-Read Stable with respect to Node.item (case J)
// 14595.1-14595.136: (4.5): Ref.reference is not Write-Read Stable with respect to Node.item (case K)
// 14596.1-14596.99: (4.5): Ref.reference is not Write-Read Stable with respect to Node.item (case L)
// 14688.1-14688.140: (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case A.1)
// 14689.1-14689.101: (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case A.2)
// 14690.1-14690.156: (5.5): Ref.mark is not Write-Write Stable with respect to Node.item (case A.3)
// 14816.1-14816.140: (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case C)
// 14947.1-14947.144: (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case D)
// 14948.1-14948.144: (18.5): Node.item is not Write-Write Stable with respect to Ref.mark (case R)
// 15039.1-15039.136: (18.5): Node.item is not Read-Write Stable with respect to Ref.mark (case F)
// 15040.1-15040.136: (18.5): Node.item is not Read-Write Stable with respect to Ref.mark (case H)
// 15041.1-15041.144: (18.5): Node.item is not Read-Write Stable with respect to Ref.mark (case I)
// 15131.1-15131.136: (5.5): Ref.mark is not Write-Read Stable with respect to Node.item (case J)
// 15132.1-15132.136: (5.5): Ref.mark is not Write-Read Stable with respect to Node.item (case K)
// 15133.1-15133.99: (5.5): Ref.mark is not Write-Read Stable with respect to Node.item (case L)
// 15225.1-15225.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case A.1)
// 15226.1-15226.101: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case A.2)
// 15227.1-15227.156: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.item (case A.3)
// 15353.1-15353.140: (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 15484.1-15484.144: (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 15485.1-15485.144: (18.5): Node.item is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 15576.1-15576.136: (18.5): Node.item is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 15577.1-15577.136: (18.5): Node.item is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 15578.1-15578.144: (18.5): Node.item is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 15668.1-15668.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.item (case J)
// 15669.1-15669.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.item (case K)
// 15670.1-15670.99: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.item (case L)
// 15762.1-15762.140: (18.5): Node.item is not Write-Write Stable with respect to Node.item (case A.1)
// 15763.1-15763.101: (18.5): Node.item is not Write-Write Stable with respect to Node.item (case A.2)
// 15764.1-15764.158: (18.5): Node.item is not Write-Write Stable with respect to Node.item (case A.3)
// 15890.1-15890.140: (18.5): Node.item is not Write-Write Stable with respect to Node.item (case C)
// 16021.1-16021.144: (18.5): Node.item is not Write-Write Stable with respect to Node.item (case D)
// 16022.1-16022.144: (18.5): Node.item is not Write-Write Stable with respect to Node.item (case R)
// 16113.1-16113.136: (18.5): Node.item is not Read-Write Stable with respect to Node.item (case F)
// 16114.1-16114.136: (18.5): Node.item is not Read-Write Stable with respect to Node.item (case H)
// 16115.1-16115.146: (18.5): Node.item is not Read-Write Stable with respect to Node.item (case I)
// 16205.1-16205.136: (18.5): Node.item is not Write-Read Stable with respect to Node.item (case J)
// 16206.1-16206.136: (18.5): Node.item is not Write-Read Stable with respect to Node.item (case K)
// 16207.1-16207.99: (18.5): Node.item is not Write-Read Stable with respect to Node.item (case L)
// 16299.1-16299.140: (19.5): Node.next is not Write-Write Stable with respect to Node.item (case A.1)
// 16300.1-16300.101: (19.5): Node.next is not Write-Write Stable with respect to Node.item (case A.2)
// 16301.1-16301.158: (19.5): Node.next is not Write-Write Stable with respect to Node.item (case A.3)
// 16427.1-16427.140: (18.5): Node.item is not Write-Write Stable with respect to Node.next (case C)
// 16558.1-16558.144: (18.5): Node.item is not Write-Write Stable with respect to Node.next (case D)
// 16559.1-16559.144: (18.5): Node.item is not Write-Write Stable with respect to Node.next (case R)
// 16650.1-16650.136: (18.5): Node.item is not Read-Write Stable with respect to Node.next (case F)
// 16651.1-16651.136: (18.5): Node.item is not Read-Write Stable with respect to Node.next (case H)
// 16652.1-16652.146: (18.5): Node.item is not Read-Write Stable with respect to Node.next (case I)
// 16742.1-16742.136: (19.5): Node.next is not Write-Read Stable with respect to Node.item (case J)
// 16743.1-16743.136: (19.5): Node.next is not Write-Read Stable with respect to Node.item (case K)
// 16744.1-16744.99: (19.5): Node.next is not Write-Read Stable with respect to Node.item (case L)
// 16836.1-16836.140: (35.5): List.head is not Write-Write Stable with respect to Node.item (case A.1)
// 16837.1-16837.101: (35.5): List.head is not Write-Write Stable with respect to Node.item (case A.2)
// 16838.1-16838.156: (35.5): List.head is not Write-Write Stable with respect to Node.item (case A.3)
// 16964.1-16964.140: (18.5): Node.item is not Write-Write Stable with respect to List.head (case C)
// 17095.1-17095.144: (18.5): Node.item is not Write-Write Stable with respect to List.head (case D)
// 17096.1-17096.144: (18.5): Node.item is not Write-Write Stable with respect to List.head (case R)
// 17187.1-17187.136: (18.5): Node.item is not Read-Write Stable with respect to List.head (case F)
// 17188.1-17188.136: (18.5): Node.item is not Read-Write Stable with respect to List.head (case H)
// 17189.1-17189.144: (18.5): Node.item is not Read-Write Stable with respect to List.head (case I)
// 17279.1-17279.136: (35.5): List.head is not Write-Read Stable with respect to Node.item (case J)
// 17280.1-17280.136: (35.5): List.head is not Write-Read Stable with respect to Node.item (case K)
// 17281.1-17281.99: (35.5): List.head is not Write-Read Stable with respect to Node.item (case L)
// 17373.1-17373.140: (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case A.1)
// 17374.1-17374.101: (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case A.2)
// 17375.1-17375.156: (4.5): Ref.reference is not Write-Write Stable with respect to Node.next (case A.3)
// 17501.1-17501.140: (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case C)
// 17632.1-17632.144: (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case D)
// 17633.1-17633.144: (19.5): Node.next is not Write-Write Stable with respect to Ref.reference (case R)
// 17724.1-17724.136: (19.5): Node.next is not Read-Write Stable with respect to Ref.reference (case F)
// 17725.1-17725.136: (19.5): Node.next is not Read-Write Stable with respect to Ref.reference (case H)
// 17726.1-17726.144: (19.5): Node.next is not Read-Write Stable with respect to Ref.reference (case I)
// 17816.1-17816.136: (4.5): Ref.reference is not Write-Read Stable with respect to Node.next (case J)
// 17817.1-17817.136: (4.5): Ref.reference is not Write-Read Stable with respect to Node.next (case K)
// 17818.1-17818.99: (4.5): Ref.reference is not Write-Read Stable with respect to Node.next (case L)
// 17910.1-17910.140: (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case A.1)
// 17911.1-17911.101: (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case A.2)
// 17912.1-17912.156: (5.5): Ref.mark is not Write-Write Stable with respect to Node.next (case A.3)
// 18038.1-18038.140: (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case C)
// 18169.1-18169.144: (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case D)
// 18170.1-18170.144: (19.5): Node.next is not Write-Write Stable with respect to Ref.mark (case R)
// 18261.1-18261.136: (19.5): Node.next is not Read-Write Stable with respect to Ref.mark (case F)
// 18262.1-18262.136: (19.5): Node.next is not Read-Write Stable with respect to Ref.mark (case H)
// 18263.1-18263.144: (19.5): Node.next is not Read-Write Stable with respect to Ref.mark (case I)
// 18353.1-18353.136: (5.5): Ref.mark is not Write-Read Stable with respect to Node.next (case J)
// 18354.1-18354.136: (5.5): Ref.mark is not Write-Read Stable with respect to Node.next (case K)
// 18355.1-18355.99: (5.5): Ref.mark is not Write-Read Stable with respect to Node.next (case L)
// 18447.1-18447.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case A.1)
// 18448.1-18448.101: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case A.2)
// 18449.1-18449.156: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to Node.next (case A.3)
// 18575.1-18575.140: (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 18706.1-18706.144: (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 18707.1-18707.144: (19.5): Node.next is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 18798.1-18798.136: (19.5): Node.next is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 18799.1-18799.136: (19.5): Node.next is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 18800.1-18800.144: (19.5): Node.next is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 18890.1-18890.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.next (case J)
// 18891.1-18891.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.next (case K)
// 18892.1-18892.99: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to Node.next (case L)
// 18984.1-18984.140: (18.5): Node.item is not Write-Write Stable with respect to Node.next (case A.1)
// 18985.1-18985.101: (18.5): Node.item is not Write-Write Stable with respect to Node.next (case A.2)
// 18986.1-18986.158: (18.5): Node.item is not Write-Write Stable with respect to Node.next (case A.3)
// 19112.1-19112.140: (19.5): Node.next is not Write-Write Stable with respect to Node.item (case C)
// 19243.1-19243.144: (19.5): Node.next is not Write-Write Stable with respect to Node.item (case D)
// 19244.1-19244.144: (19.5): Node.next is not Write-Write Stable with respect to Node.item (case R)
// 19335.1-19335.136: (19.5): Node.next is not Read-Write Stable with respect to Node.item (case F)
// 19336.1-19336.136: (19.5): Node.next is not Read-Write Stable with respect to Node.item (case H)
// 19337.1-19337.146: (19.5): Node.next is not Read-Write Stable with respect to Node.item (case I)
// 19427.1-19427.136: (18.5): Node.item is not Write-Read Stable with respect to Node.next (case J)
// 19428.1-19428.136: (18.5): Node.item is not Write-Read Stable with respect to Node.next (case K)
// 19429.1-19429.99: (18.5): Node.item is not Write-Read Stable with respect to Node.next (case L)
// 19521.1-19521.140: (19.5): Node.next is not Write-Write Stable with respect to Node.next (case A.1)
// 19522.1-19522.101: (19.5): Node.next is not Write-Write Stable with respect to Node.next (case A.2)
// 19523.1-19523.158: (19.5): Node.next is not Write-Write Stable with respect to Node.next (case A.3)
// 19649.1-19649.140: (19.5): Node.next is not Write-Write Stable with respect to Node.next (case C)
// 19780.1-19780.144: (19.5): Node.next is not Write-Write Stable with respect to Node.next (case D)
// 19781.1-19781.144: (19.5): Node.next is not Write-Write Stable with respect to Node.next (case R)
// 19872.1-19872.136: (19.5): Node.next is not Read-Write Stable with respect to Node.next (case F)
// 19873.1-19873.136: (19.5): Node.next is not Read-Write Stable with respect to Node.next (case H)
// 19874.1-19874.146: (19.5): Node.next is not Read-Write Stable with respect to Node.next (case I)
// 19964.1-19964.136: (19.5): Node.next is not Write-Read Stable with respect to Node.next (case J)
// 19965.1-19965.136: (19.5): Node.next is not Write-Read Stable with respect to Node.next (case K)
// 19966.1-19966.99: (19.5): Node.next is not Write-Read Stable with respect to Node.next (case L)
// 20058.1-20058.140: (35.5): List.head is not Write-Write Stable with respect to Node.next (case A.1)
// 20059.1-20059.101: (35.5): List.head is not Write-Write Stable with respect to Node.next (case A.2)
// 20060.1-20060.156: (35.5): List.head is not Write-Write Stable with respect to Node.next (case A.3)
// 20186.1-20186.140: (19.5): Node.next is not Write-Write Stable with respect to List.head (case C)
// 20317.1-20317.144: (19.5): Node.next is not Write-Write Stable with respect to List.head (case D)
// 20318.1-20318.144: (19.5): Node.next is not Write-Write Stable with respect to List.head (case R)
// 20409.1-20409.136: (19.5): Node.next is not Read-Write Stable with respect to List.head (case F)
// 20410.1-20410.136: (19.5): Node.next is not Read-Write Stable with respect to List.head (case H)
// 20411.1-20411.144: (19.5): Node.next is not Read-Write Stable with respect to List.head (case I)
// 20501.1-20501.136: (35.5): List.head is not Write-Read Stable with respect to Node.next (case J)
// 20502.1-20502.136: (35.5): List.head is not Write-Read Stable with respect to Node.next (case K)
// 20503.1-20503.99: (35.5): List.head is not Write-Read Stable with respect to Node.next (case L)
// 20595.1-20595.140: (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case A.1)
// 20596.1-20596.101: (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case A.2)
// 20597.1-20597.156: (4.5): Ref.reference is not Write-Write Stable with respect to List.head (case A.3)
// 20723.1-20723.140: (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case C)
// 20854.1-20854.144: (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case D)
// 20855.1-20855.144: (35.5): List.head is not Write-Write Stable with respect to Ref.reference (case R)
// 20946.1-20946.136: (35.5): List.head is not Read-Write Stable with respect to Ref.reference (case F)
// 20947.1-20947.136: (35.5): List.head is not Read-Write Stable with respect to Ref.reference (case H)
// 20948.1-20948.144: (35.5): List.head is not Read-Write Stable with respect to Ref.reference (case I)
// 21038.1-21038.136: (4.5): Ref.reference is not Write-Read Stable with respect to List.head (case J)
// 21039.1-21039.136: (4.5): Ref.reference is not Write-Read Stable with respect to List.head (case K)
// 21040.1-21040.99: (4.5): Ref.reference is not Write-Read Stable with respect to List.head (case L)
// 21132.1-21132.140: (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case A.1)
// 21133.1-21133.101: (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case A.2)
// 21134.1-21134.156: (5.5): Ref.mark is not Write-Write Stable with respect to List.head (case A.3)
// 21260.1-21260.140: (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case C)
// 21391.1-21391.144: (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case D)
// 21392.1-21392.144: (35.5): List.head is not Write-Write Stable with respect to Ref.mark (case R)
// 21483.1-21483.136: (35.5): List.head is not Read-Write Stable with respect to Ref.mark (case F)
// 21484.1-21484.136: (35.5): List.head is not Read-Write Stable with respect to Ref.mark (case H)
// 21485.1-21485.144: (35.5): List.head is not Read-Write Stable with respect to Ref.mark (case I)
// 21575.1-21575.136: (5.5): Ref.mark is not Write-Read Stable with respect to List.head (case J)
// 21576.1-21576.136: (5.5): Ref.mark is not Write-Read Stable with respect to List.head (case K)
// 21577.1-21577.99: (5.5): Ref.mark is not Write-Read Stable with respect to List.head (case L)
// 21669.1-21669.140: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case A.1)
// 21670.1-21670.101: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case A.2)
// 21671.1-21671.156: (10.5): AtomicMarkableReference.pair is not Write-Write Stable with respect to List.head (case A.3)
// 21797.1-21797.140: (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case C)
// 21928.1-21928.144: (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case D)
// 21929.1-21929.144: (35.5): List.head is not Write-Write Stable with respect to AtomicMarkableReference.pair (case R)
// 22020.1-22020.136: (35.5): List.head is not Read-Write Stable with respect to AtomicMarkableReference.pair (case F)
// 22021.1-22021.136: (35.5): List.head is not Read-Write Stable with respect to AtomicMarkableReference.pair (case H)
// 22022.1-22022.144: (35.5): List.head is not Read-Write Stable with respect to AtomicMarkableReference.pair (case I)
// 22112.1-22112.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to List.head (case J)
// 22113.1-22113.136: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to List.head (case K)
// 22114.1-22114.99: (10.5): AtomicMarkableReference.pair is not Write-Read Stable with respect to List.head (case L)
// 22206.1-22206.140: (18.5): Node.item is not Write-Write Stable with respect to List.head (case A.1)
// 22207.1-22207.101: (18.5): Node.item is not Write-Write Stable with respect to List.head (case A.2)
// 22208.1-22208.156: (18.5): Node.item is not Write-Write Stable with respect to List.head (case A.3)
// 22334.1-22334.140: (35.5): List.head is not Write-Write Stable with respect to Node.item (case C)
// 22465.1-22465.144: (35.5): List.head is not Write-Write Stable with respect to Node.item (case D)
// 22466.1-22466.144: (35.5): List.head is not Write-Write Stable with respect to Node.item (case R)
// 22557.1-22557.136: (35.5): List.head is not Read-Write Stable with respect to Node.item (case F)
// 22558.1-22558.136: (35.5): List.head is not Read-Write Stable with respect to Node.item (case H)
// 22559.1-22559.144: (35.5): List.head is not Read-Write Stable with respect to Node.item (case I)
// 22649.1-22649.136: (18.5): Node.item is not Write-Read Stable with respect to List.head (case J)
// 22650.1-22650.136: (18.5): Node.item is not Write-Read Stable with respect to List.head (case K)
// 22651.1-22651.99: (18.5): Node.item is not Write-Read Stable with respect to List.head (case L)
// 22743.1-22743.140: (19.5): Node.next is not Write-Write Stable with respect to List.head (case A.1)
// 22744.1-22744.101: (19.5): Node.next is not Write-Write Stable with respect to List.head (case A.2)
// 22745.1-22745.156: (19.5): Node.next is not Write-Write Stable with respect to List.head (case A.3)
// 22871.1-22871.140: (35.5): List.head is not Write-Write Stable with respect to Node.next (case C)
// 23002.1-23002.144: (35.5): List.head is not Write-Write Stable with respect to Node.next (case D)
// 23003.1-23003.144: (35.5): List.head is not Write-Write Stable with respect to Node.next (case R)
// 23094.1-23094.136: (35.5): List.head is not Read-Write Stable with respect to Node.next (case F)
// 23095.1-23095.136: (35.5): List.head is not Read-Write Stable with respect to Node.next (case H)
// 23096.1-23096.144: (35.5): List.head is not Read-Write Stable with respect to Node.next (case I)
// 23186.1-23186.136: (19.5): Node.next is not Write-Read Stable with respect to List.head (case J)
// 23187.1-23187.136: (19.5): Node.next is not Write-Read Stable with respect to List.head (case K)
// 23188.1-23188.99: (19.5): Node.next is not Write-Read Stable with respect to List.head (case L)
// 23280.1-23280.140: (35.5): List.head is not Write-Write Stable with respect to List.head (case A.1)
// 23281.1-23281.101: (35.5): List.head is not Write-Write Stable with respect to List.head (case A.2)
// 23282.1-23282.158: (35.5): List.head is not Write-Write Stable with respect to List.head (case A.3)
// 23408.1-23408.140: (35.5): List.head is not Write-Write Stable with respect to List.head (case C)
// 23539.1-23539.144: (35.5): List.head is not Write-Write Stable with respect to List.head (case D)
// 23540.1-23540.144: (35.5): List.head is not Write-Write Stable with respect to List.head (case R)
// 23631.1-23631.136: (35.5): List.head is not Read-Write Stable with respect to List.head (case F)
// 23632.1-23632.136: (35.5): List.head is not Read-Write Stable with respect to List.head (case H)
// 23633.1-23633.146: (35.5): List.head is not Read-Write Stable with respect to List.head (case I)
// 23723.1-23723.136: (35.5): List.head is not Write-Read Stable with respect to List.head (case J)
// 23724.1-23724.136: (35.5): List.head is not Write-Read Stable with respect to List.head (case K)
// 23725.1-23725.99: (35.5): List.head is not Write-Read Stable with respect to List.head (case L)
// 23732.1-23732.461: (<undefined position>): Object invariant may not hold.
// 23733.1-23733.366: (<undefined position>): Object invariant may not hold.
// 23734.1-23734.366: (<undefined position>): Object invariant may not hold.
// 23735.1-23735.366: (<undefined position>): Object invariant may not hold.
// 23736.1-23736.366: (<undefined position>): Object invariant may not hold.
// 23737.1-23737.366: (<undefined position>): Object invariant may not hold.
// 23738.1-23738.366: (<undefined position>): Object invariant may not hold.
// 23755.1-23755.460: (<undefined position>): Object invariant may not hold.
// 23756.1-23756.365: (<undefined position>): Object invariant may not hold.
// 23757.1-23757.365: (<undefined position>): Object invariant may not hold.
// 23758.1-23758.365: (<undefined position>): Object invariant may not hold.
// 23759.1-23759.365: (<undefined position>): Object invariant may not hold.
// 23760.1-23760.365: (<undefined position>): Object invariant may not hold.
// 23761.1-23761.365: (<undefined position>): Object invariant may not hold.
// 23781.1-23811.2: (4.5): yields_as clause for Ref.reference is not valid
// 23816.1-23841.2: (4.5): yields_as clause for Ref.reference is not reflexive
// 23847.1-23847.461: (4.32): Object invariant may not hold.
// 23848.1-23848.366: (4.32): Object invariant may not hold.
// 23849.1-23849.366: (4.32): Object invariant may not hold.
// 23850.1-23850.366: (4.32): Object invariant may not hold.
// 23851.1-23851.366: (4.32): Object invariant may not hold.
// 23852.1-23852.366: (4.32): Object invariant may not hold.
// 23853.1-23853.366: (4.32): Object invariant may not hold.
// 23854.1-23904.2: (4.5): yields_as clause for Ref.reference is not transitive
// 23923.1-23953.2: (5.5): yields_as clause for Ref.mark is not valid
// 23958.1-23983.2: (5.5): yields_as clause for Ref.mark is not reflexive
// 23989.1-23989.461: (5.35): Object invariant may not hold.
// 23990.1-23990.366: (5.35): Object invariant may not hold.
// 23991.1-23991.366: (5.35): Object invariant may not hold.
// 23992.1-23992.366: (5.35): Object invariant may not hold.
// 23993.1-23993.366: (5.35): Object invariant may not hold.
// 23994.1-23994.366: (5.35): Object invariant may not hold.
// 23995.1-23995.366: (5.35): Object invariant may not hold.
// 23996.1-24046.2: (5.5): yields_as clause for Ref.mark is not transitive
// 24066.1-24096.2: (7.32): yields_as clause for Ref._lock is not valid
// 24101.1-24126.2: (7.32): yields_as clause for Ref._lock is not reflexive
// 24132.1-24132.461: (3.1): Object invariant may not hold.
// 24133.1-24133.366: (3.1): Object invariant may not hold.
// 24134.1-24134.366: (3.1): Object invariant may not hold.
// 24135.1-24135.366: (3.1): Object invariant may not hold.
// 24136.1-24136.366: (3.1): Object invariant may not hold.
// 24137.1-24137.366: (3.1): Object invariant may not hold.
// 24138.1-24138.366: (3.1): Object invariant may not hold.
// 24139.1-24189.2: (7.32): yields_as clause for Ref._lock is not transitive
// 24208.1-24238.2: (10.5): yields_as clause for AtomicMarkableReference.pair is not valid
// 24243.1-24268.2: (10.5): yields_as clause for AtomicMarkableReference.pair is not reflexive
// 24274.1-24274.461: (10.33): Object invariant may not hold.
// 24275.1-24275.366: (10.33): Object invariant may not hold.
// 24276.1-24276.366: (10.33): Object invariant may not hold.
// 24277.1-24277.366: (10.33): Object invariant may not hold.
// 24278.1-24278.366: (10.33): Object invariant may not hold.
// 24279.1-24279.366: (10.33): Object invariant may not hold.
// 24280.1-24280.366: (10.33): Object invariant may not hold.
// 24281.1-24331.2: (10.5): yields_as clause for AtomicMarkableReference.pair is not transitive
// 24351.1-24381.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not valid
// 24386.1-24411.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not reflexive
// 24417.1-24417.461: (8.1): Object invariant may not hold.
// 24418.1-24418.366: (8.1): Object invariant may not hold.
// 24419.1-24419.366: (8.1): Object invariant may not hold.
// 24420.1-24420.366: (8.1): Object invariant may not hold.
// 24421.1-24421.366: (8.1): Object invariant may not hold.
// 24422.1-24422.366: (8.1): Object invariant may not hold.
// 24423.1-24423.366: (8.1): Object invariant may not hold.
// 24424.1-24474.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not transitive
// 24493.1-24523.2: (18.5): yields_as clause for Node.item is not valid
// 24528.1-24553.2: (18.5): yields_as clause for Node.item is not reflexive
// 24559.1-24559.461: (18.23): Object invariant may not hold.
// 24560.1-24560.366: (18.23): Object invariant may not hold.
// 24561.1-24561.366: (18.23): Object invariant may not hold.
// 24562.1-24562.366: (18.23): Object invariant may not hold.
// 24563.1-24563.366: (18.23): Object invariant may not hold.
// 24564.1-24564.366: (18.23): Object invariant may not hold.
// 24565.1-24565.366: (18.23): Object invariant may not hold.
// 24566.1-24616.2: (18.5): yields_as clause for Node.item is not transitive
// 24635.1-24665.2: (19.5): yields_as clause for Node.next is not valid
// 24670.1-24695.2: (19.5): yields_as clause for Node.next is not reflexive
// 24701.1-24701.461: (19.43): Object invariant may not hold.
// 24702.1-24702.366: (19.43): Object invariant may not hold.
// 24703.1-24703.366: (19.43): Object invariant may not hold.
// 24704.1-24704.366: (19.43): Object invariant may not hold.
// 24705.1-24705.366: (19.43): Object invariant may not hold.
// 24706.1-24706.366: (19.43): Object invariant may not hold.
// 24707.1-24707.366: (19.43): Object invariant may not hold.
// 24708.1-24758.2: (19.5): yields_as clause for Node.next is not transitive
// 24778.1-24808.2: (7.32): yields_as clause for Node._lock is not valid
// 24813.1-24838.2: (7.32): yields_as clause for Node._lock is not reflexive
// 24844.1-24844.461: (17.1): Object invariant may not hold.
// 24845.1-24845.366: (17.1): Object invariant may not hold.
// 24846.1-24846.366: (17.1): Object invariant may not hold.
// 24847.1-24847.366: (17.1): Object invariant may not hold.
// 24848.1-24848.366: (17.1): Object invariant may not hold.
// 24849.1-24849.366: (17.1): Object invariant may not hold.
// 24850.1-24850.366: (17.1): Object invariant may not hold.
// 24851.1-24901.2: (7.32): yields_as clause for Node._lock is not transitive
// 24920.1-24950.2: (35.5): yields_as clause for List.head is not valid
// 24955.1-24980.2: (35.5): yields_as clause for List.head is not reflexive
// 24986.1-24986.461: (35.24): Object invariant may not hold.
// 24987.1-24987.366: (35.24): Object invariant may not hold.
// 24988.1-24988.366: (35.24): Object invariant may not hold.
// 24989.1-24989.366: (35.24): Object invariant may not hold.
// 24990.1-24990.366: (35.24): Object invariant may not hold.
// 24991.1-24991.366: (35.24): Object invariant may not hold.
// 24992.1-24992.366: (35.24): Object invariant may not hold.
// 24993.1-25043.2: (35.5): yields_as clause for List.head is not transitive
// 25063.1-25093.2: (7.32): yields_as clause for List._lock is not valid
// 25098.1-25123.2: (7.32): yields_as clause for List._lock is not reflexive
// 25129.1-25129.461: (33.1): Object invariant may not hold.
// 25130.1-25130.366: (33.1): Object invariant may not hold.
// 25131.1-25131.366: (33.1): Object invariant may not hold.
// 25132.1-25132.366: (33.1): Object invariant may not hold.
// 25133.1-25133.366: (33.1): Object invariant may not hold.
// 25134.1-25134.366: (33.1): Object invariant may not hold.
// 25135.1-25135.366: (33.1): Object invariant may not hold.
// 25136.1-25186.2: (7.32): yields_as clause for List._lock is not transitive
