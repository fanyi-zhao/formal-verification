                                                                                                    
 /*                                                                                                 
                                                                                                    
 /home/fzhao12/Synchronicity/workspace/Synchronicity/tests/atomic-markable-reference.anchor:        
                                                                                                    
 AST:                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
    class Data {                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReferenceResult {                                                           
       Data ref isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Data ref this.nextWriter == tid                                                      
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile boolean mark this.nextWriter == tid                                                  
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile Tid nextWriter isLocal(this, tid)                                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : this.nextWriter == tid                                                                     
         ? isRead                                                                                   
           ? B                                                                                      
           : newValue == tid                                                                        
             ? B                                                                                    
             : newValue == Tid.null ? L : E                                                         
         : isRead                                                                                   
           ? E                                                                                      
           : this.nextWriter == Tid.null && newValue == tid ? R : E !                               
        yields_as this.nextWriter != tid == (newValue != tid);                                      
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        assume this.nextWriter == Tid.null;                                                         
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean cas2(Data expectedRef,Data newRef,boolean expectedMark,boolean newMark) {             
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp1;                                                                             
          boolean tmp2;                                                                             
          tmp2 = ref == expectedRef;                                                                
          if (tmp2) {                                                                               
            tmp1 = mark == expectedMark;                                                            
          } else {                                                                                  
            tmp1 = false;                                                                           
          }                                                                                         
          if (tmp1 /* == ref == expectedRef && mark == expectedMark */) {                           
            this.ref := newRef;                                                                     
            nocheck {                                                                               
              this.mark := newMark;                                                                 
            }                                                                                       
             return true;                                                                           
          } else {                                                                                  
             return false;                                                                          
          }                                                                                         
        } else {                                                                                    
           return false;                                                                            
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(Data expectedRef,boolean newMark) {                                       
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp3;                                                                             
          tmp3 = ref == expectedRef;                                                                
          if (tmp3 /* == ref == expectedRef */) {                                                   
            this.mark := newMark;                                                                   
             return true;                                                                           
          } else {                                                                                  
             return false;                                                                          
          }                                                                                         
        } else {                                                                                    
           return false;                                                                            
        }                                                                                           
        // return false;                                                                            
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      AtomicMarkableReferenceResult get() {                                                         
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == Tid.null;                                                       
          this.nextWriter := tid;                                                                   
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        AtomicMarkableReferenceResult result;                                                       
        result = new AtomicMarkableReferenceResult();                                               
        result.init()                                                                               
        Data tmp4;                                                                                  
        tmp4 := this.ref;                                                                           
        result.ref := tmp4;                                                                         
        nocheck {                                                                                   
          boolean tmp5;                                                                             
          tmp5 := this.mark;                                                                        
          result.mark := tmp5;                                                                      
        }                                                                                           
         return result;                                                                             
        // return AtomicMarkableReferenceResult.null;                                               
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        // return;                                                                                  
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void f() {                                                                             
        AtomicMarkableReference x;                                                                  
        x = new AtomicMarkableReference();                                                          
        x.init()                                                                                    
        Data d;                                                                                     
        d = new Data();                                                                             
        d.init()                                                                                    
        AtomicMarkableReferenceResult result;                                                       
        result = x.get()                                                                            
        yield;                                                                                      
        AtomicMarkableReferenceResult result2;                                                      
        result2 = x.get()                                                                           
        boolean b;                                                                                  
        Data tmp6;                                                                                  
        tmp6 := result.ref;                                                                         
        boolean tmp7;                                                                               
        tmp7 := result.mark;                                                                        
        b = x.cas2(tmp6,Data.null,tmp7,true)                                                        
        if (b /* == b */) {                                                                         
          Data tmp8;                                                                                
          tmp8 := result.ref;                                                                       
          Data tmp9;                                                                                
          tmp9 := result2.ref;                                                                      
          assert tmp8 == tmp9;                                                                      
          boolean tmp10;                                                                            
          tmp10 := result.mark;                                                                     
          boolean tmp11;                                                                            
          tmp11 := result2.mark;                                                                    
          assert tmp10 == tmp11;                                                                    
        } else {                                                                                    
          Data tmp12;                                                                               
          tmp12 := result.ref;                                                                      
          Data tmp13;                                                                               
          tmp13 := result2.ref;                                                                     
          assert tmp12 == tmp13;                                                                    
        }                                                                                           
        assume forall AtomicMarkableReference _i ::_i.nextWriter != tid;                            
        // return;                                                                                  
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Explicit:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Data {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReferenceResult {                                                           
       Data ref isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Data ref this.nextWriter == tid                                                      
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile boolean mark this.nextWriter == tid                                                  
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile Tid nextWriter isLocal(this, tid)                                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : this.nextWriter == tid                                                                     
         ? isRead                                                                                   
           ? B                                                                                      
           : newValue == tid                                                                        
             ? B                                                                                    
             : newValue == Tid.null ? L : E                                                         
         : isRead                                                                                   
           ? E                                                                                      
           : this.nextWriter == Tid.null && newValue == tid ? R : E !                               
        yields_as this.nextWriter != tid == (newValue != tid);                                      
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        assume this.nextWriter == Tid.null;                                                         
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean cas2(Data expectedRef,Data newRef,boolean expectedMark,boolean newMark) {             
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp1;                                                                             
          boolean tmp2;                                                                             
          tmp2 = ref == expectedRef;                                                                
          if (tmp2) {                                                                               
            tmp1 = mark == expectedMark;                                                            
          } else {                                                                                  
            tmp1 = false;                                                                           
          }                                                                                         
          if (tmp1 /* == ref == expectedRef && mark == expectedMark */) {                           
            this.ref := newRef;                                                                     
            nocheck {                                                                               
              this.mark := newMark;                                                                 
            }                                                                                       
            {                                                                                       
               return true;                                                                         
            }                                                                                       
          } else {                                                                                  
            {                                                                                       
               return false;                                                                        
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(Data expectedRef,boolean newMark) {                                       
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp3;                                                                             
          tmp3 = ref == expectedRef;                                                                
          if (tmp3 /* == ref == expectedRef */) {                                                   
            this.mark := newMark;                                                                   
            {                                                                                       
               return true;                                                                         
            }                                                                                       
          } else {                                                                                  
            {                                                                                       
               return false;                                                                        
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      AtomicMarkableReferenceResult get() {                                                         
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == Tid.null;                                                       
          this.nextWriter := tid;                                                                   
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        AtomicMarkableReferenceResult result;                                                       
        result = new AtomicMarkableReferenceResult();                                               
        result.init()                                                                               
        Data tmp4;                                                                                  
        tmp4 := this.ref;                                                                           
        result.ref := tmp4;                                                                         
        nocheck {                                                                                   
          boolean tmp5;                                                                             
          tmp5 := this.mark;                                                                        
          result.mark := tmp5;                                                                      
        }                                                                                           
        {                                                                                           
           return result;                                                                           
        }                                                                                           
        {                                                                                           
          // return AtomicMarkableReferenceResult.null;                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void f() {                                                                             
        AtomicMarkableReference x;                                                                  
        x = new AtomicMarkableReference();                                                          
        x.init()                                                                                    
        Data d;                                                                                     
        d = new Data();                                                                             
        d.init()                                                                                    
        AtomicMarkableReferenceResult result;                                                       
        result = x.get()                                                                            
        yield;                                                                                      
        AtomicMarkableReferenceResult result2;                                                      
        result2 = x.get()                                                                           
        boolean b;                                                                                  
        Data tmp6;                                                                                  
        tmp6 := result.ref;                                                                         
        boolean tmp7;                                                                               
        tmp7 := result.mark;                                                                        
        b = x.cas2(tmp6,Data.null,tmp7,true)                                                        
        if (b /* == b */) {                                                                         
          Data tmp8;                                                                                
          tmp8 := result.ref;                                                                       
          Data tmp9;                                                                                
          tmp9 := result2.ref;                                                                      
          assert tmp8 == tmp9;                                                                      
          boolean tmp10;                                                                            
          tmp10 := result.mark;                                                                     
          boolean tmp11;                                                                            
          tmp11 := result2.mark;                                                                    
          assert tmp10 == tmp11;                                                                    
        } else {                                                                                    
          Data tmp12;                                                                               
          tmp12 := result.ref;                                                                      
          Data tmp13;                                                                               
          tmp13 := result2.ref;                                                                     
          assert tmp12 == tmp13;                                                                    
        }                                                                                           
        assume forall AtomicMarkableReference _i ::_i.nextWriter != tid;                            
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Inlined:                                                                                           
                                                                                                    
                                                                                                    
                                                                                                    
    class Data {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReferenceResult {                                                           
       Data ref isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Data ref this.nextWriter == tid                                                      
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile boolean mark this.nextWriter == tid                                                  
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile Tid nextWriter isLocal(this, tid)                                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : this.nextWriter == tid                                                                     
         ? isRead                                                                                   
           ? B                                                                                      
           : newValue == tid                                                                        
             ? B                                                                                    
             : newValue == Tid.null ? L : E                                                         
         : isRead                                                                                   
           ? E                                                                                      
           : this.nextWriter == Tid.null && newValue == tid ? R : E !                               
        yields_as this.nextWriter != tid == (newValue != tid);                                      
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        assume this.nextWriter == Tid.null;                                                         
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean cas2(Data expectedRef,Data newRef,boolean expectedMark,boolean newMark) {             
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp1;                                                                             
          boolean tmp2;                                                                             
          tmp2 = ref == expectedRef;                                                                
          if (tmp2) {                                                                               
            tmp1 = mark == expectedMark;                                                            
          } else {                                                                                  
            tmp1 = false;                                                                           
          }                                                                                         
          if (tmp1 /* == ref == expectedRef && mark == expectedMark */) {                           
            this.ref := newRef;                                                                     
            nocheck {                                                                               
              this.mark := newMark;                                                                 
            }                                                                                       
            {                                                                                       
               return true;                                                                         
            }                                                                                       
          } else {                                                                                  
            {                                                                                       
               return false;                                                                        
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(Data expectedRef,boolean newMark) {                                       
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp3;                                                                             
          tmp3 = ref == expectedRef;                                                                
          if (tmp3 /* == ref == expectedRef */) {                                                   
            this.mark := newMark;                                                                   
            {                                                                                       
               return true;                                                                         
            }                                                                                       
          } else {                                                                                  
            {                                                                                       
               return false;                                                                        
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      AtomicMarkableReferenceResult get() {                                                         
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == Tid.null;                                                       
          this.nextWriter := tid;                                                                   
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        AtomicMarkableReferenceResult result;                                                       
        result = new AtomicMarkableReferenceResult();                                               
        result.init()                                                                               
        Data tmp4;                                                                                  
        tmp4 := this.ref;                                                                           
        result.ref := tmp4;                                                                         
        nocheck {                                                                                   
          boolean tmp5;                                                                             
          tmp5 := this.mark;                                                                        
          result.mark := tmp5;                                                                      
        }                                                                                           
        {                                                                                           
           return result;                                                                           
        }                                                                                           
        {                                                                                           
          // return AtomicMarkableReferenceResult.null;                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void f() {                                                                             
        AtomicMarkableReference x;                                                                  
        x = new AtomicMarkableReference();                                                          
        {                                                                                           
          inlined x.init();                                                                         
          exit$9: {                                                                                 
            AtomicMarkableReference this$9;                                                         
            this$9 = x;                                                                             
            {                                                                                       
              assume this$9.ref == Data.null;                                                       
              assume this$9.mark == false;                                                          
              assume this$9.nextWriter == Tid.null;                                                 
              {                                                                                     
                {                                                                                   
                  break exit$9;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        Data d;                                                                                     
        d = new Data();                                                                             
        {                                                                                           
          inlined d.init();                                                                         
          exit$10: {                                                                                
            Data this$10;                                                                           
            this$10 = d;                                                                            
            {                                                                                       
              {                                                                                     
                break exit$10;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        AtomicMarkableReferenceResult result;                                                       
        {                                                                                           
          inlined result = x.get();                                                                 
          exit$11: {                                                                                
            AtomicMarkableReference this$11;                                                        
            this$11 = x;                                                                            
            {                                                                                       
              boolean tmp$11;                                                                       
              tmp$11 = *;                                                                           
              if (tmp$11 /* == tmp$11 */) {                                                         
                assume this$11.nextWriter == Tid.null;                                              
                this$11.nextWriter := tid;                                                          
              } else {                                                                              
                                                                                                    
              }                                                                                     
              AtomicMarkableReferenceResult result$11;                                              
              result$11 = new AtomicMarkableReferenceResult();                                      
              {                                                                                     
                inlined result$11.init();                                                           
                exit$12: {                                                                          
                  AtomicMarkableReferenceResult this$12;                                            
                  this$12 = result$11;                                                              
                  {                                                                                 
                    assume this$12.ref == Data.null;                                                
                    assume this$12.mark == false;                                                   
                    {                                                                               
                      {                                                                             
                        break exit$12;                                                              
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              Data tmp4$11;                                                                         
              tmp4$11 := this$11.ref;                                                               
              result$11.ref := tmp4$11;                                                             
              nocheck {                                                                             
                boolean tmp5$11;                                                                    
                tmp5$11 := this$11.mark;                                                            
                result$11.mark := tmp5$11;                                                          
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = result$11;                                                               
                  break exit$11;                                                                    
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = AtomicMarkableReferenceResult.null;                                      
                  break exit$11;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        yield;                                                                                      
        AtomicMarkableReferenceResult result2;                                                      
        {                                                                                           
          inlined result2 = x.get();                                                                
          exit$13: {                                                                                
            AtomicMarkableReference this$13;                                                        
            this$13 = x;                                                                            
            {                                                                                       
              boolean tmp$13;                                                                       
              tmp$13 = *;                                                                           
              if (tmp$13 /* == tmp$13 */) {                                                         
                assume this$13.nextWriter == Tid.null;                                              
                this$13.nextWriter := tid;                                                          
              } else {                                                                              
                                                                                                    
              }                                                                                     
              AtomicMarkableReferenceResult result$13;                                              
              result$13 = new AtomicMarkableReferenceResult();                                      
              {                                                                                     
                inlined result$13.init();                                                           
                exit$14: {                                                                          
                  AtomicMarkableReferenceResult this$14;                                            
                  this$14 = result$13;                                                              
                  {                                                                                 
                    assume this$14.ref == Data.null;                                                
                    assume this$14.mark == false;                                                   
                    {                                                                               
                      {                                                                             
                        break exit$14;                                                              
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              Data tmp4$13;                                                                         
              tmp4$13 := this$13.ref;                                                               
              result$13.ref := tmp4$13;                                                             
              nocheck {                                                                             
                boolean tmp5$13;                                                                    
                tmp5$13 := this$13.mark;                                                            
                result$13.mark := tmp5$13;                                                          
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = result$13;                                                              
                  break exit$13;                                                                    
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = AtomicMarkableReferenceResult.null;                                     
                  break exit$13;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        boolean b;                                                                                  
        Data tmp6;                                                                                  
        tmp6 := result.ref;                                                                         
        boolean tmp7;                                                                               
        tmp7 := result.mark;                                                                        
        {                                                                                           
          inlined b = x.cas2(tmp6,Data.null,tmp7,true);                                             
          exit$15: {                                                                                
            Data expectedRef$15;                                                                    
            Data newRef$15;                                                                         
            boolean expectedMark$15;                                                                
            boolean newMark$15;                                                                     
            AtomicMarkableReference this$15;                                                        
            expectedRef$15 = tmp6;                                                                  
            newRef$15 = Data.null;                                                                  
            expectedMark$15 = tmp7;                                                                 
            newMark$15 = true;                                                                      
            this$15 = x;                                                                            
            {                                                                                       
              boolean tmp$15;                                                                       
              tmp$15 = *;                                                                           
              if (tmp$15 /* == tmp$15 */) {                                                         
                assume this$15.nextWriter == tid;                                                   
                Data ref$15;                                                                        
                boolean mark$15;                                                                    
                nocheck {                                                                           
                  ref$15 := this$15.ref;                                                            
                }                                                                                   
                nocheck {                                                                           
                  mark$15 := this$15.mark;                                                          
                }                                                                                   
                boolean tmp1$15;                                                                    
                boolean tmp2$15;                                                                    
                tmp2$15 = ref$15 == expectedRef$15;                                                 
                if (tmp2$15) {                                                                      
                  tmp1$15 = mark$15 == expectedMark$15;                                             
                } else {                                                                            
                  tmp1$15 = false;                                                                  
                }                                                                                   
                if (tmp1$15 /* == ref$15 == expectedRef$15 && mark$15 == expectedMark$15 */) {      
                  this$15.ref := newRef$15;                                                         
                  nocheck {                                                                         
                    this$15.mark := newMark$15;                                                     
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      b = true;                                                                     
                      break exit$15;                                                                
                    }                                                                               
                  }                                                                                 
                } else {                                                                            
                  {                                                                                 
                    {                                                                               
                      b = false;                                                                    
                      break exit$15;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              } else {                                                                              
                {                                                                                   
                  {                                                                                 
                    b = false;                                                                      
                    break exit$15;                                                                  
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  b = false;                                                                        
                  break exit$15;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        if (b /* == b */) {                                                                         
          Data tmp8;                                                                                
          tmp8 := result.ref;                                                                       
          Data tmp9;                                                                                
          tmp9 := result2.ref;                                                                      
          assert tmp8 == tmp9;                                                                      
          boolean tmp10;                                                                            
          tmp10 := result.mark;                                                                     
          boolean tmp11;                                                                            
          tmp11 := result2.mark;                                                                    
          assert tmp10 == tmp11;                                                                    
        } else {                                                                                    
          Data tmp12;                                                                               
          tmp12 := result.ref;                                                                      
          Data tmp13;                                                                               
          tmp13 := result2.ref;                                                                     
          assert tmp12 == tmp13;                                                                    
        }                                                                                           
        assume forall AtomicMarkableReference _i ::_i.nextWriter != tid;                            
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
 Prepared:                                                                                          
                                                                                                    
                                                                                                    
                                                                                                    
    class Data {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReferenceResult {                                                           
       Data ref isLocal(this, tid)                                                                  
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       boolean mark isLocal(this, tid)                                                              
       ? isLocal(this, tid) ? B : E                                                                 
       : isRead ? B : E                                                                             
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class AtomicMarkableReference {                                                                 
      volatile Data ref this.nextWriter == tid                                                      
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile boolean mark this.nextWriter == tid                                                  
       ? isRead ? R : N                                                                             
       : isRead ? N : E                                                                             
                                                                                                    
      volatile Tid nextWriter isLocal(this, tid)                                                    
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : this.nextWriter == tid                                                                     
         ? isRead                                                                                   
           ? B                                                                                      
           : newValue == tid                                                                        
             ? B                                                                                    
             : newValue == Tid.null ? L : E                                                         
         : isRead                                                                                   
           ? E                                                                                      
           : this.nextWriter == Tid.null && newValue == tid ? R : E !                               
        yields_as this.nextWriter != tid == (newValue != tid);                                      
                                                                                                    
                                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        assume this.ref == Data.null;                                                               
        assume this.mark == false;                                                                  
        assume this.nextWriter == Tid.null;                                                         
        {                                                                                           
          {                                                                                         
            // return;                                                                              
          }                                                                                         
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean cas2(Data expectedRef,Data newRef,boolean expectedMark,boolean newMark) {             
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp1;                                                                             
          boolean tmp2;                                                                             
          tmp2 = ref == expectedRef;                                                                
          if (tmp2) {                                                                               
            tmp1 = mark == expectedMark;                                                            
          } else {                                                                                  
            tmp1 = false;                                                                           
          }                                                                                         
          if (tmp1 /* == ref == expectedRef && mark == expectedMark */) {                           
            this.ref := newRef;                                                                     
            nocheck {                                                                               
              this.mark := newMark;                                                                 
            }                                                                                       
            {                                                                                       
               return true;                                                                         
            }                                                                                       
          } else {                                                                                  
            {                                                                                       
               return false;                                                                        
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      boolean attemptMark(Data expectedRef,boolean newMark) {                                       
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == tid;                                                            
          Data ref;                                                                                 
          boolean mark;                                                                             
          nocheck {                                                                                 
            ref := this.ref;                                                                        
          }                                                                                         
          nocheck {                                                                                 
            mark := this.mark;                                                                      
          }                                                                                         
          boolean tmp3;                                                                             
          tmp3 = ref == expectedRef;                                                                
          if (tmp3 /* == ref == expectedRef */) {                                                   
            this.mark := newMark;                                                                   
            {                                                                                       
               return true;                                                                         
            }                                                                                       
          } else {                                                                                  
            {                                                                                       
               return false;                                                                        
            }                                                                                       
          }                                                                                         
        } else {                                                                                    
          {                                                                                         
             return false;                                                                          
          }                                                                                         
        }                                                                                           
        {                                                                                           
          // return false;                                                                          
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      AtomicMarkableReferenceResult get() {                                                         
        boolean tmp;                                                                                
        tmp = *;                                                                                    
        if (tmp /* == tmp */) {                                                                     
          assume this.nextWriter == Tid.null;                                                       
          this.nextWriter := tid;                                                                   
        } else {                                                                                    
                                                                                                    
        }                                                                                           
        AtomicMarkableReferenceResult result;                                                       
        result = new AtomicMarkableReferenceResult();                                               
        result.init()                                                                               
        Data tmp4;                                                                                  
        tmp4 := this.ref;                                                                           
        result.ref := tmp4;                                                                         
        nocheck {                                                                                   
          boolean tmp5;                                                                             
          tmp5 := this.mark;                                                                        
          result.mark := tmp5;                                                                      
        }                                                                                           
        {                                                                                           
           return result;                                                                           
        }                                                                                           
        {                                                                                           
          // return AtomicMarkableReferenceResult.null;                                             
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
    class Main {                                                                                    
       Tid _lock isLocal(this, tid)                                                                 
       ? isRead                                                                                     
         ? B                                                                                        
         : newValue == tid || newValue == Tid.null ? B : E                                          
       : isRead                                                                                     
         ? this._lock == tid ? R : E                                                                
         : this._lock == Tid.null && newValue == tid                                                
           ? R                                                                                      
           : this._lock == tid && newValue == Tid.null ? L : E !                                    
        yields_as this._lock == tid == (newValue == tid);                                           
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      void init() {                                                                                 
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
      public void f() {                                                                             
        AtomicMarkableReference x;                                                                  
        x = new AtomicMarkableReference();                                                          
        {                                                                                           
          inlined x.init();                                                                         
          exit$9: {                                                                                 
            AtomicMarkableReference this$9;                                                         
            this$9 = x;                                                                             
            {                                                                                       
              assume this$9.ref == Data.null;                                                       
              assume this$9.mark == false;                                                          
              assume this$9.nextWriter == Tid.null;                                                 
              {                                                                                     
                {                                                                                   
                  break exit$9;                                                                     
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        Data d;                                                                                     
        d = new Data();                                                                             
        {                                                                                           
          inlined d.init();                                                                         
          exit$10: {                                                                                
            Data this$10;                                                                           
            this$10 = d;                                                                            
            {                                                                                       
              {                                                                                     
                break exit$10;                                                                      
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        AtomicMarkableReferenceResult result;                                                       
        {                                                                                           
          inlined result = x.get();                                                                 
          exit$11: {                                                                                
            AtomicMarkableReference this$11;                                                        
            this$11 = x;                                                                            
            {                                                                                       
              boolean tmp$11;                                                                       
              tmp$11 = *;                                                                           
              if (tmp$11 /* == tmp$11 */) {                                                         
                assume this$11.nextWriter == Tid.null;                                              
                this$11.nextWriter := tid;                                                          
              } else {                                                                              
                                                                                                    
              }                                                                                     
              AtomicMarkableReferenceResult result$11;                                              
              result$11 = new AtomicMarkableReferenceResult();                                      
              {                                                                                     
                inlined result$11.init();                                                           
                exit$12: {                                                                          
                  AtomicMarkableReferenceResult this$12;                                            
                  this$12 = result$11;                                                              
                  {                                                                                 
                    assume this$12.ref == Data.null;                                                
                    assume this$12.mark == false;                                                   
                    {                                                                               
                      {                                                                             
                        break exit$12;                                                              
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              Data tmp4$11;                                                                         
              tmp4$11 := this$11.ref;                                                               
              result$11.ref := tmp4$11;                                                             
              nocheck {                                                                             
                boolean tmp5$11;                                                                    
                tmp5$11 := this$11.mark;                                                            
                result$11.mark := tmp5$11;                                                          
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = result$11;                                                               
                  break exit$11;                                                                    
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result = AtomicMarkableReferenceResult.null;                                      
                  break exit$11;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        yield;                                                                                      
        AtomicMarkableReferenceResult result2;                                                      
        {                                                                                           
          inlined result2 = x.get();                                                                
          exit$13: {                                                                                
            AtomicMarkableReference this$13;                                                        
            this$13 = x;                                                                            
            {                                                                                       
              boolean tmp$13;                                                                       
              tmp$13 = *;                                                                           
              if (tmp$13 /* == tmp$13 */) {                                                         
                assume this$13.nextWriter == Tid.null;                                              
                this$13.nextWriter := tid;                                                          
              } else {                                                                              
                                                                                                    
              }                                                                                     
              AtomicMarkableReferenceResult result$13;                                              
              result$13 = new AtomicMarkableReferenceResult();                                      
              {                                                                                     
                inlined result$13.init();                                                           
                exit$14: {                                                                          
                  AtomicMarkableReferenceResult this$14;                                            
                  this$14 = result$13;                                                              
                  {                                                                                 
                    assume this$14.ref == Data.null;                                                
                    assume this$14.mark == false;                                                   
                    {                                                                               
                      {                                                                             
                        break exit$14;                                                              
                      }                                                                             
                    }                                                                               
                  }                                                                                 
                }                                                                                   
                inlined return;                                                                     
              }                                                                                     
              Data tmp4$13;                                                                         
              tmp4$13 := this$13.ref;                                                               
              result$13.ref := tmp4$13;                                                             
              nocheck {                                                                             
                boolean tmp5$13;                                                                    
                tmp5$13 := this$13.mark;                                                            
                result$13.mark := tmp5$13;                                                          
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = result$13;                                                              
                  break exit$13;                                                                    
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  result2 = AtomicMarkableReferenceResult.null;                                     
                  break exit$13;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        boolean b;                                                                                  
        Data tmp6;                                                                                  
        tmp6 := result.ref;                                                                         
        boolean tmp7;                                                                               
        tmp7 := result.mark;                                                                        
        {                                                                                           
          inlined b = x.cas2(tmp6,Data.null,tmp7,true);                                             
          exit$15: {                                                                                
            Data expectedRef$15;                                                                    
            Data newRef$15;                                                                         
            boolean expectedMark$15;                                                                
            boolean newMark$15;                                                                     
            AtomicMarkableReference this$15;                                                        
            expectedRef$15 = tmp6;                                                                  
            newRef$15 = Data.null;                                                                  
            expectedMark$15 = tmp7;                                                                 
            newMark$15 = true;                                                                      
            this$15 = x;                                                                            
            {                                                                                       
              boolean tmp$15;                                                                       
              tmp$15 = *;                                                                           
              if (tmp$15 /* == tmp$15 */) {                                                         
                assume this$15.nextWriter == tid;                                                   
                Data ref$15;                                                                        
                boolean mark$15;                                                                    
                nocheck {                                                                           
                  ref$15 := this$15.ref;                                                            
                }                                                                                   
                nocheck {                                                                           
                  mark$15 := this$15.mark;                                                          
                }                                                                                   
                boolean tmp1$15;                                                                    
                boolean tmp2$15;                                                                    
                tmp2$15 = ref$15 == expectedRef$15;                                                 
                if (tmp2$15) {                                                                      
                  tmp1$15 = mark$15 == expectedMark$15;                                             
                } else {                                                                            
                  tmp1$15 = false;                                                                  
                }                                                                                   
                if (tmp1$15 /* == ref$15 == expectedRef$15 && mark$15 == expectedMark$15 */) {      
                  this$15.ref := newRef$15;                                                         
                  nocheck {                                                                         
                    this$15.mark := newMark$15;                                                     
                  }                                                                                 
                  {                                                                                 
                    {                                                                               
                      b = true;                                                                     
                      break exit$15;                                                                
                    }                                                                               
                  }                                                                                 
                } else {                                                                            
                  {                                                                                 
                    {                                                                               
                      b = false;                                                                    
                      break exit$15;                                                                
                    }                                                                               
                  }                                                                                 
                }                                                                                   
              } else {                                                                              
                {                                                                                   
                  {                                                                                 
                    b = false;                                                                      
                    break exit$15;                                                                  
                  }                                                                                 
                }                                                                                   
              }                                                                                     
              {                                                                                     
                {                                                                                   
                  b = false;                                                                        
                  break exit$15;                                                                    
                }                                                                                   
              }                                                                                     
            }                                                                                       
          }                                                                                         
          inlined return;                                                                           
        }                                                                                           
        if (b /* == b */) {                                                                         
          Data tmp8;                                                                                
          tmp8 := result.ref;                                                                       
          Data tmp9;                                                                                
          tmp9 := result2.ref;                                                                      
          assert tmp8 == tmp9;                                                                      
          boolean tmp10;                                                                            
          tmp10 := result.mark;                                                                     
          boolean tmp11;                                                                            
          tmp11 := result2.mark;                                                                    
          assert tmp10 == tmp11;                                                                    
        } else {                                                                                    
          Data tmp12;                                                                               
          tmp12 := result.ref;                                                                      
          Data tmp13;                                                                               
          tmp13 := result2.ref;                                                                     
          assert tmp12 == tmp13;                                                                    
        }                                                                                           
        assume forall AtomicMarkableReference _i ::_i.nextWriter != tid;                            
        {                                                                                           
          // return;                                                                                
        }                                                                                           
      }                                                                                             
                                                                                                    
    }                                                                                               
                                                                                                    
                                                                                                    
 */                                                                                                 
                                                                                                    
//// Background                                                                                     
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * Tid                                                                                              
 */                                                                                                 
 type Tid = int;  // make int so you can iterate over Tids                                          
 const unique Tid.null: Tid;                                                                        
 axiom Tid.null == -1;                                                                              
                                                                                                    
 function {:inline} ValidTid(tid : Tid): bool {                                                     
  tid != Tid.null && tid >= 0                                                                       
 }                                                                                                  
                                                                                                    
 type{:datatype} State;                                                                             
 function{:constructor} NULL(): State;                                                              
 function{:constructor} FRESH(): State;                                                             
 function{:constructor} LOCAL(t: Tid): State;                                                       
 function{:constructor} SHARED(): State;                                                            
                                                                                                    
 function {:inline} isNull(state: State) : bool {                                                   
  state == NULL()                                                                                   
 }                                                                                                  
                                                                                                    
 function {:inline} isFresh(state: State) : bool {                                                  
  state == FRESH()                                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} isShared(state: State) : bool {                                                 
  state == SHARED()                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocal(state: State, t: Tid) : bool {                                          
  state == LOCAL(t)                                                                                 
 }                                                                                                  
                                                                                                    
 function {:inline} isLocalAssignable(state: State, t: Tid) : bool {                                
  state == LOCAL(t) || state == SHARED() || state == NULL()                                         
 }                                                                                                  
                                                                                                    
 function {:inline} isSharedAssignable(state: State) : bool {                                       
  state == SHARED() || state == NULL()                                                              
 }                                                                                                  
                                                                                                    
 function {:inline} isAccessible(state: State, t: Tid) : bool {                                     
  state == LOCAL(t) || state == SHARED()                                                            
 }                                                                                                  
                                                                                                    
 function {:inline} isAllocated(state: State) : bool {                                              
  !isFresh(state) && !isNull(state)                                                                 
 }                                                                                                  
                                                                                                    
                                                                                                    
 function MOD(x:int, y:int): int;                                                                   
                                                                                                    
                                                                                                    
 /*                                                                                                 
 * For triggers                                                                                     
 */                                                                                                 
 function {:inline false} _trigger(i: int): bool {  true  }                                         
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 type Phase;                                                                                        
 const unique PreCommit : Phase;                                                                    
 const unique PostCommit : Phase;                                                                   
 const unique PhaseError : Phase;                                                                   
                                                                                                    
 function {:inline} transition(p: Phase, m: Mover): Phase {                                         
  if (m == _B) then                                                                                 
   p                                                                                                
  else if (m == _R) then                                                                            
   if (p == PreCommit) then                                                                         
    PreCommit                                                                                       
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _L) then                                                                            
   if (p == PostCommit) then                                                                        
    PostCommit                                                                                      
   else if (p == PreCommit) then                                                                    
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else if (m == _N) then                                                                            
   if (p == PreCommit) then                                                                         
    PostCommit                                                                                      
   else                                                                                             
    PhaseError                                                                                      
  else                                                                                              
   PhaseError // m == E or m == I                                                                   
 }                                                                                                  
                                                                                                    
                                                                                                    
 type Mover;                                                                                        
 const unique _B : Mover;                                                                           
 const unique _R : Mover;                                                                           
 const unique _L : Mover;                                                                           
 const unique _N : Mover;                                                                           
 const unique _E : Mover;                                                                           
                                                                                                    
 axiom (forall m : Mover :: m == _B || m == _R || m == _L || m == _N || m == _E);                   
                                                                                                    
 function {:inline} leq(m1: Mover, m2: Mover) : bool {                                              
  if (m1 == _B) then                                                                                
   true                                                                                             
  else if (m1 == _R) then                                                                           
   m2 == _R || m2 == _N || m2 == _E                                                                 
  else if (m1 == _L) then                                                                           
   m2 == _L || m2 == _N || m2 == _E                                                                 
  else if (m1 == _N) then                                                                           
   m2 == _N || m2 == _E                                                                             
  else if (m1 == _E) then                                                                           
   m2 == _E                                                                                         
  else                                                                                              
   false // should never happen...                                                                  
 }                                                                                                  
                                                                                                    
 function {:inline} lt(m1: Mover, m2: Mover) : bool { m1 != m2 && leq(m1, m2) }                     
                                                                                                    
 function {:inline} isError(m : Mover) : bool {                                                     
  m == _E                                                                                           
 }                                                                                                  
                                                                                                    
 function {:inline} eqOrError(m : Mover, n : Mover) : bool {                                        
  m == n || m == _E                                                                                 
 }                                                                                                  
                                                                                                    
 type{:datatype} MoverPath;                                                                         
 function{:constructor} moverPath(m:Mover, p:int):MoverPath;                                        
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// axioms                                                                                         
                                                                                                    
                                                                                                    
//// classes                                                                                        
                                                                                                    
                                                                                                    
/*** Class Decl Data ***/                                                                           
                                                                                                    
type Data;                                                                                          
const unique Data.null: Data;                                                                       
var Data._state: [Data]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Data._lock: [Data]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Data._lock(tid: Tid,this : Data,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Data._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Data._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Data._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Data._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Data._lock(tid: Tid,this : Data,newValue: Tid,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Data._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Data._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Data._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Data._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl AtomicMarkableReferenceResult ***/                                                  
                                                                                                    
type AtomicMarkableReferenceResult;                                                                 
const unique AtomicMarkableReferenceResult.null: AtomicMarkableReferenceResult;                     
var AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State;                     
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data;                         
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReferenceResult.ref(tid: Tid,this : AtomicMarkableReferenceResult,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Data.null;                                                                        
 if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                 
  if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReferenceResult.ref(tid: Tid,this : AtomicMarkableReferenceResult,newValue: Data,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                 
  if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool;                        
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReferenceResult.mark(tid: Tid,this : AtomicMarkableReferenceResult,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := false;                                                                            
 if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                 
  if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReferenceResult.mark(tid: Tid,this : AtomicMarkableReferenceResult,newValue: bool,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                 
  if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   moverPath(_E, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_B, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid;                        
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReferenceResult._lock(tid: Tid,this : AtomicMarkableReferenceResult,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                 
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReferenceResult._lock[this]==tid)) then                                       
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReferenceResult._lock[this]==Tid.null)&&(newValue==tid))) then               
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReferenceResult._lock[this]==tid)&&(newValue==Tid.null))) then              
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReferenceResult._lock(tid: Tid,this : AtomicMarkableReferenceResult,newValue: Tid,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReferenceResult._state[this], tid)) then                                 
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReferenceResult._lock[this]==tid)) then                                       
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReferenceResult._lock[this]==Tid.null)&&(newValue==tid))) then               
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReferenceResult._lock[this]==tid)&&(newValue==Tid.null))) then              
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl AtomicMarkableReference ***/                                                        
                                                                                                    
type AtomicMarkableReference;                                                                       
const unique AtomicMarkableReference.null: AtomicMarkableReference;                                 
var AtomicMarkableReference._state: [AtomicMarkableReference]State;                                 
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.ref: [AtomicMarkableReference]Data;                                     
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.ref(tid: Tid,this : AtomicMarkableReference,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Data.null;                                                                        
 if ((AtomicMarkableReference.nextWriter[this]==tid)) then                                          
  if (isRead) then                                                                                  
   moverPath(_R, 3)                                                                                 
  else                                                                                              
   moverPath(_N, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.ref(tid: Tid,this : AtomicMarkableReference,newValue: Data,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if ((AtomicMarkableReference.nextWriter[this]==tid)) then                                          
  if (isRead) then                                                                                  
   moverPath(_R, 3)                                                                                 
  else                                                                                              
   moverPath(_N, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.mark: [AtomicMarkableReference]bool;                                    
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.mark(tid: Tid,this : AtomicMarkableReference,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := false;                                                                            
 if ((AtomicMarkableReference.nextWriter[this]==tid)) then                                          
  if (isRead) then                                                                                  
   moverPath(_R, 3)                                                                                 
  else                                                                                              
   moverPath(_N, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.mark(tid: Tid,this : AtomicMarkableReference,newValue: bool,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if ((AtomicMarkableReference.nextWriter[this]==tid)) then                                          
  if (isRead) then                                                                                  
   moverPath(_R, 3)                                                                                 
  else                                                                                              
   moverPath(_N, 1)                                                                                 
 else                                                                                               
  if (isRead) then                                                                                  
   moverPath(_N, 2)                                                                                 
  else                                                                                              
   moverPath(_E, 0)                                                                                 
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid;                               
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference.nextWriter(tid: Tid,this : AtomicMarkableReference,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if ((AtomicMarkableReference.nextWriter[this]==tid)) then                                         
   if (isRead) then                                                                                 
    moverPath(_B, 6)                                                                                
   else                                                                                             
    if ((newValue==tid)) then                                                                       
     moverPath(_B, 10)                                                                              
    else                                                                                            
     if ((newValue==Tid.null)) then                                                                 
      moverPath(_L, 18)                                                                             
     else                                                                                           
      moverPath(_E, 2)                                                                              
  else                                                                                              
   if (isRead) then                                                                                 
    moverPath(_E, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference.nextWriter[this]==Tid.null)&&(newValue==tid))) then               
     moverPath(_R, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference.nextWriter(tid: Tid,this : AtomicMarkableReference,newValue: Tid,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if ((AtomicMarkableReference.nextWriter[this]==tid)) then                                         
   if (isRead) then                                                                                 
    moverPath(_B, 6)                                                                                
   else                                                                                             
    if ((newValue==tid)) then                                                                       
     moverPath(_B, 10)                                                                              
    else                                                                                            
     if ((newValue==Tid.null)) then                                                                 
      moverPath(_L, 18)                                                                             
     else                                                                                           
      moverPath(_E, 2)                                                                              
  else                                                                                              
   if (isRead) then                                                                                 
    moverPath(_E, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference.nextWriter[this]==Tid.null)&&(newValue==tid))) then               
     moverPath(_R, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
var AtomicMarkableReference._lock: [AtomicMarkableReference]Tid;                                    
                                                                                                    
function {:inline} ReadEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.AtomicMarkableReference._lock(tid: Tid,this : AtomicMarkableReference,newValue: Tid,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(AtomicMarkableReference._state[this], tid)) then                                       
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((AtomicMarkableReference._lock[this]==tid)) then                                             
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((AtomicMarkableReference._lock[this]==Tid.null)&&(newValue==tid))) then                     
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((AtomicMarkableReference._lock[this]==tid)&&(newValue==Tid.null))) then                    
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
/*** Class Decl Main ***/                                                                           
                                                                                                    
type Main;                                                                                          
const unique Main.null: Main;                                                                       
var Main._state: [Main]State;                                                                       
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
var Main._lock: [Main]Tid;                                                                          
                                                                                                    
function {:inline} ReadEval.Main._lock(tid: Tid,this : Main,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := true;                                                                               
 (var newValue := Tid.null;                                                                         
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
 )                                                                                                  
}                                                                                                   
                                                                                                    
function {:inline} WriteEval.Main._lock(tid: Tid,this : Main,newValue: Tid,Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (MoverPath) {
 (var isRead := false;                                                                              
 if (isLocal(Main._state[this], tid)) then                                                          
  if (isRead) then                                                                                  
   moverPath(_B, 3)                                                                                 
  else                                                                                              
   if (((newValue==tid)||(newValue==Tid.null))) then                                                
    moverPath(_B, 5)                                                                                
   else                                                                                             
    moverPath(_E, 1)                                                                                
 else                                                                                               
  if (isRead) then                                                                                  
   if ((Main._lock[this]==tid)) then                                                                
    moverPath(_R, 6)                                                                                
   else                                                                                             
    moverPath(_E, 2)                                                                                
  else                                                                                              
   if (((Main._lock[this]==Tid.null)&&(newValue==tid))) then                                        
    moverPath(_R, 4)                                                                                
   else                                                                                             
    if (((Main._lock[this]==tid)&&(newValue==Tid.null))) then                                       
     moverPath(_L, 8)                                                                               
    else                                                                                            
     moverPath(_E, 0)                                                                               
 )                                                                                                  
}                                                                                                   
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
/////                                                                                               
                                                                                                    
/////                                                                                               
                                                                                                    
                                                                                                    
procedure  Main.f(tid:Tid, this : Main)                                                             
modifies Data._state;                                                                               
modifies Data._lock;                                                                                
modifies AtomicMarkableReferenceResult._state;                                                      
modifies AtomicMarkableReferenceResult.ref;                                                         
modifies AtomicMarkableReferenceResult.mark;                                                        
modifies AtomicMarkableReferenceResult._lock;                                                       
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.ref;                                                               
modifies AtomicMarkableReference.mark;                                                              
modifies AtomicMarkableReference.nextWriter;                                                        
modifies AtomicMarkableReference._lock;                                                             
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
                                                                                                    
requires ValidTid(tid);                                                                                    // (82.5): Bad tid
requires isShared(Main._state[this]);                                                                      // (82.5): this is not global
                                                                                                    
requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
                                                                                                    
ensures StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
{                                                                                                   
 var $pc308769: Phase;                                                                              
 var ref$15: Data;                                                                                  
 var AtomicMarkableReference._lock308611: [AtomicMarkableReference]Tid;                             
 var $recorded.state308763: int;                                                                    
 var this$13: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._lock308643_post: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReferenceResult._lock308924: [AtomicMarkableReferenceResult]Tid;                 
 var tmp7308769: bool;                                                                              
 var AtomicMarkableReferenceResult._state308868: [AtomicMarkableReferenceResult]State;              
 var x308560: AtomicMarkableReference;                                                              
 var tmp$15308868: bool;                                                                            
 var AtomicMarkableReference._lock308769: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.mark308959: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReference.ref308947: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReferenceResult.ref308947: [AtomicMarkableReferenceResult]Data;                  
 var Data._state308672: [Data]State;                                                                
 var x308970: AtomicMarkableReference;                                                              
 var this$11308611: AtomicMarkableReference;                                                        
 var AtomicMarkableReferenceResult.mark308643_post: [AtomicMarkableReferenceResult]bool;            
 var AtomicMarkableReference._state308952: [AtomicMarkableReference]State;                          
 var mover308924: Mover;                                                                            
 var this308959: Main;                                                                              
 var b308965: bool;                                                                                 
 var tmp6308941: Data;                                                                              
 var d308608: Data;                                                                                 
 var this308924: Main;                                                                              
 var $recorded.state308720: int;                                                                    
 var tid308611: Tid;                                                                                
 var Main._state308941: [Main]State;                                                                
 var Main._lock308560: [Main]Tid;                                                                   
 var tmp12: Data;                                                                                   
 var AtomicMarkableReferenceResult.ref308941: [AtomicMarkableReferenceResult]Data;                  
 var result308965: AtomicMarkableReferenceResult;                                                   
 var $recorded.state308560: int;                                                                    
 var AtomicMarkableReferenceResult.ref308930: [AtomicMarkableReferenceResult]Data;                  
 var AtomicMarkableReferenceResult._state308643: [AtomicMarkableReferenceResult]State;              
 var AtomicMarkableReference._state308560: [AtomicMarkableReference]State;                          
 var AtomicMarkableReferenceResult._state308643_post: [AtomicMarkableReferenceResult]State;         
 var $pc308930: Phase;                                                                              
 var this308952: Main;                                                                              
 var x308763: AtomicMarkableReference;                                                              
 var ref$15308868: Data;                                                                            
 var tmp7308947: bool;                                                                              
 var AtomicMarkableReference._lock308763: [AtomicMarkableReference]Tid;                             
 var b308868: bool;                                                                                 
 var tid308952: Tid;                                                                                
 var AtomicMarkableReferenceResult.mark308970: [AtomicMarkableReferenceResult]bool;                 
 var tmp8308941: Data;                                                                              
 var AtomicMarkableReferenceResult._state308672: [AtomicMarkableReferenceResult]State;              
 var Data._state308924: [Data]State;                                                                
 var this308720: Main;                                                                              
 var this308947: Main;                                                                              
 var Main._state308935: [Main]State;                                                                
 var this308723: Main;                                                                              
 var this$11308608: AtomicMarkableReference;                                                        
 var AtomicMarkableReferenceResult.ref308763: [AtomicMarkableReferenceResult]Data;                  
 var AtomicMarkableReferenceResult.ref308959: [AtomicMarkableReferenceResult]Data;                  
 var Data._state308720: [Data]State;                                                                
 var $pc308970: Phase;                                                                              
 var AtomicMarkableReferenceResult._state308769: [AtomicMarkableReferenceResult]State;              
 var AtomicMarkableReferenceResult._state308941: [AtomicMarkableReferenceResult]State;              
 var AtomicMarkableReferenceResult._lock308959: [AtomicMarkableReferenceResult]Tid;                 
 var b308970: bool;                                                                                 
 var AtomicMarkableReferenceResult._state308723: [AtomicMarkableReferenceResult]State;              
 var d308970: Data;                                                                                 
 var mover308769: Mover;                                                                            
 var Data._state308868: [Data]State;                                                                
 var Data._lock308930: [Data]Tid;                                                                   
 var mover308611: Mover;                                                                            
 var tmp6308763: Data;                                                                              
 var Data._lock308947: [Data]Tid;                                                                   
 var AtomicMarkableReferenceResult._state308982: [AtomicMarkableReferenceResult]State;              
 var Data._lock308952: [Data]Tid;                                                                   
 var AtomicMarkableReferenceResult.ref308643: [AtomicMarkableReferenceResult]Data;                  
 var $pc308868: Phase;                                                                              
 var tmp12308970: Data;                                                                             
 var AtomicMarkableReference.nextWriter308930: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReferenceResult.mark308643: [AtomicMarkableReferenceResult]bool;                 
 var moverPath308608: MoverPath;                                                                    
 var AtomicMarkableReferenceResult._lock308952: [AtomicMarkableReferenceResult]Tid;                 
 var tmp11308952: bool;                                                                             
 var tmp$11: bool;                                                                                  
 var d308952: Data;                                                                                 
 var AtomicMarkableReferenceResult._state308924: [AtomicMarkableReferenceResult]State;              
 var tid308560: Tid;                                                                                
 var AtomicMarkableReferenceResult.mark308924: [AtomicMarkableReferenceResult]bool;                 
 var tid308965: Tid;                                                                                
 var this$13308672: AtomicMarkableReference;                                                        
 var Main._lock308769: [Main]Tid;                                                                   
 var tmp12308959: Data;                                                                             
 var AtomicMarkableReferenceResult._lock308672: [AtomicMarkableReferenceResult]Tid;                 
 var tmp10308952: bool;                                                                             
 var mover308868: Mover;                                                                            
 var AtomicMarkableReferenceResult.mark308672: [AtomicMarkableReferenceResult]bool;                 
 var AtomicMarkableReferenceResult.mark308769: [AtomicMarkableReferenceResult]bool;                 
 var Main._lock308924: [Main]Tid;                                                                   
 var Main._state308720: [Main]State;                                                                
 var $pc308941: Phase;                                                                              
 var Data._state308941: [Data]State;                                                                
 var AtomicMarkableReference.ref308643_post: [AtomicMarkableReference]Data;                         
 var $pc308924: Phase;                                                                              
 var moverPath308723: MoverPath;                                                                    
 var this308608: Main;                                                                              
 var tmp7308941: bool;                                                                              
 var Data._state308769: [Data]State;                                                                
 var AtomicMarkableReference._state308930: [AtomicMarkableReference]State;                          
 var newRef$15: Data;                                                                               
 var AtomicMarkableReference.ref308769: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReferenceResult.ref308611: [AtomicMarkableReferenceResult]Data;                  
 var AtomicMarkableReference._state308720: [AtomicMarkableReference]State;                          
 var AtomicMarkableReferenceResult.mark308720: [AtomicMarkableReferenceResult]bool;                 
 var AtomicMarkableReference._state308924: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference.nextWriter308560: [AtomicMarkableReference]Tid;                        
 var Main._state308611: [Main]State;                                                                
 var AtomicMarkableReferenceResult._lock308643_post: [AtomicMarkableReferenceResult]Tid;            
 var tmp12308965: Data;                                                                             
 var result308643_post: AtomicMarkableReferenceResult;                                              
 var result308924: AtomicMarkableReferenceResult;                                                   
 var $pc308935: Phase;                                                                              
 var mark$15: bool;                                                                                 
 var tmp7308952: bool;                                                                              
 var Main._lock308941: [Main]Tid;                                                                   
 var path308930: int;                                                                               
 var $recorded.state308965: int;                                                                    
 var AtomicMarkableReference.nextWriter308769: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReference._state308643: [AtomicMarkableReference]State;                          
 var d308982: Data;                                                                                 
 var this308560: Main;                                                                              
 var $recorded.state308723: int;                                                                    
 var result$11308611: AtomicMarkableReferenceResult;                                                
 var result308947: AtomicMarkableReferenceResult;                                                   
 var tmp8308947: Data;                                                                              
 var result308643: AtomicMarkableReferenceResult;                                                   
 var path308672: int;                                                                               
 var $pc308952: Phase;                                                                              
 var moverPath308965: MoverPath;                                                                    
 var AtomicMarkableReferenceResult._state308611: [AtomicMarkableReferenceResult]State;              
 var AtomicMarkableReference.nextWriter308959: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReference.ref308935: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReference.ref308560: [AtomicMarkableReference]Data;                              
 var Main._state308970: [Main]State;                                                                
 var Main._lock308970: [Main]Tid;                                                                   
 var AtomicMarkableReference._lock308982: [AtomicMarkableReference]Tid;                             
 var $pc308672: Phase;                                                                              
 var AtomicMarkableReference.mark308924: [AtomicMarkableReference]bool;                             
 var tid308720: Tid;                                                                                
 var this308769: Main;                                                                              
 var AtomicMarkableReference.ref308965: [AtomicMarkableReference]Data;                              
 var $recorded.state308672: int;                                                                    
 var result2308959: AtomicMarkableReferenceResult;                                                  
 var result308560: AtomicMarkableReferenceResult;                                                   
 var AtomicMarkableReference.nextWriter308941: [AtomicMarkableReference]Tid;                        
 var Main._lock308947: [Main]Tid;                                                                   
 var AtomicMarkableReference.ref308982: [AtomicMarkableReference]Data;                              
 var result308935: AtomicMarkableReferenceResult;                                                   
 var Main._state308965: [Main]State;                                                                
 var result$13308720: AtomicMarkableReferenceResult;                                                
 var AtomicMarkableReference.ref308720: [AtomicMarkableReference]Data;                              
 var Data._state308935: [Data]State;                                                                
 var d308720: Data;                                                                                 
 var tid308672: Tid;                                                                                
 var $pc308608: Phase;                                                                              
 var AtomicMarkableReference.ref308924: [AtomicMarkableReference]Data;                              
 var tmp10308947: bool;                                                                             
 var AtomicMarkableReference._lock308608: [AtomicMarkableReference]Tid;                             
 var moverPath308672: MoverPath;                                                                    
 var AtomicMarkableReference.ref308611: [AtomicMarkableReference]Data;                              
 var d308611: Data;                                                                                 
 var mover308959: Mover;                                                                            
 var AtomicMarkableReferenceResult._lock308763: [AtomicMarkableReferenceResult]Tid;                 
 var result: AtomicMarkableReferenceResult;                                                         
 var result308930: AtomicMarkableReferenceResult;                                                   
 var Main._state308952: [Main]State;                                                                
 var result$13: AtomicMarkableReferenceResult;                                                      
 var mover308763: Mover;                                                                            
 var mover308965: Mover;                                                                            
 var Data._lock308965: [Data]Tid;                                                                   
 var AtomicMarkableReference._lock308868: [AtomicMarkableReference]Tid;                             
 var tmp1$15: bool;                                                                                 
 var tmp7308935: bool;                                                                              
 var this308982: Main;                                                                              
 var d308959: Data;                                                                                 
 var x: AtomicMarkableReference;                                                                    
 var d308868: Data;                                                                                 
 var this$12: AtomicMarkableReferenceResult;                                                        
 var Data._state308643: [Data]State;                                                                
 var this308763: Main;                                                                              
 var tmp13308965: Data;                                                                             
 var mover308941: Mover;                                                                            
 var AtomicMarkableReferenceResult._lock308769: [AtomicMarkableReferenceResult]Tid;                 
 var Data._state308947: [Data]State;                                                                
 var Data._state308982: [Data]State;                                                                
 var $recorded.state308935: int;                                                                    
 var AtomicMarkableReference.ref308608: [AtomicMarkableReference]Data;                              
 var moverPath308959: MoverPath;                                                                    
 var tmp6308924: Data;                                                                              
 var tid308982: Tid;                                                                                
 var AtomicMarkableReference.nextWriter308763: [AtomicMarkableReference]Tid;                        
 var this308868: Main;                                                                              
 var $recorded.state308868: int;                                                                    
 var AtomicMarkableReferenceResult._lock308970: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReferenceResult._lock308930: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReferenceResult.ref308720: [AtomicMarkableReferenceResult]Data;                  
 var x308959: AtomicMarkableReference;                                                              
 var AtomicMarkableReference.nextWriter308935: [AtomicMarkableReference]Tid;                        
 var moverPath308947: MoverPath;                                                                    
 var $pc308611: Phase;                                                                              
 var b308947: bool;                                                                                 
 var result2308672: AtomicMarkableReferenceResult;                                                  
 var tmp8308935: Data;                                                                              
 var result308608: AtomicMarkableReferenceResult;                                                   
 var AtomicMarkableReference.nextWriter308947: [AtomicMarkableReference]Tid;                        
 var expectedMark$15308868: bool;                                                                   
 var AtomicMarkableReference.ref308723: [AtomicMarkableReference]Data;                              
 var x308868: AtomicMarkableReference;                                                              
 var tmp6308982: Data;                                                                              
 var AtomicMarkableReference._state308941: [AtomicMarkableReference]State;                          
 var tmp11: bool;                                                                                   
 var AtomicMarkableReferenceResult._lock308965: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReference.mark308935: [AtomicMarkableReference]bool;                             
 var Data._lock308970: [Data]Tid;                                                                   
 var mover308672: Mover;                                                                            
 var AtomicMarkableReference._state308723: [AtomicMarkableReference]State;                          
 var $recorded.state308769: int;                                                                    
 var Data._lock308611: [Data]Tid;                                                                   
 var result2308947: AtomicMarkableReferenceResult;                                                  
 var AtomicMarkableReference.mark308611: [AtomicMarkableReference]bool;                             
 var Main._state308643_post: [Main]State;                                                           
 var AtomicMarkableReference._state308643_post: [AtomicMarkableReference]State;                     
 var result308723: AtomicMarkableReferenceResult;                                                   
 var Main._state308608: [Main]State;                                                                
 var d308947: Data;                                                                                 
 var tmp9308935: Data;                                                                              
 var tmp9308930: Data;                                                                              
 var AtomicMarkableReference._lock308720: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.nextWriter308982: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReferenceResult._lock308947: [AtomicMarkableReferenceResult]Tid;                 
 var tmp10308941: bool;                                                                             
 var this308643_post: Main;                                                                         
 var result2308935: AtomicMarkableReferenceResult;                                                  
 var Main._lock308672: [Main]Tid;                                                                   
 var result2308970: AtomicMarkableReferenceResult;                                                  
 var moverPath308763: MoverPath;                                                                    
 var x308608: AtomicMarkableReference;                                                              
 var AtomicMarkableReferenceResult._state308608: [AtomicMarkableReferenceResult]State;              
 var Main._state308723: [Main]State;                                                                
 var x308982: AtomicMarkableReference;                                                              
 var tmp$13308672: bool;                                                                            
 var $pc308643: Phase;                                                                              
 var AtomicMarkableReferenceResult._lock308560: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReference.ref308952: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReferenceResult.ref308672: [AtomicMarkableReferenceResult]Data;                  
 var AtomicMarkableReference.nextWriter308643_post: [AtomicMarkableReference]Tid;                   
 var tmp8308952: Data;                                                                              
 var $recorded.state308952: int;                                                                    
 var AtomicMarkableReference._lock308952: [AtomicMarkableReference]Tid;                             
 var this308935: Main;                                                                              
 var tmp11308947: bool;                                                                             
 var moverPath308769: MoverPath;                                                                    
 var Main._state308947: [Main]State;                                                                
 var AtomicMarkableReferenceResult.mark308947: [AtomicMarkableReferenceResult]bool;                 
 var tmp6308769: Data;                                                                              
 var Main._lock308643_post: [Main]Tid;                                                              
 var tid308970: Tid;                                                                                
 var this$11308560: AtomicMarkableReference;                                                        
 var AtomicMarkableReferenceResult.ref308935: [AtomicMarkableReferenceResult]Data;                  
 var result2308723: AtomicMarkableReferenceResult;                                                  
 var x308720: AtomicMarkableReference;                                                              
 var tmp4$11308608: Data;                                                                           
 var AtomicMarkableReferenceResult._state308970: [AtomicMarkableReferenceResult]State;              
 var result2308769: AtomicMarkableReferenceResult;                                                  
 var AtomicMarkableReference._state308982: [AtomicMarkableReference]State;                          
 var path308608: int;                                                                               
 var mark$15308868: bool;                                                                           
 var moverPath308720: MoverPath;                                                                    
 var AtomicMarkableReference.ref308970: [AtomicMarkableReference]Data;                              
 var $recorded.state308970: int;                                                                    
 var path308959: int;                                                                               
 var AtomicMarkableReferenceResult._lock308868: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReferenceResult.mark308763: [AtomicMarkableReferenceResult]bool;                 
 var AtomicMarkableReference.ref308672: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReference._lock308930: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReferenceResult._state308935: [AtomicMarkableReferenceResult]State;              
 var result$13308723: AtomicMarkableReferenceResult;                                                
 var tid308868: Tid;                                                                                
 var d308643_post: Data;                                                                            
 var AtomicMarkableReference._lock308941: [AtomicMarkableReference]Tid;                             
 var tmp$13308723: bool;                                                                            
 var tmp4$11308611: Data;                                                                           
 var tmp$11308611: bool;                                                                            
 var AtomicMarkableReferenceResult.mark308560: [AtomicMarkableReferenceResult]bool;                 
 var Data._lock308941: [Data]Tid;                                                                   
 var path308769: int;                                                                               
 var Main._lock308952: [Main]Tid;                                                                   
 var x308952: AtomicMarkableReference;                                                              
 var this308930: Main;                                                                              
 var AtomicMarkableReference.nextWriter308643: [AtomicMarkableReference]Tid;                        
 var tmp$15: bool;                                                                                  
 var moverPath308924: MoverPath;                                                                    
 var AtomicMarkableReferenceResult._lock308611: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReference.nextWriter308720: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReference.nextWriter308952: [AtomicMarkableReference]Tid;                        
 var path308941: int;                                                                               
 var x308769: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._state308672: [AtomicMarkableReference]State;                          
 var result308611: AtomicMarkableReferenceResult;                                                   
 var tid308763: Tid;                                                                                
 var AtomicMarkableReference.ref308959: [AtomicMarkableReference]Data;                              
 var tmp8: Data;                                                                                    
 var Data._state308930: [Data]State;                                                                
 var this308965: Main;                                                                              
 var b308935: bool;                                                                                 
 var AtomicMarkableReference.ref308930: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReferenceResult._state308930: [AtomicMarkableReferenceResult]State;              
 var AtomicMarkableReference.nextWriter308608: [AtomicMarkableReference]Tid;                        
 var Main._state308930: [Main]State;                                                                
 var Data._state308560: [Data]State;                                                                
 var AtomicMarkableReferenceResult.mark308952: [AtomicMarkableReferenceResult]bool;                 
 var $recorded.state308982: int;                                                                    
 var mover308608: Mover;                                                                            
 var $pc308947: Phase;                                                                              
 var Main._state308769: [Main]State;                                                                
 var AtomicMarkableReference._lock308723: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReferenceResult._lock308982: [AtomicMarkableReferenceResult]Tid;                 
 var Data._lock308924: [Data]Tid;                                                                   
 var AtomicMarkableReferenceResult.mark308608: [AtomicMarkableReferenceResult]bool;                 
 var $recorded.state308611: int;                                                                    
 var mover308930: Mover;                                                                            
 var Data._lock308643: [Data]Tid;                                                                   
 var moverPath308611: MoverPath;                                                                    
 var AtomicMarkableReference.mark308643_post: [AtomicMarkableReference]bool;                        
 var this308672: Main;                                                                              
 var AtomicMarkableReference._lock308560: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.mark308952: [AtomicMarkableReference]bool;                             
 var Main._lock308720: [Main]Tid;                                                                   
 var AtomicMarkableReference._lock308924: [AtomicMarkableReference]Tid;                             
 var Main._lock308959: [Main]Tid;                                                                   
 var Data._state308952: [Data]State;                                                                
 var AtomicMarkableReferenceResult.ref308952: [AtomicMarkableReferenceResult]Data;                  
 var b308959: bool;                                                                                 
 var tmp7308930: bool;                                                                              
 var path308868: int;                                                                               
 var result308952: AtomicMarkableReferenceResult;                                                   
 var AtomicMarkableReferenceResult._state308560: [AtomicMarkableReferenceResult]State;              
 var tmp4$11: Data;                                                                                 
 var AtomicMarkableReference.nextWriter308868: [AtomicMarkableReference]Tid;                        
 var tmp10: bool;                                                                                   
 var path308723: int;                                                                               
 var moverPath308941: MoverPath;                                                                    
 var mover308560: Mover;                                                                            
 var tmp6: Data;                                                                                    
 var this$15308868: AtomicMarkableReference;                                                        
 var tid308924: Tid;                                                                                
 var $recorded.state308959: int;                                                                    
 var tid308723: Tid;                                                                                
 var $recorded.state308608: int;                                                                    
 var AtomicMarkableReference._state308965: [AtomicMarkableReference]State;                          
 var path308924: int;                                                                               
 var this$11: AtomicMarkableReference;                                                              
 var Data._lock308935: [Data]Tid;                                                                   
 var tid308608: Tid;                                                                                
 var result2308930: AtomicMarkableReferenceResult;                                                  
 var tmp$13308720: bool;                                                                            
 var Main._lock308763: [Main]Tid;                                                                   
 var AtomicMarkableReferenceResult._state308763: [AtomicMarkableReferenceResult]State;              
 var result$11: AtomicMarkableReferenceResult;                                                      
 var AtomicMarkableReference.mark308643: [AtomicMarkableReference]bool;                             
 var tmp7308965: bool;                                                                              
 var Data._lock308560: [Data]Tid;                                                                   
 var Main._lock308930: [Main]Tid;                                                                   
 var x308947: AtomicMarkableReference;                                                              
 var tmp6308935: Data;                                                                              
 var d308965: Data;                                                                                 
 var Data._lock308608: [Data]Tid;                                                                   
 var x308965: AtomicMarkableReference;                                                              
 var Data._state308611: [Data]State;                                                                
 var AtomicMarkableReference.mark308720: [AtomicMarkableReference]bool;                             
 var result308982: AtomicMarkableReferenceResult;                                                   
 var tmp13: Data;                                                                                   
 var expectedRef$15: Data;                                                                          
 var $recorded.state308947: int;                                                                    
 var moverPath308930: MoverPath;                                                                    
 var x308643: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._state308947: [AtomicMarkableReference]State;                          
 var tmp$13: bool;                                                                                  
 var result308672: AtomicMarkableReferenceResult;                                                   
 var tmp7308982: bool;                                                                              
 var tid308643_post: Tid;                                                                           
 var tmp7: bool;                                                                                    
 var tmp6308930: Data;                                                                              
 var x308924: AtomicMarkableReference;                                                              
 var AtomicMarkableReferenceResult.ref308643_post: [AtomicMarkableReferenceResult]Data;             
 var AtomicMarkableReferenceResult._lock308643: [AtomicMarkableReferenceResult]Tid;                 
 var expectedRef$15308868: Data;                                                                    
 var this308611: Main;                                                                              
 var Data._lock308763: [Data]Tid;                                                                   
 var tmp6308959: Data;                                                                              
 var $pc308720: Phase;                                                                              
 var Data._state308959: [Data]State;                                                                
 var AtomicMarkableReference._lock308672: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.mark308947: [AtomicMarkableReference]bool;                             
 var tmp9308952: Data;                                                                              
 var mover308723: Mover;                                                                            
 var tmp13308970: Data;                                                                             
 var AtomicMarkableReferenceResult.mark308982: [AtomicMarkableReferenceResult]bool;                 
 var path308560: int;                                                                               
 var AtomicMarkableReferenceResult._lock308608: [AtomicMarkableReferenceResult]Tid;                 
 var Data._state308763: [Data]State;                                                                
 var d: Data;                                                                                       
 var result2308763: AtomicMarkableReferenceResult;                                                  
 var tmp4$13308723: Data;                                                                           
 var d308643: Data;                                                                                 
 var Data._lock308643_post: [Data]Tid;                                                              
 var b308930: bool;                                                                                 
 var AtomicMarkableReferenceResult.ref308965: [AtomicMarkableReferenceResult]Data;                  
 var tmp9308941: Data;                                                                              
 var AtomicMarkableReferenceResult.mark308935: [AtomicMarkableReferenceResult]bool;                 
 var mover308720: Mover;                                                                            
 var Main._state308868: [Main]State;                                                                
 var tid308959: Tid;                                                                                
 var x308672: AtomicMarkableReference;                                                              
 var AtomicMarkableReference._lock308947: [AtomicMarkableReference]Tid;                             
 var path308947: int;                                                                               
 var Data._lock308720: [Data]Tid;                                                                   
 var Data._lock308672: [Data]Tid;                                                                   
 var tmp$11308608: bool;                                                                            
 var tid308947: Tid;                                                                                
 var tmp9308947: Data;                                                                              
 var x308611: AtomicMarkableReference;                                                              
 var Main._lock308723: [Main]Tid;                                                                   
 var Main._state308959: [Main]State;                                                                
 var tmp4$13: Data;                                                                                 
 var Data._state308970: [Data]State;                                                                
 var result2308720: AtomicMarkableReferenceResult;                                                  
 var this$13308723: AtomicMarkableReference;                                                        
 var result308763: AtomicMarkableReferenceResult;                                                   
 var this308643: Main;                                                                              
 var tmp7308868: bool;                                                                              
 var AtomicMarkableReference.mark308970: [AtomicMarkableReference]bool;                             
 var b308924: bool;                                                                                 
 var Main._state308560: [Main]State;                                                                
 var AtomicMarkableReference.mark308723: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReference.mark308965: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReference.ref308763: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReferenceResult._lock308723: [AtomicMarkableReferenceResult]Tid;                 
 var Main._lock308935: [Main]Tid;                                                                   
 var Main._lock308608: [Main]Tid;                                                                   
 var d308930: Data;                                                                                 
 var moverPath308868: MoverPath;                                                                    
 var AtomicMarkableReference._lock308935: [AtomicMarkableReference]Tid;                             
 var Main._state308643: [Main]State;                                                                
 var AtomicMarkableReference._state308970: [AtomicMarkableReference]State;                          
 var Data._lock308723: [Data]Tid;                                                                   
 var Main._lock308965: [Main]Tid;                                                                   
 var path308763: int;                                                                               
 var newMark$15308868: bool;                                                                        
 var b308763: bool;                                                                                 
 var AtomicMarkableReference._lock308959: [AtomicMarkableReference]Tid;                             
 var $recorded.state308643: int;                                                                    
 var path308611: int;                                                                               
 var AtomicMarkableReference.ref308868: [AtomicMarkableReference]Data;                              
 var $recorded.state308941: int;                                                                    
 var d308672: Data;                                                                                 
 var tid308769: Tid;                                                                                
 var this308941: Main;                                                                              
 var AtomicMarkableReference.mark308672: [AtomicMarkableReference]bool;                             
 var tmp7308959: bool;                                                                              
 var AtomicMarkableReferenceResult._state308965: [AtomicMarkableReferenceResult]State;              
 var AtomicMarkableReferenceResult.ref308982: [AtomicMarkableReferenceResult]Data;                  
 var tid308935: Tid;                                                                                
 var result308941: AtomicMarkableReferenceResult;                                                   
 var AtomicMarkableReferenceResult.mark308611: [AtomicMarkableReferenceResult]bool;                 
 var AtomicMarkableReference.mark308608: [AtomicMarkableReference]bool;                             
 var d308763: Data;                                                                                 
 var $pc308763: Phase;                                                                              
 var moverPath308560: MoverPath;                                                                    
 var tmp9: Data;                                                                                    
 var AtomicMarkableReference.nextWriter308924: [AtomicMarkableReference]Tid;                        
 var d308769: Data;                                                                                 
 var tid308941: Tid;                                                                                
 var AtomicMarkableReference.mark308763: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReference.nextWriter308611: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReference.mark308982: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReferenceResult.ref308970: [AtomicMarkableReferenceResult]Data;                  
 var tmp5$11: bool;                                                                                 
 var AtomicMarkableReference._lock308643: [AtomicMarkableReference]Tid;                             
 var $pc308982: Phase;                                                                              
 var tmp5$13: bool;                                                                                 
 var $pc308723: Phase;                                                                              
 var Main._state308924: [Main]State;                                                                
 var b308941: bool;                                                                                 
 var AtomicMarkableReferenceResult.mark308959: [AtomicMarkableReferenceResult]bool;                 
 var tid308643: Tid;                                                                                
 var AtomicMarkableReferenceResult._state308959: [AtomicMarkableReferenceResult]State;              
 var d308560: Data;                                                                                 
 var tmp6308868: Data;                                                                              
 var tmp1$15308868: bool;                                                                           
 var AtomicMarkableReferenceResult.mark308723: [AtomicMarkableReferenceResult]bool;                 
 var result2308982: AtomicMarkableReferenceResult;                                                  
 var $pc308643_post: Phase;                                                                         
 var AtomicMarkableReference.mark308769: [AtomicMarkableReference]bool;                             
 var Data._state308608: [Data]State;                                                                
 var Data._state308965: [Data]State;                                                                
 var expectedMark$15: bool;                                                                         
 var AtomicMarkableReference._state308935: [AtomicMarkableReference]State;                          
 var mover308947: Mover;                                                                            
 var this$10: Data;                                                                                 
 var tmp2$15: bool;                                                                                 
 var $pc308965: Phase;                                                                              
 var AtomicMarkableReferenceResult.ref308608: [AtomicMarkableReferenceResult]Data;                  
 var AtomicMarkableReferenceResult.ref308868: [AtomicMarkableReferenceResult]Data;                  
 var result2308952: AtomicMarkableReferenceResult;                                                  
 var tmp2$15308868: bool;                                                                           
 var AtomicMarkableReference.mark308941: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReferenceResult.ref308924: [AtomicMarkableReferenceResult]Data;                  
 var AtomicMarkableReferenceResult.mark308930: [AtomicMarkableReferenceResult]bool;                 
 var AtomicMarkableReference._state308763: [AtomicMarkableReference]State;                          
 var newRef$15308868: Data;                                                                         
 var AtomicMarkableReferenceResult.mark308965: [AtomicMarkableReferenceResult]bool;                 
 var b308769: bool;                                                                                 
 var AtomicMarkableReference._state308868: [AtomicMarkableReference]State;                          
 var tmp8308924: Data;                                                                              
 var AtomicMarkableReference.nextWriter308672: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReferenceResult._lock308935: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReferenceResult._state308947: [AtomicMarkableReferenceResult]State;              
 var $recorded.state308930: int;                                                                    
 var tmp7308924: bool;                                                                              
 var Data._lock308982: [Data]Tid;                                                                   
 var d308723: Data;                                                                                 
 var x308723: AtomicMarkableReference;                                                              
 var tmp6308965: Data;                                                                              
 var x308941: AtomicMarkableReference;                                                              
 var Data._state308643_post: [Data]State;                                                           
 var b308952: bool;                                                                                 
 var result$11308608: AtomicMarkableReferenceResult;                                                
 var Main._lock308868: [Main]Tid;                                                                   
 var result308868: AtomicMarkableReferenceResult;                                                   
 var newMark$15: bool;                                                                              
 var AtomicMarkableReference.ref308643: [AtomicMarkableReference]Data;                              
 var AtomicMarkableReference._lock308965: [AtomicMarkableReference]Tid;                             
 var AtomicMarkableReference.mark308560: [AtomicMarkableReference]bool;                             
 var tmp6308970: Data;                                                                              
 var result2308941: AtomicMarkableReferenceResult;                                                  
 var AtomicMarkableReference.mark308868: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReference.mark308930: [AtomicMarkableReference]bool;                             
 var AtomicMarkableReference.nextWriter308723: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReferenceResult.ref308723: [AtomicMarkableReferenceResult]Data;                  
 var $pc308560: Phase;                                                                              
 var x308643_post: AtomicMarkableReference;                                                         
 var d308924: Data;                                                                                 
 var Main._state308763: [Main]State;                                                                
 var result308970: AtomicMarkableReferenceResult;                                                   
 var result2: AtomicMarkableReferenceResult;                                                        
 var AtomicMarkableReferenceResult.ref308769: [AtomicMarkableReferenceResult]Data;                  
 var Main._state308982: [Main]State;                                                                
 var AtomicMarkableReference._state308608: [AtomicMarkableReference]State;                          
 var result2308924: AtomicMarkableReferenceResult;                                                  
 var this$9: AtomicMarkableReference;                                                               
 var Data._lock308868: [Data]Tid;                                                                   
 var AtomicMarkableReference.nextWriter308965: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReferenceResult.mark308941: [AtomicMarkableReferenceResult]bool;                 
 var AtomicMarkableReference._state308959: [AtomicMarkableReference]State;                          
 var Data._lock308769: [Data]Tid;                                                                   
 var this$15: AtomicMarkableReference;                                                              
 var $recorded.state308924: int;                                                                    
 var Main._lock308611: [Main]Tid;                                                                   
 var Main._lock308982: [Main]Tid;                                                                   
 var AtomicMarkableReference._state308611: [AtomicMarkableReference]State;                          
 var AtomicMarkableReference.nextWriter308970: [AtomicMarkableReference]Tid;                        
 var AtomicMarkableReference._state308769: [AtomicMarkableReference]State;                          
 var tmp$11308560: bool;                                                                            
 var this$14: AtomicMarkableReferenceResult;                                                        
 var path308965: int;                                                                               
 var path308720: int;                                                                               
 var $recorded.state308643_post: int;                                                               
 var Main._state308672: [Main]State;                                                                
 var this$13308720: AtomicMarkableReference;                                                        
 var $pc308959: Phase;                                                                              
 var AtomicMarkableReferenceResult._state308952: [AtomicMarkableReferenceResult]State;              
 var x308935: AtomicMarkableReference;                                                              
 var Data._lock308959: [Data]Tid;                                                                   
 var result2308868: AtomicMarkableReferenceResult;                                                  
 var AtomicMarkableReferenceResult.ref308560: [AtomicMarkableReferenceResult]Data;                  
 var d308935: Data;                                                                                 
 var AtomicMarkableReferenceResult._lock308941: [AtomicMarkableReferenceResult]Tid;                 
 var AtomicMarkableReference.ref308941: [AtomicMarkableReference]Data;                              
 var tid308930: Tid;                                                                                
 var this308970: Main;                                                                              
 var AtomicMarkableReferenceResult.mark308868: [AtomicMarkableReferenceResult]bool;                 
 var x308930: AtomicMarkableReference;                                                              
 var AtomicMarkableReferenceResult._state308720: [AtomicMarkableReferenceResult]State;              
 var result308769: AtomicMarkableReferenceResult;                                                   
 var result2308965: AtomicMarkableReferenceResult;                                                  
 var tmp4$13308720: Data;                                                                           
 var AtomicMarkableReferenceResult._lock308720: [AtomicMarkableReferenceResult]Tid;                 
 var tmp8308930: Data;                                                                              
 var tmp7308970: bool;                                                                              
 var tmp6308952: Data;                                                                              
 var tmp6308947: Data;                                                                              
 var b: bool;                                                                                       
 var result308720: AtomicMarkableReferenceResult;                                                   
 var result308959: AtomicMarkableReferenceResult;                                                   
 var Data._state308723: [Data]State;                                                                
 var b308982: bool;                                                                                 
 var Main._lock308643: [Main]Tid;                                                                   
 var d308941: Data;                                                                                 
 var AtomicMarkableReference._lock308970: [AtomicMarkableReference]Tid;                             
                                                                                                    
 var $pc : Phase;                                                                                   
 $pc := PreCommit;                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 // 83.7: AtomicMarkableReference x;                                                                
                                                                                                    
                                                                                                    
 // 83.7: x = new AtomicMarkableReference();                                                        
                                                                                                    
 havoc x;                                                                                           
 assume x != AtomicMarkableReference.null && isFresh(AtomicMarkableReference._state[x]);            
 AtomicMarkableReference._state[x] := LOCAL(tid);                                                   
 assume AtomicMarkableReference.ref[x]  == Data.null;                                               
 assume AtomicMarkableReference.mark[x]  == false;                                                  
 assume AtomicMarkableReference.nextWriter[x]  == Tid.null;                                         
 assume AtomicMarkableReference._lock[x]  == Tid.null;                                              
 // inlined: x.init()}                                                                              
 exit$9_top:                                                                                        
                                                                                                    
 // 83.7: AtomicMarkableReference this$9;                                                           
                                                                                                    
                                                                                                    
 // 83.7: this$9 = x;                                                                               
                                                                                                    
 this$9 := x;                                                                                       
                                                                                                    
 // 13.31: assume this$9.ref == Data.null;                                                          
                                                                                                    
 assume (AtomicMarkableReference.ref[this$9]==Data.null);                                           
                                                                                                    
 // 13.31: assume this$9.mark == false;                                                             
                                                                                                    
 assume (AtomicMarkableReference.mark[this$9]==false);                                              
                                                                                                    
 // 13.31: assume this$9.nextWriter == Tid.null;                                                    
                                                                                                    
 assume (AtomicMarkableReference.nextWriter[this$9]==Tid.null);                                     
                                                                                                    
 // 76.1: break exit$9;                                                                             
                                                                                                    
 goto exit$9_bottom;                                                                                
 exit$9_bottom:                                                                                     
                                                                                                    
 // 84.7: Data d;                                                                                   
                                                                                                    
                                                                                                    
 // 84.7: d = new Data();                                                                           
                                                                                                    
 havoc d;                                                                                           
 assume d != Data.null && isFresh(Data._state[d]);                                                  
 Data._state[d] := LOCAL(tid);                                                                      
 assume Data._lock[d]  == Tid.null;                                                                 
 // inlined: d.init()}                                                                              
 exit$10_top:                                                                                       
                                                                                                    
 // 84.7: Data this$10;                                                                             
                                                                                                    
                                                                                                    
 // 84.7: this$10 = d;                                                                              
                                                                                                    
 this$10 := d;                                                                                      
                                                                                                    
 // 4.1: break exit$10;                                                                             
                                                                                                    
 goto exit$10_bottom;                                                                               
 exit$10_bottom:                                                                                    
                                                                                                    
 // 85.7: AtomicMarkableReferenceResult result;                                                     
                                                                                                    
 // inlined: x.get()}                                                                               
 exit$11_top:                                                                                       
                                                                                                    
 // 85.7: AtomicMarkableReference this$11;                                                          
                                                                                                    
                                                                                                    
 // 85.7: this$11 = x;                                                                              
                                                                                                    
 this$11 := x;                                                                                      
                                                                                                    
 // 65.5: boolean tmp$11;                                                                           
                                                                                                    
                                                                                                    
 // 65.5: tmp$11 = *;                                                                               
                                                                                                    
 havoc tmp$11;                                                                                      
 if (tmp$11 /* lowered tmp$11 */) {                                                                 
                                                                                                    
  // 67.7: assume this$11.nextWriter == Tid.null;                                                   
                                                                                                    
  assume (AtomicMarkableReference.nextWriter[this$11]==Tid.null);                                   
                                                                                                    
                                                                                                    
  // 68.7: this$11.nextWriter := tid;                                                               
                                                                                                    
                                                                                                    
  moverPath308560 := WriteEval.AtomicMarkableReference.nextWriter(tid: Tid,this$11: AtomicMarkableReference,tid: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308560 := m#moverPath(moverPath308560);                                                      
  path308560 := p#moverPath(moverPath308560);                                                       
  assume Data._state308560 == Data._state && Data._lock308560 == Data._lock && AtomicMarkableReferenceResult._state308560 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308560 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308560 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308560 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308560 == AtomicMarkableReference._state && AtomicMarkableReference.ref308560 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308560 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308560 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308560 == AtomicMarkableReference._lock && Main._state308560 == Main._state && Main._lock308560 == Main._lock && tmp$11308560 == tmp$11 && this$11308560 == this$11 && result308560 == result && d308560 == d && x308560 == x && this308560 == this && tid308560 == tid && $pc308560 == $pc;
  assume $recorded.state308560 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$11 != AtomicMarkableReference.null;                                                  
  } else {                                                                                          
   assert this$11 != AtomicMarkableReference.null;                                                         // (68.7): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover308560);                                                              
  assert $pc != PhaseError;                                                                                // (68.7): Reduction failure
  AtomicMarkableReference.nextWriter[this$11] := tid;                                               
 } else {                                                                                           
 }                                                                                                  
                                                                                                    
 // 70.5: AtomicMarkableReferenceResult result$11;                                                  
                                                                                                    
                                                                                                    
 // 70.5: result$11 = new AtomicMarkableReferenceResult();                                          
                                                                                                    
 havoc result$11;                                                                                   
 assume result$11 != AtomicMarkableReferenceResult.null && isFresh(AtomicMarkableReferenceResult._state[result$11]);
 AtomicMarkableReferenceResult._state[result$11] := LOCAL(tid);                                     
 assume AtomicMarkableReferenceResult.ref[result$11]  == Data.null;                                 
 assume AtomicMarkableReferenceResult.mark[result$11]  == false;                                    
 assume AtomicMarkableReferenceResult._lock[result$11]  == Tid.null;                                
 // inlined: result$11.init()}                                                                      
 exit$12_top:                                                                                       
                                                                                                    
 // 70.5: AtomicMarkableReferenceResult this$12;                                                    
                                                                                                    
                                                                                                    
 // 70.5: this$12 = result$11;                                                                      
                                                                                                    
 this$12 := result$11;                                                                              
                                                                                                    
 // 6.37: assume this$12.ref == Data.null;                                                          
                                                                                                    
 assume (AtomicMarkableReferenceResult.ref[this$12]==Data.null);                                    
                                                                                                    
 // 6.37: assume this$12.mark == false;                                                             
                                                                                                    
 assume (AtomicMarkableReferenceResult.mark[this$12]==false);                                       
                                                                                                    
 // 9.1: break exit$12;                                                                             
                                                                                                    
 goto exit$12_bottom;                                                                               
 exit$12_bottom:                                                                                    
                                                                                                    
 // 71.5: Data tmp4$11;                                                                             
                                                                                                    
                                                                                                    
 // 71.5: tmp4$11 := this$11.ref;                                                                   
                                                                                                    
                                                                                                    
 moverPath308608 := ReadEval.AtomicMarkableReference.ref(tid: Tid,this$11: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 mover308608 := m#moverPath(moverPath308608);                                                       
 path308608 := p#moverPath(moverPath308608);                                                        
 assume Data._state308608 == Data._state && Data._lock308608 == Data._lock && AtomicMarkableReferenceResult._state308608 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308608 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308608 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308608 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308608 == AtomicMarkableReference._state && AtomicMarkableReference.ref308608 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308608 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308608 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308608 == AtomicMarkableReference._lock && Main._state308608 == Main._state && Main._lock308608 == Main._lock && tmp4$11308608 == tmp4$11 && result$11308608 == result$11 && tmp$11308608 == tmp$11 && this$11308608 == this$11 && result308608 == result && d308608 == d && x308608 == x && this308608 == this && tid308608 == tid && $pc308608 == $pc;
 assume $recorded.state308608 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$11 != AtomicMarkableReference.null;                                                   
 } else {                                                                                           
  assert this$11 != AtomicMarkableReference.null;                                                          // (71.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover308608);                                                               
 assert $pc != PhaseError;                                                                                 // (71.5): Reduction failure
 tmp4$11 := AtomicMarkableReference.ref[this$11];                                                   
                                                                                                    
                                                                                                    
 // 71.5: result$11.ref := tmp4$11;                                                                 
                                                                                                    
                                                                                                    
 moverPath308611 := WriteEval.AtomicMarkableReferenceResult.ref(tid: Tid,result$11: AtomicMarkableReferenceResult,tmp4$11: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 mover308611 := m#moverPath(moverPath308611);                                                       
 path308611 := p#moverPath(moverPath308611);                                                        
 assume Data._state308611 == Data._state && Data._lock308611 == Data._lock && AtomicMarkableReferenceResult._state308611 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308611 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308611 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308611 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308611 == AtomicMarkableReference._state && AtomicMarkableReference.ref308611 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308611 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308611 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308611 == AtomicMarkableReference._lock && Main._state308611 == Main._state && Main._lock308611 == Main._lock && tmp4$11308611 == tmp4$11 && result$11308611 == result$11 && tmp$11308611 == tmp$11 && this$11308611 == this$11 && result308611 == result && d308611 == d && x308611 == x && this308611 == this && tid308611 == tid && $pc308611 == $pc;
 assume $recorded.state308611 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume result$11 != AtomicMarkableReferenceResult.null;                                           
 } else {                                                                                           
  assert result$11 != AtomicMarkableReferenceResult.null;                                                  // (71.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover308611);                                                               
 assert $pc != PhaseError;                                                                                 // (71.5): Reduction failure
 AtomicMarkableReferenceResult.ref[result$11] := tmp4$11;                                           
 if (isLocal(Data._state[tmp4$11], tid)) {                                                          
  Data._state[tmp4$11] := SHARED();                                                                 
 }                                                                                                  
                                                                                                    
 // nocheck {                                                                                       
                                                                                                    
                                                                                                    
  // 72.13: boolean tmp5$11;                                                                        
                                                                                                    
                                                                                                    
  // 72.13: tmp5$11 := this$11.mark;                                                                
                                                                                                    
                                                                                                    
  assume this$11 != AtomicMarkableReference.null;                                                   
                                                                                                    
  tmp5$11 := AtomicMarkableReference.mark[this$11];                                                 
                                                                                                    
                                                                                                    
  // 72.13: result$11.mark := tmp5$11;                                                              
                                                                                                    
                                                                                                    
  assume result$11 != AtomicMarkableReferenceResult.null;                                           
  AtomicMarkableReferenceResult.mark[result$11] := tmp5$11;                                         
                                                                                                    
 // }                                                                                               
                                                                                                    
 // 73.5: result = result$11;                                                                       
                                                                                                    
 result := result$11;                                                                               
                                                                                                    
 // 73.5: break exit$11;                                                                            
                                                                                                    
 goto exit$11_bottom;                                                                               
                                                                                                    
 // 64.39: result = AtomicMarkableReferenceResult.null;                                             
                                                                                                    
 result := AtomicMarkableReferenceResult.null;                                                      
                                                                                                    
 // 64.39: break exit$11;                                                                           
                                                                                                    
 goto exit$11_bottom;                                                                               
 exit$11_bottom:                                                                                    
                                                                                                    
 // 86.7: yield;                                                                                    
                                                                                                    
 assume Data._state308643 == Data._state && Data._lock308643 == Data._lock && AtomicMarkableReferenceResult._state308643 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308643 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308643 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308643 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308643 == AtomicMarkableReference._state && AtomicMarkableReference.ref308643 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308643 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308643 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308643 == AtomicMarkableReference._lock && Main._state308643 == Main._state && Main._lock308643 == Main._lock && result308643 == result && d308643 == d && x308643 == x && this308643 == this && tid308643 == tid;
 assume $recorded.state308643 == 1;                                                                 
 call Yield(tid);                                                                                   
 $pc := PreCommit;                                                                                  
 assume Data._state308643_post == Data._state && Data._lock308643_post == Data._lock && AtomicMarkableReferenceResult._state308643_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308643_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308643_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308643_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308643_post == AtomicMarkableReference._state && AtomicMarkableReference.ref308643_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark308643_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308643_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308643_post == AtomicMarkableReference._lock && Main._state308643_post == Main._state && Main._lock308643_post == Main._lock && result308643_post == result && d308643_post == d && x308643_post == x && this308643_post == this && tid308643_post == tid;
 assume $recorded.state308643_post == 1;                                                            
                                                                                                    
 // 87.7: AtomicMarkableReferenceResult result2;                                                    
                                                                                                    
 // inlined: x.get()}                                                                               
 exit$13_top:                                                                                       
                                                                                                    
 // 87.7: AtomicMarkableReference this$13;                                                          
                                                                                                    
                                                                                                    
 // 87.7: this$13 = x;                                                                              
                                                                                                    
 this$13 := x;                                                                                      
                                                                                                    
 // 65.5: boolean tmp$13;                                                                           
                                                                                                    
                                                                                                    
 // 65.5: tmp$13 = *;                                                                               
                                                                                                    
 havoc tmp$13;                                                                                      
 if (tmp$13 /* lowered tmp$13 */) {                                                                 
                                                                                                    
  // 67.7: assume this$13.nextWriter == Tid.null;                                                   
                                                                                                    
  assume (AtomicMarkableReference.nextWriter[this$13]==Tid.null);                                   
                                                                                                    
                                                                                                    
  // 68.7: this$13.nextWriter := tid;                                                               
                                                                                                    
                                                                                                    
  moverPath308672 := WriteEval.AtomicMarkableReference.nextWriter(tid: Tid,this$13: AtomicMarkableReference,tid: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308672 := m#moverPath(moverPath308672);                                                      
  path308672 := p#moverPath(moverPath308672);                                                       
  assume Data._state308672 == Data._state && Data._lock308672 == Data._lock && AtomicMarkableReferenceResult._state308672 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308672 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308672 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308672 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308672 == AtomicMarkableReference._state && AtomicMarkableReference.ref308672 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308672 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308672 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308672 == AtomicMarkableReference._lock && Main._state308672 == Main._state && Main._lock308672 == Main._lock && tmp$13308672 == tmp$13 && this$13308672 == this$13 && result2308672 == result2 && result308672 == result && d308672 == d && x308672 == x && this308672 == this && tid308672 == tid && $pc308672 == $pc;
  assume $recorded.state308672 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume this$13 != AtomicMarkableReference.null;                                                  
  } else {                                                                                          
   assert this$13 != AtomicMarkableReference.null;                                                         // (68.7): Cannot have potential null deference in left-mover part.
  }                                                                                                 
  $pc := transition($pc, mover308672);                                                              
  assert $pc != PhaseError;                                                                                // (68.7): Reduction failure
  AtomicMarkableReference.nextWriter[this$13] := tid;                                               
 } else {                                                                                           
 }                                                                                                  
                                                                                                    
 // 70.5: AtomicMarkableReferenceResult result$13;                                                  
                                                                                                    
                                                                                                    
 // 70.5: result$13 = new AtomicMarkableReferenceResult();                                          
                                                                                                    
 havoc result$13;                                                                                   
 assume result$13 != AtomicMarkableReferenceResult.null && isFresh(AtomicMarkableReferenceResult._state[result$13]);
 AtomicMarkableReferenceResult._state[result$13] := LOCAL(tid);                                     
 assume AtomicMarkableReferenceResult.ref[result$13]  == Data.null;                                 
 assume AtomicMarkableReferenceResult.mark[result$13]  == false;                                    
 assume AtomicMarkableReferenceResult._lock[result$13]  == Tid.null;                                
 // inlined: result$13.init()}                                                                      
 exit$14_top:                                                                                       
                                                                                                    
 // 70.5: AtomicMarkableReferenceResult this$14;                                                    
                                                                                                    
                                                                                                    
 // 70.5: this$14 = result$13;                                                                      
                                                                                                    
 this$14 := result$13;                                                                              
                                                                                                    
 // 6.37: assume this$14.ref == Data.null;                                                          
                                                                                                    
 assume (AtomicMarkableReferenceResult.ref[this$14]==Data.null);                                    
                                                                                                    
 // 6.37: assume this$14.mark == false;                                                             
                                                                                                    
 assume (AtomicMarkableReferenceResult.mark[this$14]==false);                                       
                                                                                                    
 // 9.1: break exit$14;                                                                             
                                                                                                    
 goto exit$14_bottom;                                                                               
 exit$14_bottom:                                                                                    
                                                                                                    
 // 71.5: Data tmp4$13;                                                                             
                                                                                                    
                                                                                                    
 // 71.5: tmp4$13 := this$13.ref;                                                                   
                                                                                                    
                                                                                                    
 moverPath308720 := ReadEval.AtomicMarkableReference.ref(tid: Tid,this$13: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 mover308720 := m#moverPath(moverPath308720);                                                       
 path308720 := p#moverPath(moverPath308720);                                                        
 assume Data._state308720 == Data._state && Data._lock308720 == Data._lock && AtomicMarkableReferenceResult._state308720 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308720 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308720 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308720 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308720 == AtomicMarkableReference._state && AtomicMarkableReference.ref308720 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308720 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308720 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308720 == AtomicMarkableReference._lock && Main._state308720 == Main._state && Main._lock308720 == Main._lock && tmp4$13308720 == tmp4$13 && result$13308720 == result$13 && tmp$13308720 == tmp$13 && this$13308720 == this$13 && result2308720 == result2 && result308720 == result && d308720 == d && x308720 == x && this308720 == this && tid308720 == tid && $pc308720 == $pc;
 assume $recorded.state308720 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume this$13 != AtomicMarkableReference.null;                                                   
 } else {                                                                                           
  assert this$13 != AtomicMarkableReference.null;                                                          // (71.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover308720);                                                               
 assert $pc != PhaseError;                                                                                 // (71.5): Reduction failure
 tmp4$13 := AtomicMarkableReference.ref[this$13];                                                   
                                                                                                    
                                                                                                    
 // 71.5: result$13.ref := tmp4$13;                                                                 
                                                                                                    
                                                                                                    
 moverPath308723 := WriteEval.AtomicMarkableReferenceResult.ref(tid: Tid,result$13: AtomicMarkableReferenceResult,tmp4$13: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 mover308723 := m#moverPath(moverPath308723);                                                       
 path308723 := p#moverPath(moverPath308723);                                                        
 assume Data._state308723 == Data._state && Data._lock308723 == Data._lock && AtomicMarkableReferenceResult._state308723 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308723 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308723 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308723 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308723 == AtomicMarkableReference._state && AtomicMarkableReference.ref308723 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308723 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308723 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308723 == AtomicMarkableReference._lock && Main._state308723 == Main._state && Main._lock308723 == Main._lock && tmp4$13308723 == tmp4$13 && result$13308723 == result$13 && tmp$13308723 == tmp$13 && this$13308723 == this$13 && result2308723 == result2 && result308723 == result && d308723 == d && x308723 == x && this308723 == this && tid308723 == tid && $pc308723 == $pc;
 assume $recorded.state308723 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume result$13 != AtomicMarkableReferenceResult.null;                                           
 } else {                                                                                           
  assert result$13 != AtomicMarkableReferenceResult.null;                                                  // (71.5): Cannot have potential null deference in left-mover part.
 }                                                                                                  
 $pc := transition($pc, mover308723);                                                               
 assert $pc != PhaseError;                                                                                 // (71.5): Reduction failure
 AtomicMarkableReferenceResult.ref[result$13] := tmp4$13;                                           
 if (isLocal(Data._state[tmp4$13], tid)) {                                                          
  Data._state[tmp4$13] := SHARED();                                                                 
 }                                                                                                  
                                                                                                    
 // nocheck {                                                                                       
                                                                                                    
                                                                                                    
  // 72.13: boolean tmp5$13;                                                                        
                                                                                                    
                                                                                                    
  // 72.13: tmp5$13 := this$13.mark;                                                                
                                                                                                    
                                                                                                    
  assume this$13 != AtomicMarkableReference.null;                                                   
                                                                                                    
  tmp5$13 := AtomicMarkableReference.mark[this$13];                                                 
                                                                                                    
                                                                                                    
  // 72.13: result$13.mark := tmp5$13;                                                              
                                                                                                    
                                                                                                    
  assume result$13 != AtomicMarkableReferenceResult.null;                                           
  AtomicMarkableReferenceResult.mark[result$13] := tmp5$13;                                         
                                                                                                    
 // }                                                                                               
                                                                                                    
 // 73.5: result2 = result$13;                                                                      
                                                                                                    
 result2 := result$13;                                                                              
                                                                                                    
 // 73.5: break exit$13;                                                                            
                                                                                                    
 goto exit$13_bottom;                                                                               
                                                                                                    
 // 64.39: result2 = AtomicMarkableReferenceResult.null;                                            
                                                                                                    
 result2 := AtomicMarkableReferenceResult.null;                                                     
                                                                                                    
 // 64.39: break exit$13;                                                                           
                                                                                                    
 goto exit$13_bottom;                                                                               
 exit$13_bottom:                                                                                    
                                                                                                    
 // 88.7: boolean b;                                                                                
                                                                                                    
                                                                                                    
 // 88.7: Data tmp6;                                                                                
                                                                                                    
                                                                                                    
 // 88.7: tmp6 := result.ref;                                                                       
                                                                                                    
                                                                                                    
 moverPath308763 := ReadEval.AtomicMarkableReferenceResult.ref(tid: Tid,result: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 mover308763 := m#moverPath(moverPath308763);                                                       
 path308763 := p#moverPath(moverPath308763);                                                        
 assume Data._state308763 == Data._state && Data._lock308763 == Data._lock && AtomicMarkableReferenceResult._state308763 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308763 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308763 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308763 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308763 == AtomicMarkableReference._state && AtomicMarkableReference.ref308763 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308763 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308763 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308763 == AtomicMarkableReference._lock && Main._state308763 == Main._state && Main._lock308763 == Main._lock && tmp6308763 == tmp6 && b308763 == b && result2308763 == result2 && result308763 == result && d308763 == d && x308763 == x && this308763 == this && tid308763 == tid && $pc308763 == $pc;
 assume $recorded.state308763 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume result != AtomicMarkableReferenceResult.null;                                              
 } else {                                                                                           
  assert result != AtomicMarkableReferenceResult.null;                                                     // (88.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover308763);                                                               
 assert $pc != PhaseError;                                                                                 // (88.7): Reduction failure
 tmp6 := AtomicMarkableReferenceResult.ref[result];                                                 
                                                                                                    
 // 88.7: boolean tmp7;                                                                             
                                                                                                    
                                                                                                    
 // 88.7: tmp7 := result.mark;                                                                      
                                                                                                    
                                                                                                    
 moverPath308769 := ReadEval.AtomicMarkableReferenceResult.mark(tid: Tid,result: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 mover308769 := m#moverPath(moverPath308769);                                                       
 path308769 := p#moverPath(moverPath308769);                                                        
 assume Data._state308769 == Data._state && Data._lock308769 == Data._lock && AtomicMarkableReferenceResult._state308769 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308769 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308769 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308769 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308769 == AtomicMarkableReference._state && AtomicMarkableReference.ref308769 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308769 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308769 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308769 == AtomicMarkableReference._lock && Main._state308769 == Main._state && Main._lock308769 == Main._lock && tmp7308769 == tmp7 && tmp6308769 == tmp6 && b308769 == b && result2308769 == result2 && result308769 == result && d308769 == d && x308769 == x && this308769 == this && tid308769 == tid && $pc308769 == $pc;
 assume $recorded.state308769 == 1;                                                                 
 if ($pc == PreCommit) {                                                                            
  assume result != AtomicMarkableReferenceResult.null;                                              
 } else {                                                                                           
  assert result != AtomicMarkableReferenceResult.null;                                                     // (88.7): Cannot have potential null deference in left-mover part.
 }                                                                                                  
                                                                                                    
 $pc := transition($pc, mover308769);                                                               
 assert $pc != PhaseError;                                                                                 // (88.7): Reduction failure
 tmp7 := AtomicMarkableReferenceResult.mark[result];                                                
 // inlined: x.cas2(tmp6,Data.null,tmp7,true)}                                                      
 exit$15_top:                                                                                       
                                                                                                    
 // 88.7: Data expectedRef$15;                                                                      
                                                                                                    
                                                                                                    
 // 88.7: Data newRef$15;                                                                           
                                                                                                    
                                                                                                    
 // 88.7: boolean expectedMark$15;                                                                  
                                                                                                    
                                                                                                    
 // 88.7: boolean newMark$15;                                                                       
                                                                                                    
                                                                                                    
 // 88.7: AtomicMarkableReference this$15;                                                          
                                                                                                    
                                                                                                    
 // 88.7: expectedRef$15 = tmp6;                                                                    
                                                                                                    
 expectedRef$15 := tmp6;                                                                            
                                                                                                    
 // 88.7: newRef$15 = Data.null;                                                                    
                                                                                                    
 newRef$15 := Data.null;                                                                            
                                                                                                    
 // 88.7: expectedMark$15 = tmp7;                                                                   
                                                                                                    
 expectedMark$15 := tmp7;                                                                           
                                                                                                    
 // 88.7: newMark$15 = true;                                                                        
                                                                                                    
 newMark$15 := true;                                                                                
                                                                                                    
 // 88.7: this$15 = x;                                                                              
                                                                                                    
 this$15 := x;                                                                                      
                                                                                                    
 // 25.7: boolean tmp$15;                                                                           
                                                                                                    
                                                                                                    
 // 25.7: tmp$15 = *;                                                                               
                                                                                                    
 havoc tmp$15;                                                                                      
 if (tmp$15 /* lowered tmp$15 */) {                                                                 
                                                                                                    
  // 27.8: assume this$15.nextWriter == tid;                                                        
                                                                                                    
  assume (AtomicMarkableReference.nextWriter[this$15]==tid);                                        
                                                                                                    
  // 28.8: Data ref$15;                                                                             
                                                                                                    
                                                                                                    
  // 29.8: boolean mark$15;                                                                         
                                                                                                    
  // nocheck {                                                                                      
                                                                                                    
                                                                                                    
   // 30.16: ref$15 := this$15.ref;                                                                 
                                                                                                    
                                                                                                    
   assume this$15 != AtomicMarkableReference.null;                                                  
                                                                                                    
   ref$15 := AtomicMarkableReference.ref[this$15];                                                  
                                                                                                    
  // }                                                                                              
  // nocheck {                                                                                      
                                                                                                    
                                                                                                    
   // 31.16: mark$15 := this$15.mark;                                                               
                                                                                                    
                                                                                                    
   assume this$15 != AtomicMarkableReference.null;                                                  
                                                                                                    
   mark$15 := AtomicMarkableReference.mark[this$15];                                                
                                                                                                    
  // }                                                                                              
                                                                                                    
  // 32.8: boolean tmp1$15;                                                                         
                                                                                                    
                                                                                                    
  // 32.8: boolean tmp2$15;                                                                         
                                                                                                    
                                                                                                    
  // 32.8: tmp2$15 = ref$15 == expectedRef$15;                                                      
                                                                                                    
  tmp2$15 := (ref$15==expectedRef$15);                                                              
  if (tmp2$15) {                                                                                    
                                                                                                    
   // 32.39: tmp1$15 = mark$15 == expectedMark$15;                                                  
                                                                                                    
   tmp1$15 := (mark$15==expectedMark$15);                                                           
  } else {                                                                                          
                                                                                                    
   // <undefined position>: tmp1$15 = false;                                                        
                                                                                                    
   tmp1$15 := false;                                                                                
  }                                                                                                 
  if (tmp1$15 /* lowered ((ref$15==expectedRef$15)&&(mark$15==expectedMark$15)) */) {               
                                                                                                    
                                                                                                    
   // 33.9: this$15.ref := newRef$15;                                                               
                                                                                                    
                                                                                                    
   moverPath308868 := WriteEval.AtomicMarkableReference.ref(tid: Tid,this$15: AtomicMarkableReference,newRef$15: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
   mover308868 := m#moverPath(moverPath308868);                                                     
   path308868 := p#moverPath(moverPath308868);                                                      
   assume Data._state308868 == Data._state && Data._lock308868 == Data._lock && AtomicMarkableReferenceResult._state308868 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308868 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308868 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308868 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308868 == AtomicMarkableReference._state && AtomicMarkableReference.ref308868 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308868 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308868 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308868 == AtomicMarkableReference._lock && Main._state308868 == Main._state && Main._lock308868 == Main._lock && tmp2$15308868 == tmp2$15 && tmp1$15308868 == tmp1$15 && mark$15308868 == mark$15 && ref$15308868 == ref$15 && tmp$15308868 == tmp$15 && this$15308868 == this$15 && newMark$15308868 == newMark$15 && expectedMark$15308868 == expectedMark$15 && newRef$15308868 == newRef$15 && expectedRef$15308868 == expectedRef$15 && tmp7308868 == tmp7 && tmp6308868 == tmp6 && b308868 == b && result2308868 == result2 && result308868 == result && d308868 == d && x308868 == x && this308868 == this && tid308868 == tid && $pc308868 == $pc;
   assume $recorded.state308868 == 1;                                                               
   if ($pc == PreCommit) {                                                                          
    assume this$15 != AtomicMarkableReference.null;                                                 
   } else {                                                                                         
    assert this$15 != AtomicMarkableReference.null;                                                        // (33.9): Cannot have potential null deference in left-mover part.
   }                                                                                                
   $pc := transition($pc, mover308868);                                                             
   assert $pc != PhaseError;                                                                               // (33.9): Reduction failure
   AtomicMarkableReference.ref[this$15] := newRef$15;                                               
   if (isLocal(Data._state[newRef$15], tid)) {                                                      
    Data._state[newRef$15] := SHARED();                                                             
   }                                                                                                
                                                                                                    
   // nocheck {                                                                                     
                                                                                                    
                                                                                                    
                                                                                                    
    // 34.17: this$15.mark := newMark$15;                                                           
                                                                                                    
                                                                                                    
    assume this$15 != AtomicMarkableReference.null;                                                 
    AtomicMarkableReference.mark[this$15] := newMark$15;                                            
                                                                                                    
   // }                                                                                             
                                                                                                    
   // 35.9: b = true;                                                                               
                                                                                                    
   b := true;                                                                                       
                                                                                                    
   // 35.9: break exit$15;                                                                          
                                                                                                    
   goto exit$15_bottom;                                                                             
  } else {                                                                                          
                                                                                                    
   // 37.9: b = false;                                                                              
                                                                                                    
   b := false;                                                                                      
                                                                                                    
   // 37.9: break exit$15;                                                                          
                                                                                                    
   goto exit$15_bottom;                                                                             
  }                                                                                                 
 } else {                                                                                           
                                                                                                    
  // 40.8: b = false;                                                                               
                                                                                                    
  b := false;                                                                                       
                                                                                                    
  // 40.8: break exit$15;                                                                           
                                                                                                    
  goto exit$15_bottom;                                                                              
 }                                                                                                  
                                                                                                    
 // 24.86: b = false;                                                                               
                                                                                                    
 b := false;                                                                                        
                                                                                                    
 // 24.86: break exit$15;                                                                           
                                                                                                    
 goto exit$15_bottom;                                                                               
 exit$15_bottom:                                                                                    
 if (b /* lowered b */) {                                                                           
                                                                                                    
  // 90.9: Data tmp8;                                                                               
                                                                                                    
                                                                                                    
  // 90.9: tmp8 := result.ref;                                                                      
                                                                                                    
                                                                                                    
  moverPath308924 := ReadEval.AtomicMarkableReferenceResult.ref(tid: Tid,result: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308924 := m#moverPath(moverPath308924);                                                      
  path308924 := p#moverPath(moverPath308924);                                                       
  assume Data._state308924 == Data._state && Data._lock308924 == Data._lock && AtomicMarkableReferenceResult._state308924 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308924 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308924 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308924 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308924 == AtomicMarkableReference._state && AtomicMarkableReference.ref308924 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308924 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308924 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308924 == AtomicMarkableReference._lock && Main._state308924 == Main._state && Main._lock308924 == Main._lock && tmp8308924 == tmp8 && tmp7308924 == tmp7 && tmp6308924 == tmp6 && b308924 == b && result2308924 == result2 && result308924 == result && d308924 == d && x308924 == x && this308924 == this && tid308924 == tid && $pc308924 == $pc;
  assume $recorded.state308924 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume result != AtomicMarkableReferenceResult.null;                                             
  } else {                                                                                          
   assert result != AtomicMarkableReferenceResult.null;                                                    // (90.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover308924);                                                              
  assert $pc != PhaseError;                                                                                // (90.9): Reduction failure
  tmp8 := AtomicMarkableReferenceResult.ref[result];                                                
                                                                                                    
  // 90.9: Data tmp9;                                                                               
                                                                                                    
                                                                                                    
  // 90.9: tmp9 := result2.ref;                                                                     
                                                                                                    
                                                                                                    
  moverPath308930 := ReadEval.AtomicMarkableReferenceResult.ref(tid: Tid,result2: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308930 := m#moverPath(moverPath308930);                                                      
  path308930 := p#moverPath(moverPath308930);                                                       
  assume Data._state308930 == Data._state && Data._lock308930 == Data._lock && AtomicMarkableReferenceResult._state308930 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308930 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308930 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308930 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308930 == AtomicMarkableReference._state && AtomicMarkableReference.ref308930 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308930 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308930 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308930 == AtomicMarkableReference._lock && Main._state308930 == Main._state && Main._lock308930 == Main._lock && tmp9308930 == tmp9 && tmp8308930 == tmp8 && tmp7308930 == tmp7 && tmp6308930 == tmp6 && b308930 == b && result2308930 == result2 && result308930 == result && d308930 == d && x308930 == x && this308930 == this && tid308930 == tid && $pc308930 == $pc;
  assume $recorded.state308930 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume result2 != AtomicMarkableReferenceResult.null;                                            
  } else {                                                                                          
   assert result2 != AtomicMarkableReferenceResult.null;                                                   // (90.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover308930);                                                              
  assert $pc != PhaseError;                                                                                // (90.9): Reduction failure
  tmp9 := AtomicMarkableReferenceResult.ref[result2];                                               
                                                                                                    
  // 90.9: assert tmp8 == tmp9;                                                                     
                                                                                                    
  assume Data._state308935 == Data._state && Data._lock308935 == Data._lock && AtomicMarkableReferenceResult._state308935 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308935 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308935 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308935 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308935 == AtomicMarkableReference._state && AtomicMarkableReference.ref308935 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308935 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308935 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308935 == AtomicMarkableReference._lock && Main._state308935 == Main._state && Main._lock308935 == Main._lock && tmp9308935 == tmp9 && tmp8308935 == tmp8 && tmp7308935 == tmp7 && tmp6308935 == tmp6 && b308935 == b && result2308935 == result2 && result308935 == result && d308935 == d && x308935 == x && this308935 == this && tid308935 == tid;
  assume $recorded.state308935 == 1;                                                                
  assert (tmp8==tmp9);                                                                                     // (90.9): This assertion may not hold.
                                                                                                    
  // 91.9: boolean tmp10;                                                                           
                                                                                                    
                                                                                                    
  // 91.9: tmp10 := result.mark;                                                                    
                                                                                                    
                                                                                                    
  moverPath308941 := ReadEval.AtomicMarkableReferenceResult.mark(tid: Tid,result: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308941 := m#moverPath(moverPath308941);                                                      
  path308941 := p#moverPath(moverPath308941);                                                       
  assume Data._state308941 == Data._state && Data._lock308941 == Data._lock && AtomicMarkableReferenceResult._state308941 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308941 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308941 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308941 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308941 == AtomicMarkableReference._state && AtomicMarkableReference.ref308941 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308941 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308941 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308941 == AtomicMarkableReference._lock && Main._state308941 == Main._state && Main._lock308941 == Main._lock && tmp10308941 == tmp10 && tmp9308941 == tmp9 && tmp8308941 == tmp8 && tmp7308941 == tmp7 && tmp6308941 == tmp6 && b308941 == b && result2308941 == result2 && result308941 == result && d308941 == d && x308941 == x && this308941 == this && tid308941 == tid && $pc308941 == $pc;
  assume $recorded.state308941 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume result != AtomicMarkableReferenceResult.null;                                             
  } else {                                                                                          
   assert result != AtomicMarkableReferenceResult.null;                                                    // (91.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover308941);                                                              
  assert $pc != PhaseError;                                                                                // (91.9): Reduction failure
  tmp10 := AtomicMarkableReferenceResult.mark[result];                                              
                                                                                                    
  // 91.9: boolean tmp11;                                                                           
                                                                                                    
                                                                                                    
  // 91.9: tmp11 := result2.mark;                                                                   
                                                                                                    
                                                                                                    
  moverPath308947 := ReadEval.AtomicMarkableReferenceResult.mark(tid: Tid,result2: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308947 := m#moverPath(moverPath308947);                                                      
  path308947 := p#moverPath(moverPath308947);                                                       
  assume Data._state308947 == Data._state && Data._lock308947 == Data._lock && AtomicMarkableReferenceResult._state308947 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308947 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308947 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308947 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308947 == AtomicMarkableReference._state && AtomicMarkableReference.ref308947 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308947 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308947 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308947 == AtomicMarkableReference._lock && Main._state308947 == Main._state && Main._lock308947 == Main._lock && tmp11308947 == tmp11 && tmp10308947 == tmp10 && tmp9308947 == tmp9 && tmp8308947 == tmp8 && tmp7308947 == tmp7 && tmp6308947 == tmp6 && b308947 == b && result2308947 == result2 && result308947 == result && d308947 == d && x308947 == x && this308947 == this && tid308947 == tid && $pc308947 == $pc;
  assume $recorded.state308947 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume result2 != AtomicMarkableReferenceResult.null;                                            
  } else {                                                                                          
   assert result2 != AtomicMarkableReferenceResult.null;                                                   // (91.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover308947);                                                              
  assert $pc != PhaseError;                                                                                // (91.9): Reduction failure
  tmp11 := AtomicMarkableReferenceResult.mark[result2];                                             
                                                                                                    
  // 91.9: assert tmp10 == tmp11;                                                                   
                                                                                                    
  assume Data._state308952 == Data._state && Data._lock308952 == Data._lock && AtomicMarkableReferenceResult._state308952 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308952 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308952 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308952 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308952 == AtomicMarkableReference._state && AtomicMarkableReference.ref308952 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308952 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308952 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308952 == AtomicMarkableReference._lock && Main._state308952 == Main._state && Main._lock308952 == Main._lock && tmp11308952 == tmp11 && tmp10308952 == tmp10 && tmp9308952 == tmp9 && tmp8308952 == tmp8 && tmp7308952 == tmp7 && tmp6308952 == tmp6 && b308952 == b && result2308952 == result2 && result308952 == result && d308952 == d && x308952 == x && this308952 == this && tid308952 == tid;
  assume $recorded.state308952 == 1;                                                                
  assert (tmp10==tmp11);                                                                                   // (91.9): This assertion may not hold.
 } else {                                                                                           
                                                                                                    
  // 93.9: Data tmp12;                                                                              
                                                                                                    
                                                                                                    
  // 93.9: tmp12 := result.ref;                                                                     
                                                                                                    
                                                                                                    
  moverPath308959 := ReadEval.AtomicMarkableReferenceResult.ref(tid: Tid,result: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308959 := m#moverPath(moverPath308959);                                                      
  path308959 := p#moverPath(moverPath308959);                                                       
  assume Data._state308959 == Data._state && Data._lock308959 == Data._lock && AtomicMarkableReferenceResult._state308959 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308959 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308959 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308959 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308959 == AtomicMarkableReference._state && AtomicMarkableReference.ref308959 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308959 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308959 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308959 == AtomicMarkableReference._lock && Main._state308959 == Main._state && Main._lock308959 == Main._lock && tmp12308959 == tmp12 && tmp7308959 == tmp7 && tmp6308959 == tmp6 && b308959 == b && result2308959 == result2 && result308959 == result && d308959 == d && x308959 == x && this308959 == this && tid308959 == tid && $pc308959 == $pc;
  assume $recorded.state308959 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume result != AtomicMarkableReferenceResult.null;                                             
  } else {                                                                                          
   assert result != AtomicMarkableReferenceResult.null;                                                    // (93.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover308959);                                                              
  assert $pc != PhaseError;                                                                                // (93.9): Reduction failure
  tmp12 := AtomicMarkableReferenceResult.ref[result];                                               
                                                                                                    
  // 93.9: Data tmp13;                                                                              
                                                                                                    
                                                                                                    
  // 93.9: tmp13 := result2.ref;                                                                    
                                                                                                    
                                                                                                    
  moverPath308965 := ReadEval.AtomicMarkableReferenceResult.ref(tid: Tid,result2: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
  mover308965 := m#moverPath(moverPath308965);                                                      
  path308965 := p#moverPath(moverPath308965);                                                       
  assume Data._state308965 == Data._state && Data._lock308965 == Data._lock && AtomicMarkableReferenceResult._state308965 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308965 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308965 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308965 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308965 == AtomicMarkableReference._state && AtomicMarkableReference.ref308965 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308965 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308965 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308965 == AtomicMarkableReference._lock && Main._state308965 == Main._state && Main._lock308965 == Main._lock && tmp13308965 == tmp13 && tmp12308965 == tmp12 && tmp7308965 == tmp7 && tmp6308965 == tmp6 && b308965 == b && result2308965 == result2 && result308965 == result && d308965 == d && x308965 == x && this308965 == this && tid308965 == tid && $pc308965 == $pc;
  assume $recorded.state308965 == 1;                                                                
  if ($pc == PreCommit) {                                                                           
   assume result2 != AtomicMarkableReferenceResult.null;                                            
  } else {                                                                                          
   assert result2 != AtomicMarkableReferenceResult.null;                                                   // (93.9): Cannot have potential null deference in left-mover part.
  }                                                                                                 
                                                                                                    
  $pc := transition($pc, mover308965);                                                              
  assert $pc != PhaseError;                                                                                // (93.9): Reduction failure
  tmp13 := AtomicMarkableReferenceResult.ref[result2];                                              
                                                                                                    
  // 93.9: assert tmp12 == tmp13;                                                                   
                                                                                                    
  assume Data._state308970 == Data._state && Data._lock308970 == Data._lock && AtomicMarkableReferenceResult._state308970 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308970 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308970 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308970 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308970 == AtomicMarkableReference._state && AtomicMarkableReference.ref308970 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308970 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308970 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308970 == AtomicMarkableReference._lock && Main._state308970 == Main._state && Main._lock308970 == Main._lock && tmp13308970 == tmp13 && tmp12308970 == tmp12 && tmp7308970 == tmp7 && tmp6308970 == tmp6 && b308970 == b && result2308970 == result2 && result308970 == result && d308970 == d && x308970 == x && this308970 == this && tid308970 == tid;
  assume $recorded.state308970 == 1;                                                                
  assert (tmp12==tmp13);                                                                                   // (93.9): This assertion may not hold.
 }                                                                                                  
                                                                                                    
 // 95.7: assume forall AtomicMarkableReference _i ::_i.nextWriter != tid;                          
                                                                                                    
 assume (forall _i: AtomicMarkableReference ::  ((AtomicMarkableReference.nextWriter[_i]!=tid)));   
                                                                                                    
 // 82.21: // return;                                                                               
                                                                                                    
 assume Data._state308982 == Data._state && Data._lock308982 == Data._lock && AtomicMarkableReferenceResult._state308982 == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref308982 == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark308982 == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock308982 == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state308982 == AtomicMarkableReference._state && AtomicMarkableReference.ref308982 == AtomicMarkableReference.ref && AtomicMarkableReference.mark308982 == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter308982 == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock308982 == AtomicMarkableReference._lock && Main._state308982 == Main._state && Main._lock308982 == Main._lock && tmp7308982 == tmp7 && tmp6308982 == tmp6 && b308982 == b && result2308982 == result2 && result308982 == result && d308982 == d && x308982 == x && this308982 == this && tid308982 == tid;
 assume $recorded.state308982 == 1;                                                                 
 return;                                                                                            
}                                                                                                   
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
//// Globals                                                                                        
                                                                                                    
                                                                                                    
//// State Invariant                                                                                
                                                                                                    
 function {:inline} StateInvariant(Data._state: [Data]State,Data._lock: [Data]Tid,AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State,AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data,AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool,AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid,AtomicMarkableReference._state: [AtomicMarkableReference]State,AtomicMarkableReference.ref: [AtomicMarkableReference]Data,AtomicMarkableReference.mark: [AtomicMarkableReference]bool,AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid,AtomicMarkableReference._lock: [AtomicMarkableReference]Tid,Main._state: [Main]State,Main._lock: [Main]Tid) returns (bool) {
  true &&                                                                                           
  (forall _i: Data  :: _i == Data.null <==> isNull(Data._state[_i])) &&                             
  (forall _i: AtomicMarkableReferenceResult  :: _i == AtomicMarkableReferenceResult.null <==> isNull(AtomicMarkableReferenceResult._state[_i])) &&
  (forall _i: AtomicMarkableReference  :: _i == AtomicMarkableReference.null <==> isNull(AtomicMarkableReference._state[_i])) &&
  (forall _i: Main  :: _i == Main.null <==> isNull(Main._state[_i])) &&                             
  (forall _i: AtomicMarkableReferenceResult ::  (isShared(AtomicMarkableReferenceResult._state[_i]) ==> isSharedAssignable(Data._state[AtomicMarkableReferenceResult.ref[_i]]))) &&
  (forall _i: AtomicMarkableReferenceResult ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(AtomicMarkableReferenceResult._state[_i],_t) ==> isLocalAssignable(Data._state[AtomicMarkableReferenceResult.ref[_i]], _t)))) &&
  (forall _i: AtomicMarkableReference ::  (isShared(AtomicMarkableReference._state[_i]) ==> isSharedAssignable(Data._state[AtomicMarkableReference.ref[_i]]))) &&
  (forall _i: AtomicMarkableReference ::  (forall _t: Tid :: (ValidTid(_t) && isLocal(AtomicMarkableReference._state[_i],_t) ==> isLocalAssignable(Data._state[AtomicMarkableReference.ref[_i]], _t)))) &&
  _trigger(0) &&                                                                                    
  _trigger(1) &&                                                                                    
  _trigger(2) &&                                                                                    
  _trigger(3)                                                                                       
 }                                                                                                  
//// Spec Checks                                                                                    
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,x: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.3): AtomicMarkableReferenceResult.ref failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (7.3): AtomicMarkableReferenceResult.ref failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Data;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReferenceResult.ref[x];                                                  
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := havocValue;                                                
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,x: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (7.3): AtomicMarkableReferenceResult.ref failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Data;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReferenceResult.ref[x];                                                  
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (7.3): AtomicMarkableReferenceResult.ref failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,x: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.3): AtomicMarkableReferenceResult.ref failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Data;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReferenceResult.ref[x];                                                  
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReferenceResult.ref[x] := havocValue;                                                
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,x: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (7.3): AtomicMarkableReferenceResult.ref failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,x: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.3): AtomicMarkableReferenceResult.mark failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (8.3): AtomicMarkableReferenceResult.mark failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReferenceResult.mark[x];                                                 
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := havocValue;                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,x: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (8.3): AtomicMarkableReferenceResult.mark failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : bool;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReferenceResult.mark[x];                                                 
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (8.3): AtomicMarkableReferenceResult.mark failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,x: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.3): AtomicMarkableReferenceResult.mark failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[x], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReferenceResult.mark[x];                                                 
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReferenceResult.mark[x] := havocValue;                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,x: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (8.3): AtomicMarkableReferenceResult.mark failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,x: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (14.3): AtomicMarkableReference.ref failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReference.ref(u: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (14.3): AtomicMarkableReference.ref failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Data;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.ref[x];                                                        
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReference.ref[x] := havocValue;                                                      
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,x: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (14.3): AtomicMarkableReference.ref failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Data;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.ref[x];                                                        
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReference.ref(u: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (14.3): AtomicMarkableReference.ref failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,x: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (14.3): AtomicMarkableReference.ref failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Data;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReference.ref[x];                                                        
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReference.ref[x] := havocValue;                                                      
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,x: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (14.3): AtomicMarkableReference.ref failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,x: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.3): AtomicMarkableReference.mark failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReference.mark(u: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (15.3): AtomicMarkableReference.mark failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.mark[x];                                                       
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReference.mark[x] := havocValue;                                                     
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,x: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (15.3): AtomicMarkableReference.mark failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : bool;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.mark[x];                                                       
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReference.mark(u: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (15.3): AtomicMarkableReference.mark failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,x: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.3): AtomicMarkableReference.mark failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : bool;                                                                             
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReference.mark[x];                                                       
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReference.mark[x] := havocValue;                                                     
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,x: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (15.3): AtomicMarkableReference.mark failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.RightMover.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,x: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (17.3): AtomicMarkableReference.nextWriter failed Write-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.RightMover.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_R);                                                                    
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;                                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _readByU := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assert _readByU_Mover == _E;                                                                              // (17.3): AtomicMarkableReference.nextWriter failed Write-Read Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteWrite.LeftMover.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Tid;                                                                              
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.nextWriter[x];                                                 
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := havocValue;                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;   // H[p.f = _]                                                  
 // Do we need to share writeByT.value if it is local?                                              
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,x: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assert isError(_writeByU_Mover);                                                                          // (17.3): AtomicMarkableReference.nextWriter failed Write-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckWriteRead.LeftMover.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var havocValue : Tid;                                                                              
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume w == AtomicMarkableReference.nextWriter[x];                                                 
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByU := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H                                                             
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
 assume !isError(_writeByT_Mover);                                                                  
 assume leq(_writeByT_Mover,_L);                                                                    
                                                                                                    
 assert _readByU_Mover == _E;                                                                              // (17.3): AtomicMarkableReference.nextWriter failed Write-Read Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.RightMover.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1;  // H                                                            
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,x: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_R);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (17.3): AtomicMarkableReference.nextWriter failed Read-Write Right-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure _CheckRead.LeftMover.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, x: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[x], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var havocValue : Tid;                                                                              
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
 assume w == AtomicMarkableReference.nextWriter[x];                                                 
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && x_pre == x;
 assume $recorded.state_pre == 1;  // H                                                             
 _readByT := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 AtomicMarkableReference.nextWriter[x] := havocValue;                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && x_post == x;
 assume $recorded.state_post == 1; // H[p.f := _]                                                   
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,x: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 assume leq(_readByT_Mover,_L);                                                                     
                                                                                                    
 assert isError(_writeByU_Mover);                                                                          // (17.3): AtomicMarkableReference.nextWriter failed Read-Write Left-Mover Check
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[y] := w;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[y] := w;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.ref[x];                                                      
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.ref[x] := tmpV;                                                      
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
 assume _writeByU_Mover != _E;  // will block until it can go...                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.ref(t: Tid,x: AtomicMarkableReferenceResult,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[x] := v;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[y] := w;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[y] := w;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var x_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReferenceResult.mark[x];                                                     
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReferenceResult.mark[x] := tmpV;                                                     
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
 assume _writeByU_Mover != _E;  // will block until it can go...                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReferenceResult.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReferenceResult, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReferenceResult._state[x], t);                                 
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var x_pre: AtomicMarkableReferenceResult;                                                          
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var x_post: AtomicMarkableReferenceResult;                                                         
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReferenceResult.mark(t: Tid,x: AtomicMarkableReferenceResult,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.ref.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[y] := w;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.ref.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Data, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[y] := w;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.ref.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Data, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Data;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Data;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var v_mid: Data;                                                                                   
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.ref[x];                                                            
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.ref[x] := tmpV;                                                            
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
 assume _writeByU_Mover != _E;  // will block until it can go...                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.ref.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Data, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.ref;                                                              
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var v_pre: Data;                                                                                   
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var v_post: Data;                                                                                  
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.ref(t: Tid,x: AtomicMarkableReference,v: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[x] := v;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.mark.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[y] := w;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.mark.AtomicMarkableReference.ref(t: Tid, u: Tid, v: bool, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[y] := w;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.mark.AtomicMarkableReference.mark(t: Tid, u: Tid, v: bool, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : bool;                                                                                   
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var v_mid: bool;                                                                                   
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.mark[x];                                                           
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.mark[x] := tmpV;                                                           
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
 assume _writeByU_Mover != _E;  // will block until it can go...                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.mark.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: bool, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.mark;                                                             
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var v_pre: bool;                                                                                   
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var v_post: bool;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.mark(t: Tid,x: AtomicMarkableReference,v: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[x] := v;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.ref[y] := w;                                                         
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.ref;                                                        
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.ref(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
 assert (true && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var y_mid: AtomicMarkableReferenceResult;                                                          
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReferenceResult.mark[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
 assert (true && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.nextWriter.AtomicMarkableReferenceResult.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReferenceResult)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReferenceResult._state[y], u);                                 
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReferenceResult.mark;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var y_pre: AtomicMarkableReferenceResult;                                                          
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var y_post: AtomicMarkableReferenceResult;                                                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReferenceResult.mark(u: Tid,y: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.nextWriter.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.nextWriter.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.nextWriter.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_mid: Data;                                                                                   
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var w0_mid: Data;                                                                                  
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReference.ref[y] := w;                                                               
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.nextWriter.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,w: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.ref[y] := w;                                                               
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.nextWriter.AtomicMarkableReference.ref(t: Tid, u: Tid, v: Tid, w: Data, w0: Data, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.ref;                                                              
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w0_pre: Data;                                                                                  
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var w_pre: Data;                                                                                   
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var w0_post: Data;                                                                                 
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var w_post: Data;                                                                                  
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.ref(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.nextWriter.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.nextWriter.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.nextWriter.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var w0_mid: bool;                                                                                  
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var w_mid: bool;                                                                                   
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReference.mark[y] := w;                                                              
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
                                                                                                    
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.nextWriter.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,w: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.mark[y] := w;                                                              
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
                                                                                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.nextWriter.AtomicMarkableReference.mark(t: Tid, u: Tid, v: Tid, w: bool, w0: bool, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.mark;                                                             
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var w_pre: bool;                                                                                   
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var w0_pre: bool;                                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var w_post: bool;                                                                                  
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
 var w0_post: bool;                                                                                 
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.mark(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.A.AtomicMarkableReference.nextWriter.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _E)) ==> ((_writeByU_Mover == _writeByUPost_Mover || _writeByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
 assert (leq(_writeByT_Mover, _N) && !leq(_writeByUPost_Mover, _L)) ==> (!leq(_writeByU_Mover, _L));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
 assert (x != y && leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByUPost_Mover == _writeByUPost_Mover || _writeByUPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
 procedure Stable.Check.C.AtomicMarkableReference.nextWriter.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
                                                                                                    
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.DE.AtomicMarkableReference.nextWriter.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var tmpV : Tid;                                                                                    
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _writeByUPost : MoverPath;                                                                     
 var _writeByUPost_Mover : Mover;                                                                   
 var _writeByUPost_Path : int;                                                                      
 var _writeByTPost : MoverPath;                                                                     
 var _writeByTPost_Mover : Mover;                                                                   
 var _writeByTPost_Path : int;                                                                      
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var t_mid: Tid;                                                                                    
 var Data._state_mid: [Data]State;                                                                  
 var AtomicMarkableReference.nextWriter_mid: [AtomicMarkableReference]Tid;                          
 var u_mid: Tid;                                                                                    
 var Main._lock_mid: [Main]Tid;                                                                     
 var y_mid: AtomicMarkableReference;                                                                
 var AtomicMarkableReference._lock_mid: [AtomicMarkableReference]Tid;                               
 var w_mid: Tid;                                                                                    
 var x_mid: AtomicMarkableReference;                                                                
 var $recorded.state_mid: int;                                                                      
 var Main._state_mid: [Main]State;                                                                  
 var AtomicMarkableReferenceResult._lock_mid: [AtomicMarkableReferenceResult]Tid;                   
 var w0_mid: Tid;                                                                                   
 var AtomicMarkableReferenceResult.mark_mid: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReferenceResult._state_mid: [AtomicMarkableReferenceResult]State;                
 var AtomicMarkableReferenceResult.ref_mid: [AtomicMarkableReferenceResult]Data;                    
 var AtomicMarkableReference.mark_mid: [AtomicMarkableReference]bool;                               
 var v_mid: Tid;                                                                                    
 var AtomicMarkableReference._state_mid: [AtomicMarkableReference]State;                            
 var Data._lock_mid: [Data]Tid;                                                                     
 var $pc_mid: Phase;                                                                                
 var AtomicMarkableReference.ref_mid: [AtomicMarkableReference]Data;                                
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 tmpV := AtomicMarkableReference.nextWriter[x];                                                     
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_mid == Data._state && Data._lock_mid == Data._lock && AtomicMarkableReferenceResult._state_mid == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_mid == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_mid == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_mid == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_mid == AtomicMarkableReference._state && AtomicMarkableReference.ref_mid == AtomicMarkableReference.ref && AtomicMarkableReference.mark_mid == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_mid == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_mid == AtomicMarkableReference._lock && Main._state_mid == Main._state && Main._lock_mid == Main._lock && t_mid == t && u_mid == u && v_mid == v && w_mid == w && w0_mid == w0 && x_mid == x && y_mid == y;
 assume $recorded.state_mid == 1;                                                                   
                                                                                                    
 _writeByUPost := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByUPost_Mover := m#moverPath(_writeByUPost);                                                 
 _writeByUPost_Path := p#moverPath(_writeByUPost);                                                  
                                                                                                    
 AtomicMarkableReference.nextWriter[x] := tmpV;                                                     
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 _writeByTPost := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByTPost_Mover := m#moverPath(_writeByTPost);                                                 
 _writeByTPost_Path := p#moverPath(_writeByTPost);                                                  
                                                                                                    
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assume _writeByTPost_Mover != _E;  // will block until it can go...                                
 assume _writeByUPost_Mover != _E;  // will block until it can go...                                
 assert (leq(_writeByT_Mover, _R) && leq(_writeByUPost_Mover, _N)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
 assert (leq(_writeByT_Mover, _N) && leq(_writeByUPost_Mover, _L)) ==> ((_writeByTPost_Mover == _writeByT_Mover || _writeByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
                                                                                                    
 }                                                                                                  
                                                                                                    
                                                                                                    
 procedure Stable.Check.FHI.AtomicMarkableReference.nextWriter.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByU : MoverPath;                                                                         
 var _writeByU_Mover : Mover;                                                                       
 var _writeByU_Path : int;                                                                          
 var _readByT : MoverPath;                                                                          
 var _readByT_Mover : Mover;                                                                        
 var _readByT_Path : int;                                                                           
 var _readByTPost : MoverPath;                                                                      
 var _readByTPost_Mover : Mover;                                                                    
 var _readByTPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByT := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByT_Mover := m#moverPath(_readByT);                                                           
 _readByT_Path := p#moverPath(_readByT);                                                            
 _writeByU := WriteEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,w: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByU_Mover := m#moverPath(_writeByU);                                                         
 _writeByU_Path := p#moverPath(_writeByU);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[y] := w;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByTPost := ReadEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByTPost_Mover := m#moverPath(_readByTPost);                                                   
 _readByTPost_Path := p#moverPath(_readByTPost);                                                    
 assume _writeByU_Mover != _E;  // will block until it can go...                                    
 assert (leq(_readByT_Mover, _R) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
 assert (leq(_readByT_Mover, _E) && leq(_writeByU_Mover, _L)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
 assert (x != y && leq(_readByT_Mover, _N) && leq(_writeByU_Mover, _N)) ==> ((_readByTPost_Mover == _readByT_Mover || _readByTPost_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
                                                                                                    
 }                                                                                                  
                                                                                                    
 procedure Stable.Check.JKL.AtomicMarkableReference.nextWriter.AtomicMarkableReference.nextWriter(t: Tid, u: Tid, v: Tid, w: Tid, w0: Tid, x: AtomicMarkableReference, y: AtomicMarkableReference)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(t);                                                                              
 requires ValidTid(u);                                                                              
 requires t != u;                                                                                   
 requires isAccessible(AtomicMarkableReference._state[x], t);                                       
 requires isAccessible(AtomicMarkableReference._state[y], u);                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
 modifies AtomicMarkableReference.nextWriter;                                                       
                                                                                                    
 {                                                                                                  
 var _writeByT : MoverPath;                                                                         
 var _writeByT_Mover : Mover;                                                                       
 var _writeByT_Path : int;                                                                          
 var _readByU : MoverPath;                                                                          
 var _readByU_Mover : Mover;                                                                        
 var _readByU_Path : int;                                                                           
 var _readByUPost : MoverPath;                                                                      
 var _readByUPost_Mover : Mover;                                                                    
 var _readByUPost_Path : int;                                                                       
 var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                
 var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                   
 var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                            
 var $recorded.state_pre: int;                                                                      
 var u_pre: Tid;                                                                                    
 var y_pre: AtomicMarkableReference;                                                                
 var v_pre: Tid;                                                                                    
 var w0_pre: Tid;                                                                                   
 var Main._lock_pre: [Main]Tid;                                                                     
 var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                          
 var Data._lock_pre: [Data]Tid;                                                                     
 var x_pre: AtomicMarkableReference;                                                                
 var Main._state_pre: [Main]State;                                                                  
 var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                               
 var $pc_pre: Phase;                                                                                
 var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                               
 var w_pre: Tid;                                                                                    
 var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                
 var t_pre: Tid;                                                                                    
 var Data._state_pre: [Data]State;                                                                  
 var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                   
 var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
 var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                              
 var Data._state_post: [Data]State;                                                                 
 var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                           
 var $recorded.state_post: int;                                                                     
 var y_post: AtomicMarkableReference;                                                               
 var t_post: Tid;                                                                                   
 var Main._state_post: [Main]State;                                                                 
 var $pc_post: Phase;                                                                               
 var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                  
 var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                  
 var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                              
 var Data._lock_post: [Data]Tid;                                                                    
 var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;               
 var Main._lock_post: [Main]Tid;                                                                    
 var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                               
 var x_post: AtomicMarkableReference;                                                               
 var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                         
 var w_post: Tid;                                                                                   
 var w0_post: Tid;                                                                                  
 var v_post: Tid;                                                                                   
 var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                   
 var u_post: Tid;                                                                                   
                                                                                                    
                                                                                                    
 _readByU := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByU_Mover := m#moverPath(_readByU);                                                           
 _readByU_Path := p#moverPath(_readByU);                                                            
 _writeByT := WriteEval.AtomicMarkableReference.nextWriter(t: Tid,x: AtomicMarkableReference,v: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _writeByT_Mover := m#moverPath(_writeByT);                                                         
 _writeByT_Path := p#moverPath(_writeByT);                                                          
                                                                                                    
 assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && t_pre == t && u_pre == u && v_pre == v && w_pre == w && w0_pre == w0 && x_pre == x && y_pre == y;
 assume $recorded.state_pre == 1;                                                                   
 AtomicMarkableReference.nextWriter[x] := v;                                                        
 assume Data._state_post == Data._state && Data._lock_post == Data._lock && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_post == AtomicMarkableReference._state && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock && Main._state_post == Main._state && Main._lock_post == Main._lock && t_post == t && u_post == u && v_post == v && w_post == w && w0_post == w0 && x_post == x && y_post == y;
 assume $recorded.state_post == 1;                                                                  
                                                                                                    
 _readByUPost := ReadEval.AtomicMarkableReference.nextWriter(u: Tid,y: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock);
 _readByUPost_Mover := m#moverPath(_readByUPost);                                                   
 _readByUPost_Path := p#moverPath(_readByUPost);                                                    
 assume _writeByT_Mover != _E;  // will block until it can go...                                    
 assert (leq(_writeByT_Mover, _R) && leq(_readByUPost_Mover, _E)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
 assert (leq(_writeByT_Mover, _N) && leq(_readByUPost_Mover, _L)) ==> ((_readByU_Mover == _readByUPost_Mover || _readByU_Mover == _E));       // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
 assert (leq(_writeByT_Mover, _N) && !leq(_readByUPost_Mover, _L)) ==> (!leq(_readByU_Mover, _L));         // (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
                                                                                                    
 }                                                                                                  
                                                                                                    
procedure Yield(tid: Tid);                                                                          
requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
requires ValidTid(tid);                                                                             
modifies Data._state;                                                                               
modifies Data._lock;                                                                                
modifies AtomicMarkableReferenceResult._state;                                                      
modifies AtomicMarkableReferenceResult.ref;                                                         
modifies AtomicMarkableReferenceResult.mark;                                                        
modifies AtomicMarkableReferenceResult._lock;                                                       
modifies AtomicMarkableReference._state;                                                            
modifies AtomicMarkableReference.ref;                                                               
modifies AtomicMarkableReference.mark;                                                              
modifies AtomicMarkableReference.nextWriter;                                                        
modifies AtomicMarkableReference._lock;                                                             
modifies Main._state;                                                                               
modifies Main._lock;                                                                                
ensures StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
ensures Y(tid , old(Data._state), old(Data._lock), old(AtomicMarkableReferenceResult._state), old(AtomicMarkableReferenceResult.ref), old(AtomicMarkableReferenceResult.mark), old(AtomicMarkableReferenceResult._lock), old(AtomicMarkableReference._state), old(AtomicMarkableReference.ref), old(AtomicMarkableReference.mark), old(AtomicMarkableReference.nextWriter), old(AtomicMarkableReference._lock), old(Main._state), old(Main._lock) , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
                                                                                                    
// Data._lock:                                                                                      
                                                                                                    
function {:inline} Y_Data._lock(tid : Tid, this: Data, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Data._state[this], tid) && leq(m#moverPath(ReadEval.Data._lock(tid: Tid,this: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (Data._lock[this] == newValue))
 &&(((Data._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Data._lock(tid : Tid, this: Data, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Data._lock.Subsumes.W(tid : Tid, u : Tid, this: Data, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var this_yield: Data;                                                                               
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(Data._state[this], tid);                                                       
 assume isAccessible(Data._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Data._lock(u: Tid,this: Data,newValue: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Data._lock(tid: Tid,this: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _N);
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Data._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Data._lock.Reflexive(tid : Tid, this: Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var this_yield: Data;                                                                               
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(Data._state[this], tid);                                                       
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Data._lock(tid, this, Data._lock[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Data._lock.Transitive(tid : Tid, this: Data, newValue : Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var this_pre: Data;                                                                                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var this_post: Data;                                                                                
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var newValue_post: Tid;                                                                             
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Data._state[this], tid);                                                       
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_Data._lock(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Data._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReferenceResult.ref:                                                               
                                                                                                    
function {:inline} Y_AtomicMarkableReferenceResult.ref(tid : Tid, this: AtomicMarkableReferenceResult, newValue: Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReferenceResult._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReferenceResult.ref(tid: Tid,this: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReferenceResult.ref[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReferenceResult.ref(tid : Tid, this: AtomicMarkableReferenceResult, newValue: Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult.ref.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReferenceResult, newValue: Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var newValue_yield: Data;                                                                           
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var this_yield: AtomicMarkableReferenceResult;                                                      
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
 assume isAccessible(AtomicMarkableReferenceResult._state[this], u);                                
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReferenceResult.ref(u: Tid,this: AtomicMarkableReferenceResult,newValue: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
                                                                                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReferenceResult.ref(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult.ref.Reflexive(tid : Tid, this: AtomicMarkableReferenceResult , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: AtomicMarkableReferenceResult;                                                      
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReferenceResult.ref(tid, this, AtomicMarkableReferenceResult.ref[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult.ref.Transitive(tid : Tid, this: AtomicMarkableReferenceResult, newValue : Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: AtomicMarkableReferenceResult;                                                        
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Data;                                                                             
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var newValue_post: Data;                                                                            
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: AtomicMarkableReferenceResult;                                                       
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReferenceResult.ref(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReferenceResult.ref(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReferenceResult.mark:                                                              
                                                                                                    
function {:inline} Y_AtomicMarkableReferenceResult.mark(tid : Tid, this: AtomicMarkableReferenceResult, newValue: bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReferenceResult._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReferenceResult.mark(tid: Tid,this: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReferenceResult.mark[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReferenceResult.mark(tid : Tid, this: AtomicMarkableReferenceResult, newValue: bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult.mark.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReferenceResult, newValue: bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var newValue_yield: bool;                                                                           
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var this_yield: AtomicMarkableReferenceResult;                                                      
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
 assume isAccessible(AtomicMarkableReferenceResult._state[this], u);                                
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReferenceResult.mark(u: Tid,this: AtomicMarkableReferenceResult,newValue: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
                                                                                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReferenceResult.mark(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult.mark.Reflexive(tid : Tid, this: AtomicMarkableReferenceResult , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: AtomicMarkableReferenceResult;                                                      
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReferenceResult.mark(tid, this, AtomicMarkableReferenceResult.mark[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult.mark.Transitive(tid : Tid, this: AtomicMarkableReferenceResult, newValue : bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var newValue_pre: bool;                                                                             
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: AtomicMarkableReferenceResult;                                                        
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: AtomicMarkableReferenceResult;                                                       
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var newValue_post: bool;                                                                            
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReferenceResult.mark(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReferenceResult.mark(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReferenceResult._lock:                                                             
                                                                                                    
function {:inline} Y_AtomicMarkableReferenceResult._lock(tid : Tid, this: AtomicMarkableReferenceResult, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReferenceResult._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReferenceResult._lock(tid: Tid,this: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReferenceResult._lock[this] == newValue))
 &&(((AtomicMarkableReferenceResult._lock[this]==tid)==(newValue==tid)))                            
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReferenceResult._lock(tid : Tid, this: AtomicMarkableReferenceResult, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult._lock.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReferenceResult, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var this_yield: AtomicMarkableReferenceResult;                                                      
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
 assume isAccessible(AtomicMarkableReferenceResult._state[this], u);                                
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReferenceResult._lock(u: Tid,this: AtomicMarkableReferenceResult,newValue: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.AtomicMarkableReferenceResult._lock(tid: Tid,this: AtomicMarkableReferenceResult,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _N);
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReferenceResult._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult._lock.Reflexive(tid : Tid, this: AtomicMarkableReferenceResult , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: AtomicMarkableReferenceResult;                                                      
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReferenceResult._lock(tid, this, AtomicMarkableReferenceResult._lock[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReferenceResult._lock.Transitive(tid : Tid, this: AtomicMarkableReferenceResult, newValue : Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var this_pre: AtomicMarkableReferenceResult;                                                        
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var this_post: AtomicMarkableReferenceResult;                                                       
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var newValue_post: Tid;                                                                             
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReferenceResult._state[this], tid);                              
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReferenceResult._lock(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReferenceResult._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReference.ref:                                                                     
                                                                                                    
function {:inline} Y_AtomicMarkableReference.ref(tid : Tid, this: AtomicMarkableReference, newValue: Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.ref(tid: Tid,this: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference.ref[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.ref(tid : Tid, this: AtomicMarkableReference, newValue: Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.ref.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var newValue_yield: Data;                                                                           
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference.ref(u: Tid,this: AtomicMarkableReference,newValue: Data,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
                                                                                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.ref(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.ref.Reflexive(tid : Tid, this: AtomicMarkableReference , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.ref(tid, this, AtomicMarkableReference.ref[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.ref.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Data , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var this_pre: AtomicMarkableReference;                                                              
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Data;                                                                             
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var newValue_post: Data;                                                                            
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var this_post: AtomicMarkableReference;                                                             
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReference.ref(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference.ref(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReference.mark:                                                                    
                                                                                                    
function {:inline} Y_AtomicMarkableReference.mark(tid : Tid, this: AtomicMarkableReference, newValue: bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.mark(tid: Tid,this: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference.mark[this] == newValue))
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.mark(tid : Tid, this: AtomicMarkableReference, newValue: bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.mark.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var newValue_yield: bool;                                                                           
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference.mark(u: Tid,this: AtomicMarkableReference,newValue: bool,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
                                                                                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.mark(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.mark.Reflexive(tid : Tid, this: AtomicMarkableReference , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.mark(tid, this, AtomicMarkableReference.mark[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.mark.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : bool , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var this_pre: AtomicMarkableReference;                                                              
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var newValue_pre: bool;                                                                             
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var this_post: AtomicMarkableReference;                                                             
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var newValue_post: bool;                                                                            
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReference.mark(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference.mark(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReference.nextWriter:                                                              
                                                                                                    
function {:inline} Y_AtomicMarkableReference.nextWriter(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference.nextWriter(tid: Tid,this: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference.nextWriter[this] == newValue))
 &&(((AtomicMarkableReference.nextWriter[this]!=tid)==(newValue!=tid)))                             
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference.nextWriter(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.nextWriter.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference.nextWriter(u: Tid,this: AtomicMarkableReference,newValue: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.AtomicMarkableReference.nextWriter(tid: Tid,this: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _N);
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.nextWriter(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.nextWriter.Reflexive(tid : Tid, this: AtomicMarkableReference , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference.nextWriter(tid, this, AtomicMarkableReference.nextWriter[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference.nextWriter.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var this_pre: AtomicMarkableReference;                                                              
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var this_post: AtomicMarkableReference;                                                             
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var newValue_post: Tid;                                                                             
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReference.nextWriter(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference.nextWriter(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// AtomicMarkableReference._lock:                                                                   
                                                                                                    
function {:inline} Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(AtomicMarkableReference._state[this], tid) && leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (AtomicMarkableReference._lock[this] == newValue))
 &&(((AtomicMarkableReference._lock[this]==tid)==(newValue==tid)))                                  
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_AtomicMarkableReference._lock(tid : Tid, this: AtomicMarkableReference, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Subsumes.W(tid : Tid, u : Tid, this: AtomicMarkableReference, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume isAccessible(AtomicMarkableReference._state[this], u);                                      
 assume !isError(m#moverPath(WriteEval.AtomicMarkableReference._lock(u: Tid,this: AtomicMarkableReference,newValue: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.AtomicMarkableReference._lock(tid: Tid,this: AtomicMarkableReference,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _N);
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Reflexive(tid : Tid, this: AtomicMarkableReference , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var this_yield: AtomicMarkableReference;                                                            
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_AtomicMarkableReference._lock(tid, this, AtomicMarkableReference._lock[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_AtomicMarkableReference._lock.Transitive(tid : Tid, this: AtomicMarkableReference, newValue : Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var this_pre: AtomicMarkableReference;                                                              
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var this_post: AtomicMarkableReference;                                                             
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var newValue_post: Tid;                                                                             
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(AtomicMarkableReference._state[this], tid);                                    
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_AtomicMarkableReference._lock(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_AtomicMarkableReference._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
// Main._lock:                                                                                      
                                                                                                    
function {:inline} Y_Main._lock(tid : Tid, this: Main, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 ((isAccessible(Main._state[this], tid) && leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _R)) ==> (Main._lock[this] == newValue))
 &&(((Main._lock[this]==tid)==(newValue==tid)))                                                     
                                                                                                    
}                                                                                                   
                                                                                                    
function {:inline} Invariant.Y_Main._lock(tid : Tid, this: Main, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid): bool
{                                                                                                   
 true                                                                                               
                                                                                                    
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Subsumes.W(tid : Tid, u : Tid, this: Main, newValue: Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
 requires ValidTid(u) && u != tid;                                                                  
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var newValue_yield: Tid;                                                                            
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var u_yield: Tid;                                                                                   
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume isAccessible(Main._state[this], u);                                                         
 assume !isError(m#moverPath(WriteEval.Main._lock(u: Tid,this: Main,newValue: Tid,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)));
 assume leq(m#moverPath(ReadEval.Main._lock(tid: Tid,this: Main,Data._state,Data._lock,AtomicMarkableReferenceResult._state,AtomicMarkableReferenceResult.ref,AtomicMarkableReferenceResult.mark,AtomicMarkableReferenceResult._lock,AtomicMarkableReference._state,AtomicMarkableReference.ref,AtomicMarkableReference.mark,AtomicMarkableReference.nextWriter,AtomicMarkableReference._lock,Main._state,Main._lock)), _N);
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && u_yield == u && newValue_yield == newValue && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Reflexive(tid : Tid, this: Main , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference._state_yield: [AtomicMarkableReference]State;                           
var AtomicMarkableReferenceResult.mark_yield: [AtomicMarkableReferenceResult]bool;                  
var tid_yield: Tid;                                                                                 
var AtomicMarkableReference.mark_yield: [AtomicMarkableReference]bool;                              
var Main._lock_yield: [Main]Tid;                                                                    
var AtomicMarkableReference.ref_yield: [AtomicMarkableReference]Data;                               
var AtomicMarkableReference.nextWriter_yield: [AtomicMarkableReference]Tid;                         
var $pc_yield: Phase;                                                                               
var this_yield: Main;                                                                               
var AtomicMarkableReferenceResult.ref_yield: [AtomicMarkableReferenceResult]Data;                   
var Data._state_yield: [Data]State;                                                                 
var Data._lock_yield: [Data]Tid;                                                                    
var AtomicMarkableReference._lock_yield: [AtomicMarkableReference]Tid;                              
var AtomicMarkableReferenceResult._state_yield: [AtomicMarkableReferenceResult]State;               
var Main._state_yield: [Main]State;                                                                 
var $recorded.state_yield: int;                                                                     
var AtomicMarkableReferenceResult._lock_yield: [AtomicMarkableReferenceResult]Tid;                  
                                                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
assume Data._state_yield == Data._state && Data._lock_yield == Data._lock && AtomicMarkableReferenceResult._state_yield == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_yield == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_yield == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_yield == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_yield == AtomicMarkableReference._state && AtomicMarkableReference.ref_yield == AtomicMarkableReference.ref && AtomicMarkableReference.mark_yield == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_yield == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_yield == AtomicMarkableReference._lock && Main._state_yield == Main._state && Main._lock_yield == Main._lock && this_yield == this && tid_yield == tid;
assume $recorded.state_yield == 1;                                                                  
 assert Y_Main._lock(tid, this, Main._lock[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
procedure Y_Main._lock.Transitive(tid : Tid, this: Main, newValue : Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid)
 requires StateInvariant(Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
 requires StateInvariant(Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 requires ValidTid(tid);                                                                            
                                                                                                    
{                                                                                                   
var AtomicMarkableReference.ref_pre: [AtomicMarkableReference]Data;                                 
var AtomicMarkableReferenceResult.mark_pre: [AtomicMarkableReferenceResult]bool;                    
var AtomicMarkableReference._state_pre: [AtomicMarkableReference]State;                             
var $recorded.state_pre: int;                                                                       
var this_pre: Main;                                                                                 
var Main._lock_pre: [Main]Tid;                                                                      
var AtomicMarkableReference.nextWriter_pre: [AtomicMarkableReference]Tid;                           
var Data._lock_pre: [Data]Tid;                                                                      
var tid_pre: Tid;                                                                                   
var Main._state_pre: [Main]State;                                                                   
var AtomicMarkableReference.mark_pre: [AtomicMarkableReference]bool;                                
var $pc_pre: Phase;                                                                                 
var AtomicMarkableReference._lock_pre: [AtomicMarkableReference]Tid;                                
var newValue_pre: Tid;                                                                              
var AtomicMarkableReferenceResult._state_pre: [AtomicMarkableReferenceResult]State;                 
var Data._state_pre: [Data]State;                                                                   
var AtomicMarkableReferenceResult._lock_pre: [AtomicMarkableReferenceResult]Tid;                    
var AtomicMarkableReferenceResult.ref_pre: [AtomicMarkableReferenceResult]Data;                     
                                                                                                    
var AtomicMarkableReference._lock_post: [AtomicMarkableReference]Tid;                               
var Data._state_post: [Data]State;                                                                  
var AtomicMarkableReference._state_post: [AtomicMarkableReference]State;                            
var this_post: Main;                                                                                
var $recorded.state_post: int;                                                                      
var Main._state_post: [Main]State;                                                                  
var $pc_post: Phase;                                                                                
var AtomicMarkableReferenceResult.mark_post: [AtomicMarkableReferenceResult]bool;                   
var AtomicMarkableReferenceResult._lock_post: [AtomicMarkableReferenceResult]Tid;                   
var AtomicMarkableReference.mark_post: [AtomicMarkableReference]bool;                               
var tid_post: Tid;                                                                                  
var Data._lock_post: [Data]Tid;                                                                     
var AtomicMarkableReferenceResult._state_post: [AtomicMarkableReferenceResult]State;                
var Main._lock_post: [Main]Tid;                                                                     
var AtomicMarkableReference.ref_post: [AtomicMarkableReference]Data;                                
var newValue_post: Tid;                                                                             
var AtomicMarkableReference.nextWriter_post: [AtomicMarkableReference]Tid;                          
var AtomicMarkableReferenceResult.ref_post: [AtomicMarkableReferenceResult]Data;                    
                                                                                                    
assume Data._state_pre == Data._state && Data._lock_pre == Data._lock && AtomicMarkableReferenceResult._state_pre == AtomicMarkableReferenceResult._state && AtomicMarkableReferenceResult.ref_pre == AtomicMarkableReferenceResult.ref && AtomicMarkableReferenceResult.mark_pre == AtomicMarkableReferenceResult.mark && AtomicMarkableReferenceResult._lock_pre == AtomicMarkableReferenceResult._lock && AtomicMarkableReference._state_pre == AtomicMarkableReference._state && AtomicMarkableReference.ref_pre == AtomicMarkableReference.ref && AtomicMarkableReference.mark_pre == AtomicMarkableReference.mark && AtomicMarkableReference.nextWriter_pre == AtomicMarkableReference.nextWriter && AtomicMarkableReference._lock_pre == AtomicMarkableReference._lock && Main._state_pre == Main._state && Main._lock_pre == Main._lock && newValue_pre == newValue && this_pre == this && tid_pre == tid;
assume $recorded.state_pre == 1;                                                                    
 assume isAccessible(Main._state[this], tid);                                                       
 assume Y(tid , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
 assume Y_Main._lock(tid, this, newValue , Data._state_p, Data._lock_p, AtomicMarkableReferenceResult._state_p, AtomicMarkableReferenceResult.ref_p, AtomicMarkableReferenceResult.mark_p, AtomicMarkableReferenceResult._lock_p, AtomicMarkableReference._state_p, AtomicMarkableReference.ref_p, AtomicMarkableReference.mark_p, AtomicMarkableReference.nextWriter_p, AtomicMarkableReference._lock_p, Main._state_p, Main._lock_p);
assume Data._state_post == Data._state_p && Data._lock_post == Data._lock_p && AtomicMarkableReferenceResult._state_post == AtomicMarkableReferenceResult._state_p && AtomicMarkableReferenceResult.ref_post == AtomicMarkableReferenceResult.ref_p && AtomicMarkableReferenceResult.mark_post == AtomicMarkableReferenceResult.mark_p && AtomicMarkableReferenceResult._lock_post == AtomicMarkableReferenceResult._lock_p && AtomicMarkableReference._state_post == AtomicMarkableReference._state_p && AtomicMarkableReference.ref_post == AtomicMarkableReference.ref_p && AtomicMarkableReference.mark_post == AtomicMarkableReference.mark_p && AtomicMarkableReference.nextWriter_post == AtomicMarkableReference.nextWriter_p && AtomicMarkableReference._lock_post == AtomicMarkableReference._lock_p && Main._state_post == Main._state_p && Main._lock_post == Main._lock_p && newValue_post == newValue && this_post == this && tid_post == tid;
assume $recorded.state_post == 1;                                                                   
 assert Y_Main._lock(tid, this, newValue , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock);
}                                                                                                   
                                                                                                    
                                                                                                    
function {:inline} Y(tid : Tid , Data._state: [Data]State, Data._lock: [Data]Tid, AtomicMarkableReferenceResult._state: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state: [AtomicMarkableReference]State, AtomicMarkableReference.ref: [AtomicMarkableReference]Data, AtomicMarkableReference.mark: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock: [AtomicMarkableReference]Tid, Main._state: [Main]State, Main._lock: [Main]Tid , Data._state_p: [Data]State, Data._lock_p: [Data]Tid, AtomicMarkableReferenceResult._state_p: [AtomicMarkableReferenceResult]State, AtomicMarkableReferenceResult.ref_p: [AtomicMarkableReferenceResult]Data, AtomicMarkableReferenceResult.mark_p: [AtomicMarkableReferenceResult]bool, AtomicMarkableReferenceResult._lock_p: [AtomicMarkableReferenceResult]Tid, AtomicMarkableReference._state_p: [AtomicMarkableReference]State, AtomicMarkableReference.ref_p: [AtomicMarkableReference]Data, AtomicMarkableReference.mark_p: [AtomicMarkableReference]bool, AtomicMarkableReference.nextWriter_p: [AtomicMarkableReference]Tid, AtomicMarkableReference._lock_p: [AtomicMarkableReference]Tid, Main._state_p: [Main]State, Main._lock_p: [Main]Tid): bool
{                                                                                                   
 (forall this: Data :: Y_Data._lock(tid : Tid, this, Data._lock_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: AtomicMarkableReferenceResult :: Y_AtomicMarkableReferenceResult.ref(tid : Tid, this, AtomicMarkableReferenceResult.ref_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: AtomicMarkableReferenceResult :: Y_AtomicMarkableReferenceResult.mark(tid : Tid, this, AtomicMarkableReferenceResult.mark_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: AtomicMarkableReferenceResult :: Y_AtomicMarkableReferenceResult._lock(tid : Tid, this, AtomicMarkableReferenceResult._lock_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.ref(tid : Tid, this, AtomicMarkableReference.ref_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.mark(tid : Tid, this, AtomicMarkableReference.mark_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference.nextWriter(tid : Tid, this, AtomicMarkableReference.nextWriter_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: AtomicMarkableReference :: Y_AtomicMarkableReference._lock(tid : Tid, this, AtomicMarkableReference._lock_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall this: Main :: Y_Main._lock(tid : Tid, this, Main._lock_p[this] , Data._state, Data._lock, AtomicMarkableReferenceResult._state, AtomicMarkableReferenceResult.ref, AtomicMarkableReferenceResult.mark, AtomicMarkableReferenceResult._lock, AtomicMarkableReference._state, AtomicMarkableReference.ref, AtomicMarkableReference.mark, AtomicMarkableReference.nextWriter, AtomicMarkableReference._lock, Main._state, Main._lock))
 && (forall _i : Data :: isShared(Data._state[_i]) ==> isShared(Data._state_p[_i]))                 
 && (forall _i : Data :: isLocal(Data._state[_i], tid) <==> isLocal(Data._state_p[_i], tid))        
 && (forall _i : AtomicMarkableReferenceResult :: isShared(AtomicMarkableReferenceResult._state[_i]) ==> isShared(AtomicMarkableReferenceResult._state_p[_i]))
 && (forall _i : AtomicMarkableReferenceResult :: isLocal(AtomicMarkableReferenceResult._state[_i], tid) <==> isLocal(AtomicMarkableReferenceResult._state_p[_i], tid))
 && (forall _i : AtomicMarkableReference :: isShared(AtomicMarkableReference._state[_i]) ==> isShared(AtomicMarkableReference._state_p[_i]))
 && (forall _i : AtomicMarkableReference :: isLocal(AtomicMarkableReference._state[_i], tid) <==> isLocal(AtomicMarkableReference._state_p[_i], tid))
 && (forall _i : Main :: isShared(Main._state[_i]) ==> isShared(Main._state_p[_i]))                 
 && (forall _i : Main :: isLocal(Main._state[_i], tid) <==> isLocal(Main._state_p[_i], tid))        
                                                                                                    
}                                                                                                   
                                                                                                    
                                                                                                    
// 2225.1-3622.2: (Method:82.5)
// 2242.1-2242.24: (82.5): Bad tid
// 2243.1-2243.38: (82.5): this is not global
// 2861.2-2863.2: (class anchor.sink.VarDeclStmt:83.7)
// 2864.2-2873.55: (class anchor.sink.Alloc:83.7)
// 2876.2-2878.2: (class anchor.sink.VarDeclStmt:83.7)
// 2879.2-2882.14: (class anchor.sink.Assign:83.7)
// 2883.2-2886.58: (class anchor.sink.Assume:13.31)
// 2887.2-2890.55: (class anchor.sink.Assume:13.31)
// 2891.2-2894.64: (class anchor.sink.Assume:13.31)
// 2895.2-2898.21: (class anchor.sink.Break:76.1)
// 2900.2-2902.2: (class anchor.sink.VarDeclStmt:84.7)
// 2903.2-2909.36: (class anchor.sink.Alloc:84.7)
// 2912.2-2914.2: (class anchor.sink.VarDeclStmt:84.7)
// 2915.2-2918.15: (class anchor.sink.Assign:84.7)
// 2919.2-2922.22: (class anchor.sink.Break:4.1)
// 2924.2-2926.2: (class anchor.sink.VarDeclStmt:85.7)
// 2929.2-2931.2: (class anchor.sink.VarDeclStmt:85.7)
// 2932.2-2935.15: (class anchor.sink.Assign:85.7)
// 2936.2-2938.2: (class anchor.sink.VarDeclStmt:65.5)
// 2939.2-2942.15: (class anchor.sink.Assign:65.5)
// 2944.3-2947.66: (class anchor.sink.Assume:67.7)
// 2949.3-2965.54: (class anchor.sink.Write:68.7)
// 2961.1-2961.51: (68.7): Cannot have potential null deference in left-mover part.
// 2964.1-2964.28: (68.7): Reduction failure
// 2968.2-2970.2: (class anchor.sink.VarDeclStmt:70.5)
// 2971.2-2979.69: (class anchor.sink.Alloc:70.5)
// 2982.2-2984.2: (class anchor.sink.VarDeclStmt:70.5)
// 2985.2-2988.23: (class anchor.sink.Assign:70.5)
// 2989.2-2992.65: (class anchor.sink.Assume:6.37)
// 2993.2-2996.62: (class anchor.sink.Assume:6.37)
// 2997.2-3000.22: (class anchor.sink.Break:9.1)
// 3002.2-3004.2: (class anchor.sink.VarDeclStmt:71.5)
// 3005.2-3022.50: (class anchor.sink.Read:71.5)
// 3017.1-3017.50: (71.5): Cannot have potential null deference in left-mover part.
// 3021.1-3021.27: (71.5): Reduction failure
// 3024.2-3044.2: (class anchor.sink.Write:71.5)
// 3036.1-3036.58: (71.5): Cannot have potential null deference in left-mover part.
// 3039.1-3039.27: (71.5): Reduction failure
// 3047.3-3049.3: (class anchor.sink.VarDeclStmt:72.13)
// 3050.3-3056.52: (class anchor.sink.Read:72.13)
// 3058.3-3063.60: (class anchor.sink.Write:72.13)
// 3066.2-3069.22: (class anchor.sink.Assign:73.5)
// 3070.2-3073.22: (class anchor.sink.Break:73.5)
// 3074.2-3077.47: (class anchor.sink.Assign:64.39)
// 3078.2-3081.22: (class anchor.sink.Break:64.39)
// 3083.2-3091.41: (class anchor.sink.Yield:86.7)
// 3092.2-3094.2: (class anchor.sink.VarDeclStmt:87.7)
// 3097.2-3099.2: (class anchor.sink.VarDeclStmt:87.7)
// 3100.2-3103.15: (class anchor.sink.Assign:87.7)
// 3104.2-3106.2: (class anchor.sink.VarDeclStmt:65.5)
// 3107.2-3110.15: (class anchor.sink.Assign:65.5)
// 3112.3-3115.66: (class anchor.sink.Assume:67.7)
// 3117.3-3133.54: (class anchor.sink.Write:68.7)
// 3129.1-3129.51: (68.7): Cannot have potential null deference in left-mover part.
// 3132.1-3132.28: (68.7): Reduction failure
// 3136.2-3138.2: (class anchor.sink.VarDeclStmt:70.5)
// 3139.2-3147.69: (class anchor.sink.Alloc:70.5)
// 3150.2-3152.2: (class anchor.sink.VarDeclStmt:70.5)
// 3153.2-3156.23: (class anchor.sink.Assign:70.5)
// 3157.2-3160.65: (class anchor.sink.Assume:6.37)
// 3161.2-3164.62: (class anchor.sink.Assume:6.37)
// 3165.2-3168.22: (class anchor.sink.Break:9.1)
// 3170.2-3172.2: (class anchor.sink.VarDeclStmt:71.5)
// 3173.2-3190.50: (class anchor.sink.Read:71.5)
// 3185.1-3185.50: (71.5): Cannot have potential null deference in left-mover part.
// 3189.1-3189.27: (71.5): Reduction failure
// 3192.2-3212.2: (class anchor.sink.Write:71.5)
// 3204.1-3204.58: (71.5): Cannot have potential null deference in left-mover part.
// 3207.1-3207.27: (71.5): Reduction failure
// 3215.3-3217.3: (class anchor.sink.VarDeclStmt:72.13)
// 3218.3-3224.52: (class anchor.sink.Read:72.13)
// 3226.3-3231.60: (class anchor.sink.Write:72.13)
// 3234.2-3237.23: (class anchor.sink.Assign:73.5)
// 3238.2-3241.22: (class anchor.sink.Break:73.5)
// 3242.2-3245.48: (class anchor.sink.Assign:64.39)
// 3246.2-3249.22: (class anchor.sink.Break:64.39)
// 3251.2-3253.2: (class anchor.sink.VarDeclStmt:88.7)
// 3254.2-3256.2: (class anchor.sink.VarDeclStmt:88.7)
// 3257.2-3274.52: (class anchor.sink.Read:88.7)
// 3269.1-3269.55: (88.7): Cannot have potential null deference in left-mover part.
// 3273.1-3273.27: (88.7): Reduction failure
// 3275.2-3277.2: (class anchor.sink.VarDeclStmt:88.7)
// 3278.2-3295.53: (class anchor.sink.Read:88.7)
// 3290.1-3290.55: (88.7): Cannot have potential null deference in left-mover part.
// 3294.1-3294.27: (88.7): Reduction failure
// 3298.2-3300.2: (class anchor.sink.VarDeclStmt:88.7)
// 3301.2-3303.2: (class anchor.sink.VarDeclStmt:88.7)
// 3304.2-3306.2: (class anchor.sink.VarDeclStmt:88.7)
// 3307.2-3309.2: (class anchor.sink.VarDeclStmt:88.7)
// 3310.2-3312.2: (class anchor.sink.VarDeclStmt:88.7)
// 3313.2-3316.25: (class anchor.sink.Assign:88.7)
// 3317.2-3320.25: (class anchor.sink.Assign:88.7)
// 3321.2-3324.26: (class anchor.sink.Assign:88.7)
// 3325.2-3328.21: (class anchor.sink.Assign:88.7)
// 3329.2-3332.15: (class anchor.sink.Assign:88.7)
// 3333.2-3335.2: (class anchor.sink.VarDeclStmt:25.7)
// 3336.2-3339.15: (class anchor.sink.Assign:25.7)
// 3341.3-3344.61: (class anchor.sink.Assume:27.8)
// 3345.3-3347.3: (class anchor.sink.VarDeclStmt:28.8)
// 3348.3-3350.3: (class anchor.sink.VarDeclStmt:29.8)
// 3353.4-3359.51: (class anchor.sink.Read:30.16)
// 3364.4-3370.53: (class anchor.sink.Read:31.16)
// 3373.3-3375.3: (class anchor.sink.VarDeclStmt:32.8)
// 3376.3-3378.3: (class anchor.sink.VarDeclStmt:32.8)
// 3379.3-3382.39: (class anchor.sink.Assign:32.8)
// 3384.4-3387.42: (class anchor.sink.Assign:32.39)
// 3389.4-3392.21: (class anchor.sink.Assign:<undefined position>)
// 3396.4-3416.4: (class anchor.sink.Write:33.9)
// 3408.1-3408.52: (33.9): Cannot have potential null deference in left-mover part.
// 3411.1-3411.29: (33.9): Reduction failure
// 3420.5-3425.57: (class anchor.sink.Write:34.17)
// 3428.4-3431.14: (class anchor.sink.Assign:35.9)
// 3432.4-3435.24: (class anchor.sink.Break:35.9)
// 3437.4-3440.15: (class anchor.sink.Assign:37.9)
// 3441.4-3444.24: (class anchor.sink.Break:37.9)
// 3447.3-3450.14: (class anchor.sink.Assign:40.8)
// 3451.3-3454.23: (class anchor.sink.Break:40.8)
// 3456.2-3459.13: (class anchor.sink.Assign:24.86)
// 3460.2-3463.22: (class anchor.sink.Break:24.86)
// 3466.3-3468.3: (class anchor.sink.VarDeclStmt:90.9)
// 3469.3-3486.53: (class anchor.sink.Read:90.9)
// 3481.1-3481.56: (90.9): Cannot have potential null deference in left-mover part.
// 3485.1-3485.28: (90.9): Reduction failure
// 3487.3-3489.3: (class anchor.sink.VarDeclStmt:90.9)
// 3490.3-3507.54: (class anchor.sink.Read:90.9)
// 3502.1-3502.57: (90.9): Cannot have potential null deference in left-mover part.
// 3506.1-3506.28: (90.9): Reduction failure
// 3508.3-3513.23: (class anchor.sink.Assert:90.9)
// 3513.1-3513.23: (90.9): This assertion may not hold.
// 3514.3-3516.3: (class anchor.sink.VarDeclStmt:91.9)
// 3517.3-3534.55: (class anchor.sink.Read:91.9)
// 3529.1-3529.56: (91.9): Cannot have potential null deference in left-mover part.
// 3533.1-3533.28: (91.9): Reduction failure
// 3535.3-3537.3: (class anchor.sink.VarDeclStmt:91.9)
// 3538.3-3555.56: (class anchor.sink.Read:91.9)
// 3550.1-3550.57: (91.9): Cannot have potential null deference in left-mover part.
// 3554.1-3554.28: (91.9): Reduction failure
// 3556.3-3561.25: (class anchor.sink.Assert:91.9)
// 3561.1-3561.25: (91.9): This assertion may not hold.
// 3563.3-3565.3: (class anchor.sink.VarDeclStmt:93.9)
// 3566.3-3583.54: (class anchor.sink.Read:93.9)
// 3578.1-3578.56: (93.9): Cannot have potential null deference in left-mover part.
// 3582.1-3582.28: (93.9): Reduction failure
// 3584.3-3586.3: (class anchor.sink.VarDeclStmt:93.9)
// 3587.3-3604.55: (class anchor.sink.Read:93.9)
// 3599.1-3599.57: (93.9): Cannot have potential null deference in left-mover part.
// 3603.1-3603.28: (93.9): Reduction failure
// 3605.3-3610.25: (class anchor.sink.Assert:93.9)
// 3610.1-3610.25: (93.9): This assertion may not hold.
// 3612.2-3615.98: (class anchor.sink.Assume:95.7)
// 3616.2-3621.9: (class anchor.sink.Return:82.21)
// 3723.1-3723.34: (7.3): AtomicMarkableReferenceResult.ref failed Write-Write Right-Mover Check
// 3800.1-3800.30: (7.3): AtomicMarkableReferenceResult.ref failed Write-Read Right-Mover Check
// 3881.1-3881.34: (7.3): AtomicMarkableReferenceResult.ref failed Write-Write Left-Mover Check
// 3959.1-3959.30: (7.3): AtomicMarkableReferenceResult.ref failed Write-Read Left-Mover Check
// 4034.1-4034.34: (7.3): AtomicMarkableReferenceResult.ref failed Read-Write Right-Mover Check
// 4112.1-4112.34: (7.3): AtomicMarkableReferenceResult.ref failed Read-Write Left-Mover Check
// 4189.1-4189.34: (8.3): AtomicMarkableReferenceResult.mark failed Write-Write Right-Mover Check
// 4266.1-4266.30: (8.3): AtomicMarkableReferenceResult.mark failed Write-Read Right-Mover Check
// 4347.1-4347.34: (8.3): AtomicMarkableReferenceResult.mark failed Write-Write Left-Mover Check
// 4425.1-4425.30: (8.3): AtomicMarkableReferenceResult.mark failed Write-Read Left-Mover Check
// 4500.1-4500.34: (8.3): AtomicMarkableReferenceResult.mark failed Read-Write Right-Mover Check
// 4578.1-4578.34: (8.3): AtomicMarkableReferenceResult.mark failed Read-Write Left-Mover Check
// 4655.1-4655.34: (14.3): AtomicMarkableReference.ref failed Write-Write Right-Mover Check
// 4732.1-4732.30: (14.3): AtomicMarkableReference.ref failed Write-Read Right-Mover Check
// 4813.1-4813.34: (14.3): AtomicMarkableReference.ref failed Write-Write Left-Mover Check
// 4891.1-4891.30: (14.3): AtomicMarkableReference.ref failed Write-Read Left-Mover Check
// 4966.1-4966.34: (14.3): AtomicMarkableReference.ref failed Read-Write Right-Mover Check
// 5044.1-5044.34: (14.3): AtomicMarkableReference.ref failed Read-Write Left-Mover Check
// 5121.1-5121.34: (15.3): AtomicMarkableReference.mark failed Write-Write Right-Mover Check
// 5198.1-5198.30: (15.3): AtomicMarkableReference.mark failed Write-Read Right-Mover Check
// 5279.1-5279.34: (15.3): AtomicMarkableReference.mark failed Write-Write Left-Mover Check
// 5357.1-5357.30: (15.3): AtomicMarkableReference.mark failed Write-Read Left-Mover Check
// 5432.1-5432.34: (15.3): AtomicMarkableReference.mark failed Read-Write Right-Mover Check
// 5510.1-5510.34: (15.3): AtomicMarkableReference.mark failed Read-Write Left-Mover Check
// 5587.1-5587.34: (17.3): AtomicMarkableReference.nextWriter failed Write-Write Right-Mover Check
// 5664.1-5664.30: (17.3): AtomicMarkableReference.nextWriter failed Write-Read Right-Mover Check
// 5745.1-5745.34: (17.3): AtomicMarkableReference.nextWriter failed Write-Write Left-Mover Check
// 5823.1-5823.30: (17.3): AtomicMarkableReference.nextWriter failed Write-Read Left-Mover Check
// 5898.1-5898.34: (17.3): AtomicMarkableReference.nextWriter failed Read-Write Right-Mover Check
// 5976.1-5976.34: (17.3): AtomicMarkableReference.nextWriter failed Read-Write Left-Mover Check
// 6065.1-6065.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
// 6066.1-6066.101: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
// 6067.1-6067.158: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
// 6190.1-6190.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
// 6318.1-6318.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
// 6319.1-6319.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
// 6408.1-6408.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
// 6409.1-6409.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
// 6410.1-6410.146: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
// 6498.1-6498.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
// 6499.1-6499.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
// 6500.1-6500.99: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
// 6590.1-6590.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
// 6591.1-6591.101: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
// 6592.1-6592.158: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
// 6715.1-6715.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
// 6843.1-6843.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
// 6844.1-6844.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
// 6933.1-6933.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
// 6934.1-6934.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
// 6935.1-6935.146: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
// 7023.1-7023.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
// 7024.1-7024.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
// 7025.1-7025.99: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
// 7115.1-7115.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
// 7116.1-7116.101: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
// 7117.1-7117.156: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
// 7240.1-7240.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
// 7368.1-7368.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
// 7369.1-7369.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
// 7458.1-7458.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
// 7459.1-7459.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
// 7460.1-7460.144: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
// 7548.1-7548.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
// 7549.1-7549.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
// 7550.1-7550.99: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
// 7640.1-7640.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
// 7641.1-7641.101: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
// 7642.1-7642.156: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
// 7765.1-7765.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
// 7893.1-7893.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
// 7894.1-7894.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
// 7983.1-7983.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
// 7984.1-7984.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
// 7985.1-7985.144: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
// 8073.1-8073.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
// 8074.1-8074.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
// 8075.1-8075.99: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
// 8165.1-8165.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.1)
// 8166.1-8166.101: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.2)
// 8167.1-8167.156: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case A.3)
// 8290.1-8290.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
// 8418.1-8418.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
// 8419.1-8419.144: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
// 8508.1-8508.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
// 8509.1-8509.136: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
// 8510.1-8510.144: (7.3): AtomicMarkableReferenceResult.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
// 8598.1-8598.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case J)
// 8599.1-8599.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case K)
// 8600.1-8600.99: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.ref (case L)
// 8690.1-8690.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
// 8691.1-8691.101: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
// 8692.1-8692.158: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
// 8815.1-8815.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
// 8943.1-8943.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
// 8944.1-8944.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
// 9033.1-9033.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
// 9034.1-9034.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
// 9035.1-9035.146: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
// 9123.1-9123.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
// 9124.1-9124.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
// 9125.1-9125.99: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
// 9215.1-9215.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
// 9216.1-9216.101: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
// 9217.1-9217.158: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
// 9340.1-9340.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
// 9468.1-9468.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
// 9469.1-9469.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
// 9558.1-9558.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
// 9559.1-9559.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
// 9560.1-9560.146: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
// 9648.1-9648.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
// 9649.1-9649.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
// 9650.1-9650.99: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
// 9740.1-9740.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
// 9741.1-9741.101: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
// 9742.1-9742.156: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
// 9865.1-9865.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
// 9993.1-9993.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
// 9994.1-9994.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
// 10083.1-10083.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
// 10084.1-10084.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
// 10085.1-10085.144: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
// 10173.1-10173.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
// 10174.1-10174.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
// 10175.1-10175.99: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
// 10265.1-10265.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
// 10266.1-10266.101: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
// 10267.1-10267.156: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
// 10390.1-10390.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
// 10518.1-10518.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
// 10519.1-10519.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
// 10608.1-10608.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
// 10609.1-10609.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
// 10610.1-10610.144: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
// 10698.1-10698.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
// 10699.1-10699.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
// 10700.1-10700.99: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
// 10790.1-10790.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.1)
// 10791.1-10791.101: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.2)
// 10792.1-10792.156: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case A.3)
// 10915.1-10915.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
// 11043.1-11043.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
// 11044.1-11044.144: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
// 11133.1-11133.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
// 11134.1-11134.136: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
// 11135.1-11135.144: (8.3): AtomicMarkableReferenceResult.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
// 11223.1-11223.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case J)
// 11224.1-11224.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case K)
// 11225.1-11225.99: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReferenceResult.mark (case L)
// 11315.1-11315.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
// 11316.1-11316.101: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
// 11317.1-11317.156: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
// 11440.1-11440.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
// 11568.1-11568.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
// 11569.1-11569.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
// 11658.1-11658.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
// 11659.1-11659.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
// 11660.1-11660.144: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
// 11748.1-11748.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
// 11749.1-11749.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
// 11750.1-11750.99: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
// 11840.1-11840.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
// 11841.1-11841.101: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
// 11842.1-11842.156: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
// 11965.1-11965.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
// 12093.1-12093.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
// 12094.1-12094.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
// 12183.1-12183.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
// 12184.1-12184.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
// 12185.1-12185.144: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
// 12273.1-12273.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
// 12274.1-12274.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
// 12275.1-12275.99: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
// 12365.1-12365.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
// 12366.1-12366.101: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
// 12367.1-12367.158: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
// 12490.1-12490.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
// 12618.1-12618.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
// 12619.1-12619.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
// 12708.1-12708.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
// 12709.1-12709.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
// 12710.1-12710.146: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
// 12798.1-12798.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
// 12799.1-12799.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
// 12800.1-12800.99: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
// 12890.1-12890.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
// 12891.1-12891.101: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
// 12892.1-12892.158: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
// 13015.1-13015.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
// 13143.1-13143.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
// 13144.1-13144.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
// 13233.1-13233.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
// 13234.1-13234.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
// 13235.1-13235.146: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
// 13323.1-13323.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
// 13324.1-13324.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
// 13325.1-13325.99: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
// 13415.1-13415.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.1)
// 13416.1-13416.101: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.2)
// 13417.1-13417.158: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case A.3)
// 13540.1-13540.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
// 13668.1-13668.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
// 13669.1-13669.144: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
// 13758.1-13758.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
// 13759.1-13759.136: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
// 13760.1-13760.146: (14.3): AtomicMarkableReference.ref is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
// 13848.1-13848.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.ref (case J)
// 13849.1-13849.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.ref (case K)
// 13850.1-13850.99: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.ref (case L)
// 13940.1-13940.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
// 13941.1-13941.101: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
// 13942.1-13942.156: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
// 14065.1-14065.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
// 14193.1-14193.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
// 14194.1-14194.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
// 14283.1-14283.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
// 14284.1-14284.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
// 14285.1-14285.144: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
// 14373.1-14373.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
// 14374.1-14374.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
// 14375.1-14375.99: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
// 14465.1-14465.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
// 14466.1-14466.101: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
// 14467.1-14467.156: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
// 14590.1-14590.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
// 14718.1-14718.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
// 14719.1-14719.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
// 14808.1-14808.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
// 14809.1-14809.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
// 14810.1-14810.144: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
// 14898.1-14898.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
// 14899.1-14899.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
// 14900.1-14900.99: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
// 14990.1-14990.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
// 14991.1-14991.101: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
// 14992.1-14992.158: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
// 15115.1-15115.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
// 15243.1-15243.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
// 15244.1-15244.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
// 15333.1-15333.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
// 15334.1-15334.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
// 15335.1-15335.146: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
// 15423.1-15423.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
// 15424.1-15424.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
// 15425.1-15425.99: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
// 15515.1-15515.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
// 15516.1-15516.101: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
// 15517.1-15517.158: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
// 15640.1-15640.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
// 15768.1-15768.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
// 15769.1-15769.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
// 15858.1-15858.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
// 15859.1-15859.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
// 15860.1-15860.146: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
// 15948.1-15948.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
// 15949.1-15949.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
// 15950.1-15950.99: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
// 16040.1-16040.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.1)
// 16041.1-16041.101: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.2)
// 16042.1-16042.158: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case A.3)
// 16165.1-16165.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
// 16293.1-16293.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
// 16294.1-16294.144: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
// 16383.1-16383.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
// 16384.1-16384.136: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
// 16385.1-16385.146: (15.3): AtomicMarkableReference.mark is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
// 16473.1-16473.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.mark (case J)
// 16474.1-16474.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.mark (case K)
// 16475.1-16475.99: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.mark (case L)
// 16565.1-16565.140: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
// 16566.1-16566.101: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
// 16567.1-16567.156: (7.3): AtomicMarkableReferenceResult.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
// 16690.1-16690.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case C)
// 16818.1-16818.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case D)
// 16819.1-16819.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.ref (case R)
// 16908.1-16908.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case F)
// 16909.1-16909.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case H)
// 16910.1-16910.144: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.ref (case I)
// 16998.1-16998.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
// 16999.1-16999.136: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
// 17000.1-17000.99: (7.3): AtomicMarkableReferenceResult.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
// 17090.1-17090.140: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
// 17091.1-17091.101: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
// 17092.1-17092.156: (8.3): AtomicMarkableReferenceResult.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
// 17215.1-17215.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case C)
// 17343.1-17343.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case D)
// 17344.1-17344.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReferenceResult.mark (case R)
// 17433.1-17433.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case F)
// 17434.1-17434.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case H)
// 17435.1-17435.144: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReferenceResult.mark (case I)
// 17523.1-17523.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
// 17524.1-17524.136: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
// 17525.1-17525.99: (8.3): AtomicMarkableReferenceResult.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
// 17615.1-17615.140: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
// 17616.1-17616.101: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
// 17617.1-17617.158: (14.3): AtomicMarkableReference.ref is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
// 17740.1-17740.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case C)
// 17868.1-17868.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case D)
// 17869.1-17869.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.ref (case R)
// 17958.1-17958.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.ref (case F)
// 17959.1-17959.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.ref (case H)
// 17960.1-17960.146: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.ref (case I)
// 18048.1-18048.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
// 18049.1-18049.136: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
// 18050.1-18050.99: (14.3): AtomicMarkableReference.ref is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
// 18140.1-18140.140: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
// 18141.1-18141.101: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
// 18142.1-18142.158: (15.3): AtomicMarkableReference.mark is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
// 18265.1-18265.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case C)
// 18393.1-18393.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case D)
// 18394.1-18394.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.mark (case R)
// 18483.1-18483.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.mark (case F)
// 18484.1-18484.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.mark (case H)
// 18485.1-18485.146: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.mark (case I)
// 18573.1-18573.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
// 18574.1-18574.136: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
// 18575.1-18575.99: (15.3): AtomicMarkableReference.mark is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
// 18665.1-18665.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.1)
// 18666.1-18666.101: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.2)
// 18667.1-18667.158: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case A.3)
// 18790.1-18790.140: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case C)
// 18918.1-18918.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case D)
// 18919.1-18919.144: (17.3): AtomicMarkableReference.nextWriter is not Write-Write Stable with respect to AtomicMarkableReference.nextWriter (case R)
// 19008.1-19008.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case F)
// 19009.1-19009.136: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case H)
// 19010.1-19010.146: (17.3): AtomicMarkableReference.nextWriter is not Read-Write Stable with respect to AtomicMarkableReference.nextWriter (case I)
// 19098.1-19098.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case J)
// 19099.1-19099.136: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case K)
// 19100.1-19100.99: (17.3): AtomicMarkableReference.nextWriter is not Write-Read Stable with respect to AtomicMarkableReference.nextWriter (case L)
// 19142.1-19171.2: (7.32): yields_as clause for Data._lock is not valid
// 19176.1-19200.2: (7.32): yields_as clause for Data._lock is not reflexive
// 19206.1-19254.2: (7.32): yields_as clause for Data._lock is not transitive
// 19273.1-19302.2: (7.3): yields_as clause for AtomicMarkableReferenceResult.ref is not valid
// 19307.1-19331.2: (7.3): yields_as clause for AtomicMarkableReferenceResult.ref is not reflexive
// 19337.1-19385.2: (7.3): yields_as clause for AtomicMarkableReferenceResult.ref is not transitive
// 19404.1-19433.2: (8.3): yields_as clause for AtomicMarkableReferenceResult.mark is not valid
// 19438.1-19462.2: (8.3): yields_as clause for AtomicMarkableReferenceResult.mark is not reflexive
// 19468.1-19516.2: (8.3): yields_as clause for AtomicMarkableReferenceResult.mark is not transitive
// 19536.1-19565.2: (7.32): yields_as clause for AtomicMarkableReferenceResult._lock is not valid
// 19570.1-19594.2: (7.32): yields_as clause for AtomicMarkableReferenceResult._lock is not reflexive
// 19600.1-19648.2: (7.32): yields_as clause for AtomicMarkableReferenceResult._lock is not transitive
// 19667.1-19696.2: (14.3): yields_as clause for AtomicMarkableReference.ref is not valid
// 19701.1-19725.2: (14.3): yields_as clause for AtomicMarkableReference.ref is not reflexive
// 19731.1-19779.2: (14.3): yields_as clause for AtomicMarkableReference.ref is not transitive
// 19798.1-19827.2: (15.3): yields_as clause for AtomicMarkableReference.mark is not valid
// 19832.1-19856.2: (15.3): yields_as clause for AtomicMarkableReference.mark is not reflexive
// 19862.1-19910.2: (15.3): yields_as clause for AtomicMarkableReference.mark is not transitive
// 19930.1-19959.2: (22.50): yields_as clause for AtomicMarkableReference.nextWriter is not valid
// 19964.1-19988.2: (22.50): yields_as clause for AtomicMarkableReference.nextWriter is not reflexive
// 19994.1-20042.2: (22.50): yields_as clause for AtomicMarkableReference.nextWriter is not transitive
// 20062.1-20091.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not valid
// 20096.1-20120.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not reflexive
// 20126.1-20174.2: (7.32): yields_as clause for AtomicMarkableReference._lock is not transitive
// 20194.1-20223.2: (7.32): yields_as clause for Main._lock is not valid
// 20228.1-20252.2: (7.32): yields_as clause for Main._lock is not reflexive
// 20258.1-20306.2: (7.32): yields_as clause for Main._lock is not transitive
